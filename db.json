{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/robots.txt","path":"robots.txt","modified":1,"renderable":0},{"_id":"themes/landscape-plus/source/css/bdshare.styl","path":"css/bdshare.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/img/scrollup.png","path":"img/scrollup.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/js/script.js","path":"js/script.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.eot","path":"css/fonts/coveredbyyourgrace-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.ttf","path":"css/fonts/coveredbyyourgrace-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.svg","path":"css/fonts/coveredbyyourgrace-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.woff","path":"css/fonts/coveredbyyourgrace-webfont.woff","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/robots.txt","hash":"abcb543c6c18a74874fc2a0474433408c1a68ad0","modified":1541550731521},{"_id":"themes/landscape-plus/.gitattributes","hash":"0dd57adb042e3d90c780c1c8bc867ad547381c64","modified":1526023543676},{"_id":"themes/landscape-plus/.gitignore","hash":"b8c8d05421ab1f9fc31cd3fd8714bae1cdc0058a","modified":1526023543676},{"_id":"themes/landscape-plus/LICENSE","hash":"82ce1e15ddeabeaaca60e2186b5a3ce42b1a9c49","modified":1526023543677},{"_id":"themes/landscape-plus/Gruntfile.js","hash":"412e30530784993c8997aa8b1319c669b83b91c2","modified":1526023543676},{"_id":"themes/landscape-plus/README.md","hash":"f7d0748ac684161a3fd368ab545bc192856baa23","modified":1526023543677},{"_id":"themes/landscape-plus/_config.yml","hash":"46e8cca1c5cefb04afe6f99ee70cce4a3ceda2ac","modified":1549952645649},{"_id":"themes/landscape-plus/package.json","hash":"5e1d9691a353097490e79c632563f1381c4a7b45","modified":1526023543736},{"_id":"source/_posts/Meteor-1.md","hash":"e99a9c190b42bce633934003a258b317d6c1dc59","modified":1549941465016},{"_id":"source/_posts/expert.md","hash":"adee5be4c0a9e9bbe401c52f9ce902b33700b17a","modified":1577696968721},{"_id":"source/_posts/ideal.md","hash":"2db3195c41f6ac774e4596c2682d592aa506f473","modified":1577696827473},{"_id":"source/_posts/hello-world.md","hash":"82bc92e1ad3d090e344dd03c9fd732aecc0d728e","modified":1549941465010},{"_id":"source/_posts/install-hexo.md","hash":"7c4601811a3d458ec73535e4ffd304eb9715cd6d","modified":1549941465014},{"_id":"source/_posts/slider4.jpg","hash":"7bfffd4cc375f918da249492bc52bc98d9e79882","modified":1560999970820},{"_id":"source/_posts/linux-ssh.md","hash":"cc82c6c57e8d1816e7b5bd5775ac27f9281ee227","modified":1549941465021},{"_id":"source/_posts/small_zhangben.png","hash":"216de75bad2fbdb0c2bb490eab388b7fc5203ae7","modified":1553869140694},{"_id":"source/_posts/thrift.md","hash":"6d5dd19a4f3f7b006672c5432027ec434b74fc0c","modified":1549941465018},{"_id":"source/_posts/wukong-story.md","hash":"cc72beb7071949f6cc7318a2131a63fe6fde08b9","modified":1549941465023},{"_id":"source/_posts/敏捷技能修炼笔记一.md","hash":"39f2d82f1cc65d87a985fd314a22e5939d4a8933","modified":1551081411664},{"_id":"themes/landscape-plus/languages/default.yml","hash":"e5dbafe7435258ffe14ce9bfaa4ae811c3d051a6","modified":1526023543679},{"_id":"themes/landscape-plus/languages/zh-CN.yml","hash":"f224865524474f40b2b632131a436c39aa2b6fbb","modified":1526023543679},{"_id":"themes/landscape-plus/languages/zh-TW.yml","hash":"2e6324ae793cb5210de5316454e934086415ae06","modified":1526023543680},{"_id":"themes/landscape-plus/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1526023543731},{"_id":"themes/landscape-plus/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1526023543732},{"_id":"themes/landscape-plus/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1526023543731},{"_id":"themes/landscape-plus/layout/layout.ejs","hash":"80ecd8cce6b9e57ca707982effada5ac6f887cf5","modified":1526023543733},{"_id":"themes/landscape-plus/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526023543734},{"_id":"themes/landscape-plus/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1526023543734},{"_id":"themes/landscape-plus/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1526023543735},{"_id":"themes/landscape-plus/scripts/fancybox.js","hash":"4c130fc242cf9b59b5df6ca5eae3b14302311e8c","modified":1526023543736},{"_id":"source/_posts/Meteor-2.md","hash":"d8dcd20a28addbe7c4b666ed353a8e3f03d71950","modified":1549941465027},{"_id":"source/_posts/现金日记账.png","hash":"ab5f48266398cb7cae23e961386ecfe99704fb0a","modified":1554110380164},{"_id":"source/_posts/账簿启用表.png","hash":"bdac34d42019183a1cc5d7a0abaf22ad60140176","modified":1554110439202},{"_id":"themes/landscape-plus/source/css/bdshare.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1526023543751},{"_id":"themes/landscape-plus/layout/_partial/after-footer.ejs","hash":"9e8787ba63acf00d5bab2cac85ad5d4518998f41","modified":1526023543681},{"_id":"themes/landscape-plus/layout/_partial/archive.ejs","hash":"e440311811c74c20cbdf70f6fd44fd4855d059ae","modified":1526023543682},{"_id":"themes/landscape-plus/layout/_partial/archive-post.ejs","hash":"5062c723721d8497eebad372f57092ade45041f4","modified":1526023543682},{"_id":"themes/landscape-plus/layout/_partial/article.ejs","hash":"96a47a6464279a3aef30fa50b069eeafe0a2ad90","modified":1526023543683},{"_id":"themes/landscape-plus/layout/_partial/footer.ejs","hash":"63d5c01192b856cd01108e40e25bc9606163a8a9","modified":1526023543683},{"_id":"themes/landscape-plus/layout/_partial/google-analytics.ejs","hash":"ade81710027f55371b1229548fee0754e09b07b6","modified":1526023543684},{"_id":"themes/landscape-plus/layout/_partial/head.ejs","hash":"1ea157526f4bce513fb75865d60c6a113f938356","modified":1526023543684},{"_id":"themes/landscape-plus/layout/_partial/header.ejs","hash":"a0a82b94f70fb6d9ef1703cb9bff72e77e02e268","modified":1526023543685},{"_id":"themes/landscape-plus/layout/_partial/mathjax.ejs","hash":"6c89e88bfbea77eae17f0934053d4ca691e019ce","modified":1526023543686},{"_id":"themes/landscape-plus/layout/_partial/mobile-nav.ejs","hash":"347cf1befd2ea637c24bd5901929d8e36e359e75","modified":1526023543687},{"_id":"themes/landscape-plus/layout/_partial/sidebar.ejs","hash":"c70869569749a8f48cce202fa57926c06b55fdab","modified":1526023543725},{"_id":"themes/landscape-plus/layout/_partial/totop.ejs","hash":"a94e7999f597d73dc50f05ba53ff422262f8333e","modified":1526023543726},{"_id":"themes/landscape-plus/layout/_widget/archive.ejs","hash":"3e07880f560b1c8462b19bc5003aaf67756edf09","modified":1526023543726},{"_id":"themes/landscape-plus/layout/_widget/category.ejs","hash":"864d6db41f5f9a653fd0f1f244a29cd45c73473b","modified":1526023543727},{"_id":"themes/landscape-plus/layout/_widget/links.ejs","hash":"de1cf7bcba48eb133988ac77c072088bc89f5d8e","modified":1526023543728},{"_id":"themes/landscape-plus/layout/_widget/recent_posts.ejs","hash":"16800f85ffb036d2644a26e02facd61acb3706e9","modified":1526023543729},{"_id":"themes/landscape-plus/layout/_widget/tag.ejs","hash":"20639d8b9bdb8dc0292a359125587aabb7f9575a","modified":1526023543729},{"_id":"themes/landscape-plus/layout/_widget/tagcloud.ejs","hash":"7259c179aa0c41c02e467ad892292e90430aaabc","modified":1526023543730},{"_id":"source/_posts/银行存款日记账.png","hash":"a58276783bad16c2800c4e0b1a79622f3838a899","modified":1554110379680},{"_id":"themes/landscape-plus/source/css/_extend.styl","hash":"71b4fc4d12fdd7a7f66a68ab0e9c832d2fa85ec1","modified":1526023543738},{"_id":"themes/landscape-plus/source/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1526023543821},{"_id":"themes/landscape-plus/source/css/_variables.styl","hash":"d99c6b42f7266e6e9078ca31fe8e218c3543c596","modified":1526023543751},{"_id":"themes/landscape-plus/source/css/style.styl","hash":"7f0f231b0456cffba8d5212a9d02b2056604eeba","modified":1526023543771},{"_id":"themes/landscape-plus/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1526023543772},{"_id":"themes/landscape-plus/source/js/script.js","hash":"d930c5ec3f3648425b1130922ef7eceb3fb5cda3","modified":1526023543822},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1526023543773},{"_id":"themes/landscape-plus/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1526023543806},{"_id":"themes/landscape-plus/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1526023543807},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1526023543809},{"_id":"themes/landscape-plus/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1526023543810},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.css","hash":"2e54d51d21e68ebc4bb870f6e57d3bfb660d4f9c","modified":1526023543817},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.js","hash":"58193c802f307ec9bc9e586c0e8a13ebef45d2f8","modified":1526023543819},{"_id":"themes/landscape-plus/source/fancybox/jquery.fancybox.pack.js","hash":"2da892a02778236b64076e5e8802ef0566e1d9e8","modified":1526023543820},{"_id":"source/_posts/jm_jzems.jpg","hash":"5fa43185a0317cfe027ad7e58eea6f79e09f7c9d","modified":1575884277382},{"_id":"source/_posts/jm_xxzp_0_1.jpg","hash":"847dd369ff3c7038fab44bcb9f346114916f4543","modified":1575884277235},{"_id":"themes/landscape-plus/layout/_partial/post/category.ejs","hash":"16128d2422645e18d1b6882d4c4df17d895bd76e","modified":1526023543688},{"_id":"themes/landscape-plus/layout/_partial/post/nav.ejs","hash":"cbb3819ce512bd24db8bad41b8617d46eba82fdc","modified":1526023543690},{"_id":"themes/landscape-plus/layout/_partial/post/date.ejs","hash":"947f513f7a85fbcf085624e46dc2ae6de8185eec","modified":1526023543688},{"_id":"themes/landscape-plus/layout/_partial/post/gallery.ejs","hash":"b0bf3f5d923c261ca2b5fabab513f1ec2708c8ca","modified":1526023543689},{"_id":"themes/landscape-plus/layout/_partial/post/tag.ejs","hash":"694b5101bcc44c9f9c1cc62e5ad2fdfb4b7c7a07","modified":1526023543690},{"_id":"themes/landscape-plus/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1526023543724},{"_id":"themes/landscape-plus/source/css/_partial/archive.styl","hash":"0cf17ec0c31831471b3144622e5973dbf6610ab4","modified":1526023543738},{"_id":"themes/landscape-plus/source/css/_partial/article.styl","hash":"81c1e0081d23bf8230f4303feb89f95e32f815e1","modified":1526023543739},{"_id":"themes/landscape-plus/source/css/_partial/comment.styl","hash":"2834870661e490775f9154d71638bfdc72e640a6","modified":1526023543740},{"_id":"themes/landscape-plus/source/css/_partial/footer.styl","hash":"6f7aa810f296d6a1a4486637b5a853d35a198938","modified":1526023543740},{"_id":"themes/landscape-plus/source/css/_partial/header.styl","hash":"ed7f915186f2e1d0158ec72d9760dc99a28a8fe3","modified":1526023543741},{"_id":"themes/landscape-plus/source/css/_partial/mobile.styl","hash":"680c7b809b62cd3ad294e822793fbd0b1a32cc33","modified":1526023543742},{"_id":"themes/landscape-plus/source/css/_partial/highlight.styl","hash":"bb4629ad76cb50ea103e6ef1a2b465b772b16dff","modified":1526023543742},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-aside.styl","hash":"2d3d264a34bee86abbefafd07e57beae415d28d5","modified":1526023543743},{"_id":"themes/landscape-plus/source/css/_partial/sidebar-bottom.styl","hash":"f6023861b2fbd858946e2108438b5f8f17586179","modified":1526023543744},{"_id":"themes/landscape-plus/source/css/_partial/sidebar.styl","hash":"0c91d8e0081cf2de5f729c8cf2f42c3a2ae5ccb6","modified":1526023543747},{"_id":"themes/landscape-plus/source/css/_partial/totop.styl","hash":"a5aadd9948941fca5b9289939562475d42d953a4","modified":1526023543748},{"_id":"themes/landscape-plus/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1526023543749},{"_id":"themes/landscape-plus/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1526023543750},{"_id":"themes/landscape-plus/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1526023543754},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1526023543755},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1526023543761},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1526023543767},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1526023543813},{"_id":"themes/landscape-plus/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1526023543812},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"4c9c395d705d22af7da06870d18f434e2a2eeaf9","modified":1526023543814},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-media.js","hash":"e14c32cc6823b81b2f758512f13ed8eb9ef2b454","modified":1526023543815},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1526023543816},{"_id":"themes/landscape-plus/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"83cdfea43632b613771691a11f56f99d85fb6dbd","modified":1526023543817},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1526023543759},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1526023543766},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1526023543757},{"_id":"themes/landscape-plus/source/css/fonts/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1526023543760},{"_id":"themes/landscape-plus/source/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1526023543764},{"_id":"themes/landscape-plus/source/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1526023543771},{"_id":"public/baidusitemap.xml","hash":"320ea57e3f7ec1306c2928106dceaab10f789a40","modified":1577937312848},{"_id":"public/sitemap.xml","hash":"8088b8b04a8a73c204f6f74e1639b5960c9c1604","modified":1577937313066},{"_id":"public/posts/42c1c098/index.html","hash":"dae437493a88674752981a90ac565feda570f359","modified":1577937313098},{"_id":"public/posts/53408/index.html","hash":"348feed2150b2e51f0d19345ac7e3b4971ab00e0","modified":1577937313098},{"_id":"public/posts/15069/index.html","hash":"0c4aef91e8bdec4679cb8d214d9c774fb4a137ad","modified":1577937313098},{"_id":"public/posts/54923/index.html","hash":"fe29e4010a9932c6a1aca0a3fcefc2211a7c1aa3","modified":1577937313098},{"_id":"public/posts/33643/index.html","hash":"10e6c734b80600e0bb81b26f842f09bc591d38f6","modified":1577937313098},{"_id":"public/archives/index.html","hash":"956562aebc3fca8361563c6c5cc5b3dbd39b4ae6","modified":1577937313098},{"_id":"public/archives/page/2/index.html","hash":"a989c79e44e3701ad61384496fca41c36b26be33","modified":1577937313098},{"_id":"public/archives/2016/index.html","hash":"b45723d0a701d46d9b52c77cc725c5aace292c01","modified":1577937313098},{"_id":"public/archives/2016/08/index.html","hash":"e38a35cd1decdcd21a448415f36a751fc4a601e4","modified":1577937313098},{"_id":"public/archives/2016/09/index.html","hash":"12979b5c9ea5d5a6a51b432a6de7bf33441c738d","modified":1577937313098},{"_id":"public/archives/2016/12/index.html","hash":"c99e0f7e93054514e8329e7ec122666cf3855f5a","modified":1577937313098},{"_id":"public/archives/2018/index.html","hash":"bdbdeef10bc58a7fa5f8c9625057bd18257501d2","modified":1577937313098},{"_id":"public/archives/2018/03/index.html","hash":"3fd2312bc39aa75dce4149da66f13aef762c1845","modified":1577937313098},{"_id":"public/archives/2018/05/index.html","hash":"5bef1381611fac56540697816212168fc0a576d0","modified":1577937313098},{"_id":"public/archives/2018/10/index.html","hash":"ab5ff0ce1409ca9b4cffb268141e6e6419da7e83","modified":1577937313098},{"_id":"public/archives/2019/index.html","hash":"7bf746cef9bf3e857aaf4b0b22aee21dd569c4d2","modified":1577937313098},{"_id":"public/archives/2019/02/index.html","hash":"69f5dd10b902f09b55a6587513df20795312a8fc","modified":1577937313098},{"_id":"public/archives/2020/index.html","hash":"a6225f123ec577196e9e0dc9d057e0e00dd54839","modified":1577937313098},{"_id":"public/archives/2020/01/index.html","hash":"7ca0ea2dddfddffbdeac2694523545ab06a59303","modified":1577937313098},{"_id":"public/categories/我的作品/index.html","hash":"2883e85cfc162c2d1a8279aee8007e1e83f7887c","modified":1577937313098},{"_id":"public/categories/敏捷开发/index.html","hash":"29439122b91e4c1424cb5b8f46d7e620562aca4f","modified":1577937313098},{"_id":"public/tags/出纳专家旗舰版/index.html","hash":"f5236278b7e29bb3034cee1dd4b2d56bca196be4","modified":1577937313098},{"_id":"public/tags/全真打印软件/index.html","hash":"9ac592508d3ae7971b0d2ad46325418cb9d53cc7","modified":1577937313098},{"_id":"public/tags/你的第一个Meteor应用/index.html","hash":"ab3c0dc49ab31b5ad7cf3ccec67d369e43e01e71","modified":1577937313098},{"_id":"public/tags/西游记外传之金箍棒之殇/index.html","hash":"3524125456cfaae3e8ae765edc6e5a5f54d87fc1","modified":1577937313098},{"_id":"public/tags/编译thrift0-11/index.html","hash":"fc3cd26c3843c71a5039d2c480c6a5c5b0c11624","modified":1577937313098},{"_id":"public/tags/网络安全/index.html","hash":"1aed95ea841981838f6b48cf3242420991e79305","modified":1577937313098},{"_id":"public/tags/敏捷技能修炼/index.html","hash":"09584df6d2e14287cb0326f8304ec9a39efcc45d","modified":1577937313098},{"_id":"public/posts/190a037f/index.html","hash":"d157129784cfdb158ccc3af7a197f10625fa84c8","modified":1577937313098},{"_id":"public/posts/99b996d5/index.html","hash":"45fe62c845da6051b6d4da0b8a0762bb61438d59","modified":1577937313098},{"_id":"public/posts/31784/index.html","hash":"2cfd8c8ad2c2fc870ad09d6514c52b951fa7d9de","modified":1577937313098},{"_id":"public/posts/51156/index.html","hash":"83d4082619a8875afbfcb0a3e13e816f8513aff0","modified":1577937313098},{"_id":"public/posts/49028/index.html","hash":"26ada762ed2cf134a1865dadf3d4a5c3709c8150","modified":1577937313098},{"_id":"public/index.html","hash":"b14bf419f4b068e23354fa157d7ca9b15201c8b2","modified":1577937313098},{"_id":"public/page/2/index.html","hash":"774ea63d642d37bf8596b8bfa3a9755a6cd84e5e","modified":1577937313098},{"_id":"public/robots.txt","hash":"abcb543c6c18a74874fc2a0474433408c1a68ad0","modified":1577937313113},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1577937313113},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1577937313113},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1577937313113},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1577937313113},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1577937313113},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1577937313113},{"_id":"public/css/fonts/coveredbyyourgrace-webfont.eot","hash":"a17d0f10534303e40f210c506ebb8703fa23b7de","modified":1577937313113},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1577937313113},{"_id":"public/css/fonts/coveredbyyourgrace-webfont.ttf","hash":"194ccb4acf77a03dc25bcc174edb266143704fec","modified":1577937313113},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1577937313113},{"_id":"public/css/fonts/coveredbyyourgrace-webfont.woff","hash":"c6f8dc1a2f6ce914f120e80a876b8fd77b98888e","modified":1577937313113},{"_id":"public/img/scrollup.png","hash":"2137d4f1739aa8aa3fcb0348c3ddf1e41d62f2e3","modified":1577937313113},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1577937314285},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1577937314285},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1577937314285},{"_id":"public/css/fonts/coveredbyyourgrace-webfont.svg","hash":"739808e56a56e10a03bc93d03eb55abd19590942","modified":1577937314285},{"_id":"public/css/bdshare.css","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1577937314301},{"_id":"public/js/script.js","hash":"89f3a9ba53e1481a0609cbb62e9530ca339b052d","modified":1577937314301},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1577937314301},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1577937314301},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1577937314301},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1577937314301},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1577937314301},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1577937314301},{"_id":"public/css/style.css","hash":"af7575626f362ed6f949019d8470f1ed42b60853","modified":1577937314301},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1577937314316},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"a275426daefd3716c53561fad121d258a7f05b47","modified":1577937314316},{"_id":"public/css/images/banner.jpg","hash":"843d9d47bf2b7b75495db11b3d765efaaae442a9","modified":1577937314316},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1577937314363}],"Category":[{"name":"我的作品","_id":"ck4w74u3r0002acelllplz0gh"},{"name":"敏捷开发","_id":"ck4w74u5y000pacelsxe10xxw"}],"Data":[],"Page":[],"Post":[{"title":"出纳专家旗舰版","comments":1,"abbrlink":"190a037f","date":"2020-01-01T10:54:59.000Z","_content":"---\n\n\n## 出纳专家旗舰版\n\n<div style =\"float:right\">\n![《出纳专家》有时光机的出纳软件--始于2001年](small_zhangben.png )\n</div>\n\n《出纳专家》全真帐页化操作与输出的出纳软件，实用又简单。让你工作事半功倍。\n\n* **时光机**，时光机，让您永久告别数据丢失、损坏！真安全。\n* **在线升级**，自动升级检测，时刻都是最新的系统。\n---\n* **真帐页**，如纸质帐本的软件界面\n* **真好用**，使用象在帐页上记帐一样简单\n* **真直观**，自然年月日分层结构体系\n* **真实用**，打印输出的帐页可直接存档\n\n<div style =\"clear:both\" align=\"center\">\n        <a href=\"http://oss.myqzz.net/expert/出纳专家安装.rar\" alt=\"\" title=\"立即下载《出纳专家2019》\" id=\"download\">立即下载</a>\n        <p>支持Windows 7及以上系统</p>\n</div>\n\n---\n### 您是否遇到过以下烦恼？\n\n#### 数据备份焦虑？\n你是否每天打开电脑记账前都会在心里祈祷：“电脑千万别出问题，里面可存了我几年的数据！”\n上次电脑故障，工程师上门修好了，搞了一天，也没有找回我的数据。\n“你们的软件不是有自动备份至D盘了，万无一失了吗？”\n“可是你硬盘坏了，备到哪个盘我们也无能为力呀！”\n搞得现在你每次记完账都会下意识地看看屏幕右侧你亲手做的贴纸：“记得备份哟！”\n然后默默地从左边最下面的抽屉里拿出移动硬盘，导出备份，一颗悬着的心，才算落地！\n \n#### 数据安全焦虑？\n\n我现在每次进记账网页的时候，都会拿出我的小本子，输入长达21位的大小写混合外加特殊字符的密码，没办法，我永远也忘不了那次竞争对手说出我的现金流精确到分时我的惊讶，他们竟然能猜到我长达11位的密码！\n最好的密码是自己也记不住的密码！\n所以我随身携带这个小本子，上面记着我自己都不记得的密码，我再也不想体会那种被扒光底裤的感觉了。\n现在的问题是：这个小本子，成了我的命根子！\n \n#### 软件操作的焦虑？\n当初为了胜任这份工作，我花了两万多块，参加了三个培训班，学会了用友、金蝶、新中大等多款财务软件的安装、设置、与使用，现在，我正在用财务软件记账，但我自己养成了一个习惯，总是把现金账与银行账在EXCEL里面再记一份，不为别的，自己查询方便，我不用为了查询一个简单的数字，登录系统、输入长达18位的密码，等待1分32秒，进入查询界面，输入查询条件，点查询按钮，54秒后，返回了43条记录，分了三页显示，找到我要查找的数据，一次要花掉我4分47秒的时间，这还得感谢今天网络无故障。而从我的EXCEL中查找，我要不了一分钟。\n \n#### 关于完美的焦虑？\n我们公司上市多年了却还一直用手工记账，不为别的，作为一个出纳会计，我对工作有着近乎苛刻的要求，我觉得我记的每一笔账，都是完美而精确的，它应该是一件艺术品，可这样的内容如果将它填入EXCEL样粗制滥造的表格里，对它是一种亵渎，我就喜欢方正简体楷书14号字的账本标题；仿宋12号字体的金额显示，楷体12号字体的金额栏位，一切都是那么完美，一如我手上的这套账簿，可世上哪有如此完美的记账软件呢？所以，我每天依然会拿出我的账簿，记下我的艺术。\n \n#### 小人破坏的焦虑？\n我一直对在线记账数据很有信心，直到有一次，公司出纳离岗，手续办完后，我们发现公司账对不上。财务部全体员工加班一周，终于在3587张凭证中找出几个月前的几笔数据与电脑不一致的数据，总算修复了错误，从此，我只能祈祷人事部招聘回来的员工的人品。\n\n......\n\n### 您需要《出纳专家》 \n\n\n* **漂亮：**细节精美如艺术品，经得起您用放大镜品鉴！更有自定义支持，全方位满足您的审美需求！\n* **安全：**本地密码、时光机密码、手机验证，三重安全防护。确保数据安全。\n* **省心：**“时光机”让您彻底告别数据丢、乱困扰。再也不用担心备份没做、备份文件损坏，甚至不用担心人为数据的破坏。哪怕电脑被洪水冲走了，您也不用担心。\n* **省时：**安装快：2.38M——不到同类软件十分之一的体积，下载安装十秒完成；打开快，本地验证，告别网络延迟与连接等待；使用快：全真账页操作，单击即开始记账；备份快：“记住此刻”按钮一点，备份完成。故障恢复快：重新安装到从“时光机”恢复，全过程一分钟内即可完成。\n* **省钱：**一天一块钱，即可高枕无忧！还送配套票据打印软件。一元钱搞定记账与票据打印。超级值！\n\n\n---\n\n\n### 现金日记账\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](现金日记账.png )\n\n\n</div>\n\n### 银行存款日记账\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](银行存款日记账.png )\n\n\n</div>\n\n\n### 账簿启用表\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](账簿启用表.png )\n\n\n</div>","source":"_posts/expert.md","raw":"---\ntitle: 出纳专家旗舰版\ncomments: true\ncategories: 我的作品\ntags: 出纳专家旗舰版\nabbrlink: 190a037f\ndate: 2020-01-01 18:54:59\n---\n---\n\n\n## 出纳专家旗舰版\n\n<div style =\"float:right\">\n![《出纳专家》有时光机的出纳软件--始于2001年](small_zhangben.png )\n</div>\n\n《出纳专家》全真帐页化操作与输出的出纳软件，实用又简单。让你工作事半功倍。\n\n* **时光机**，时光机，让您永久告别数据丢失、损坏！真安全。\n* **在线升级**，自动升级检测，时刻都是最新的系统。\n---\n* **真帐页**，如纸质帐本的软件界面\n* **真好用**，使用象在帐页上记帐一样简单\n* **真直观**，自然年月日分层结构体系\n* **真实用**，打印输出的帐页可直接存档\n\n<div style =\"clear:both\" align=\"center\">\n        <a href=\"http://oss.myqzz.net/expert/出纳专家安装.rar\" alt=\"\" title=\"立即下载《出纳专家2019》\" id=\"download\">立即下载</a>\n        <p>支持Windows 7及以上系统</p>\n</div>\n\n---\n### 您是否遇到过以下烦恼？\n\n#### 数据备份焦虑？\n你是否每天打开电脑记账前都会在心里祈祷：“电脑千万别出问题，里面可存了我几年的数据！”\n上次电脑故障，工程师上门修好了，搞了一天，也没有找回我的数据。\n“你们的软件不是有自动备份至D盘了，万无一失了吗？”\n“可是你硬盘坏了，备到哪个盘我们也无能为力呀！”\n搞得现在你每次记完账都会下意识地看看屏幕右侧你亲手做的贴纸：“记得备份哟！”\n然后默默地从左边最下面的抽屉里拿出移动硬盘，导出备份，一颗悬着的心，才算落地！\n \n#### 数据安全焦虑？\n\n我现在每次进记账网页的时候，都会拿出我的小本子，输入长达21位的大小写混合外加特殊字符的密码，没办法，我永远也忘不了那次竞争对手说出我的现金流精确到分时我的惊讶，他们竟然能猜到我长达11位的密码！\n最好的密码是自己也记不住的密码！\n所以我随身携带这个小本子，上面记着我自己都不记得的密码，我再也不想体会那种被扒光底裤的感觉了。\n现在的问题是：这个小本子，成了我的命根子！\n \n#### 软件操作的焦虑？\n当初为了胜任这份工作，我花了两万多块，参加了三个培训班，学会了用友、金蝶、新中大等多款财务软件的安装、设置、与使用，现在，我正在用财务软件记账，但我自己养成了一个习惯，总是把现金账与银行账在EXCEL里面再记一份，不为别的，自己查询方便，我不用为了查询一个简单的数字，登录系统、输入长达18位的密码，等待1分32秒，进入查询界面，输入查询条件，点查询按钮，54秒后，返回了43条记录，分了三页显示，找到我要查找的数据，一次要花掉我4分47秒的时间，这还得感谢今天网络无故障。而从我的EXCEL中查找，我要不了一分钟。\n \n#### 关于完美的焦虑？\n我们公司上市多年了却还一直用手工记账，不为别的，作为一个出纳会计，我对工作有着近乎苛刻的要求，我觉得我记的每一笔账，都是完美而精确的，它应该是一件艺术品，可这样的内容如果将它填入EXCEL样粗制滥造的表格里，对它是一种亵渎，我就喜欢方正简体楷书14号字的账本标题；仿宋12号字体的金额显示，楷体12号字体的金额栏位，一切都是那么完美，一如我手上的这套账簿，可世上哪有如此完美的记账软件呢？所以，我每天依然会拿出我的账簿，记下我的艺术。\n \n#### 小人破坏的焦虑？\n我一直对在线记账数据很有信心，直到有一次，公司出纳离岗，手续办完后，我们发现公司账对不上。财务部全体员工加班一周，终于在3587张凭证中找出几个月前的几笔数据与电脑不一致的数据，总算修复了错误，从此，我只能祈祷人事部招聘回来的员工的人品。\n\n......\n\n### 您需要《出纳专家》 \n\n\n* **漂亮：**细节精美如艺术品，经得起您用放大镜品鉴！更有自定义支持，全方位满足您的审美需求！\n* **安全：**本地密码、时光机密码、手机验证，三重安全防护。确保数据安全。\n* **省心：**“时光机”让您彻底告别数据丢、乱困扰。再也不用担心备份没做、备份文件损坏，甚至不用担心人为数据的破坏。哪怕电脑被洪水冲走了，您也不用担心。\n* **省时：**安装快：2.38M——不到同类软件十分之一的体积，下载安装十秒完成；打开快，本地验证，告别网络延迟与连接等待；使用快：全真账页操作，单击即开始记账；备份快：“记住此刻”按钮一点，备份完成。故障恢复快：重新安装到从“时光机”恢复，全过程一分钟内即可完成。\n* **省钱：**一天一块钱，即可高枕无忧！还送配套票据打印软件。一元钱搞定记账与票据打印。超级值！\n\n\n---\n\n\n### 现金日记账\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](现金日记账.png )\n\n\n</div>\n\n### 银行存款日记账\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](银行存款日记账.png )\n\n\n</div>\n\n\n### 账簿启用表\n\n<div style =\"float:right\">\n\n![《出纳专家》有时光机的出纳软件--始于2001年](账簿启用表.png )\n\n\n</div>","slug":"expert","published":1,"updated":"2019-12-30T09:09:28.721Z","layout":"post","photos":[],"link":"","_id":"ck4w74u3c0000acelres86ti8","content":"<hr>\n<h2 id=\"出纳专家旗舰版\"><a href=\"#出纳专家旗舰版\" class=\"headerlink\" title=\"出纳专家旗舰版\"></a>出纳专家旗舰版</h2><div style=\"float:right\"><br><img src=\"small_zhangben.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br></div>\n\n<p>《出纳专家》全真帐页化操作与输出的出纳软件，实用又简单。让你工作事半功倍。</p>\n<ul>\n<li><strong>时光机</strong>，时光机，让您永久告别数据丢失、损坏！真安全。</li>\n<li><strong>在线升级</strong>，自动升级检测，时刻都是最新的系统。</li>\n</ul>\n<hr>\n<ul>\n<li><strong>真帐页</strong>，如纸质帐本的软件界面</li>\n<li><strong>真好用</strong>，使用象在帐页上记帐一样简单</li>\n<li><strong>真直观</strong>，自然年月日分层结构体系</li>\n<li><strong>真实用</strong>，打印输出的帐页可直接存档</li>\n</ul>\n<div style=\"clear:both\" align=\"center\"><br>        <a href=\"http://oss.myqzz.net/expert/出纳专家安装.rar\" alt=\"\" title=\"立即下载《出纳专家2019》\" id=\"download\" target=\"_blank\" rel=\"noopener\">立即下载</a><br>        <p>支持Windows 7及以上系统</p><br></div>\n\n<hr>\n<h3 id=\"您是否遇到过以下烦恼？\"><a href=\"#您是否遇到过以下烦恼？\" class=\"headerlink\" title=\"您是否遇到过以下烦恼？\"></a>您是否遇到过以下烦恼？</h3><h4 id=\"数据备份焦虑？\"><a href=\"#数据备份焦虑？\" class=\"headerlink\" title=\"数据备份焦虑？\"></a>数据备份焦虑？</h4><p>你是否每天打开电脑记账前都会在心里祈祷：“电脑千万别出问题，里面可存了我几年的数据！”<br>上次电脑故障，工程师上门修好了，搞了一天，也没有找回我的数据。<br>“你们的软件不是有自动备份至D盘了，万无一失了吗？”<br>“可是你硬盘坏了，备到哪个盘我们也无能为力呀！”<br>搞得现在你每次记完账都会下意识地看看屏幕右侧你亲手做的贴纸：“记得备份哟！”<br>然后默默地从左边最下面的抽屉里拿出移动硬盘，导出备份，一颗悬着的心，才算落地！\n </p>\n<h4 id=\"数据安全焦虑？\"><a href=\"#数据安全焦虑？\" class=\"headerlink\" title=\"数据安全焦虑？\"></a>数据安全焦虑？</h4><p>我现在每次进记账网页的时候，都会拿出我的小本子，输入长达21位的大小写混合外加特殊字符的密码，没办法，我永远也忘不了那次竞争对手说出我的现金流精确到分时我的惊讶，他们竟然能猜到我长达11位的密码！<br>最好的密码是自己也记不住的密码！<br>所以我随身携带这个小本子，上面记着我自己都不记得的密码，我再也不想体会那种被扒光底裤的感觉了。<br>现在的问题是：这个小本子，成了我的命根子！\n </p>\n<h4 id=\"软件操作的焦虑？\"><a href=\"#软件操作的焦虑？\" class=\"headerlink\" title=\"软件操作的焦虑？\"></a>软件操作的焦虑？</h4><p>当初为了胜任这份工作，我花了两万多块，参加了三个培训班，学会了用友、金蝶、新中大等多款财务软件的安装、设置、与使用，现在，我正在用财务软件记账，但我自己养成了一个习惯，总是把现金账与银行账在EXCEL里面再记一份，不为别的，自己查询方便，我不用为了查询一个简单的数字，登录系统、输入长达18位的密码，等待1分32秒，进入查询界面，输入查询条件，点查询按钮，54秒后，返回了43条记录，分了三页显示，找到我要查找的数据，一次要花掉我4分47秒的时间，这还得感谢今天网络无故障。而从我的EXCEL中查找，我要不了一分钟。\n </p>\n<h4 id=\"关于完美的焦虑？\"><a href=\"#关于完美的焦虑？\" class=\"headerlink\" title=\"关于完美的焦虑？\"></a>关于完美的焦虑？</h4><p>我们公司上市多年了却还一直用手工记账，不为别的，作为一个出纳会计，我对工作有着近乎苛刻的要求，我觉得我记的每一笔账，都是完美而精确的，它应该是一件艺术品，可这样的内容如果将它填入EXCEL样粗制滥造的表格里，对它是一种亵渎，我就喜欢方正简体楷书14号字的账本标题；仿宋12号字体的金额显示，楷体12号字体的金额栏位，一切都是那么完美，一如我手上的这套账簿，可世上哪有如此完美的记账软件呢？所以，我每天依然会拿出我的账簿，记下我的艺术。\n </p>\n<h4 id=\"小人破坏的焦虑？\"><a href=\"#小人破坏的焦虑？\" class=\"headerlink\" title=\"小人破坏的焦虑？\"></a>小人破坏的焦虑？</h4><p>我一直对在线记账数据很有信心，直到有一次，公司出纳离岗，手续办完后，我们发现公司账对不上。财务部全体员工加班一周，终于在3587张凭证中找出几个月前的几笔数据与电脑不一致的数据，总算修复了错误，从此，我只能祈祷人事部招聘回来的员工的人品。</p>\n<p>……</p>\n<h3 id=\"您需要《出纳专家》\"><a href=\"#您需要《出纳专家》\" class=\"headerlink\" title=\"您需要《出纳专家》 \"></a>您需要《出纳专家》 </h3><ul>\n<li><strong>漂亮：</strong>细节精美如艺术品，经得起您用放大镜品鉴！更有自定义支持，全方位满足您的审美需求！</li>\n<li><strong>安全：</strong>本地密码、时光机密码、手机验证，三重安全防护。确保数据安全。</li>\n<li><strong>省心：</strong>“时光机”让您彻底告别数据丢、乱困扰。再也不用担心备份没做、备份文件损坏，甚至不用担心人为数据的破坏。哪怕电脑被洪水冲走了，您也不用担心。</li>\n<li><strong>省时：</strong>安装快：2.38M——不到同类软件十分之一的体积，下载安装十秒完成；打开快，本地验证，告别网络延迟与连接等待；使用快：全真账页操作，单击即开始记账；备份快：“记住此刻”按钮一点，备份完成。故障恢复快：重新安装到从“时光机”恢复，全过程一分钟内即可完成。</li>\n<li><strong>省钱：</strong>一天一块钱，即可高枕无忧！还送配套票据打印软件。一元钱搞定记账与票据打印。超级值！</li>\n</ul>\n<hr>\n<h3 id=\"现金日记账\"><a href=\"#现金日记账\" class=\"headerlink\" title=\"现金日记账\"></a>现金日记账</h3><div style=\"float:right\"><br><br><img src=\"现金日记账.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>\n\n<h3 id=\"银行存款日记账\"><a href=\"#银行存款日记账\" class=\"headerlink\" title=\"银行存款日记账\"></a>银行存款日记账</h3><div style=\"float:right\"><br><br><img src=\"银行存款日记账.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>\n\n\n<h3 id=\"账簿启用表\"><a href=\"#账簿启用表\" class=\"headerlink\" title=\"账簿启用表\"></a>账簿启用表</h3><div style=\"float:right\"><br><br><img src=\"账簿启用表.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>","site":{"data":{}},"excerpt":"","more":"<hr>\n<h2 id=\"出纳专家旗舰版\"><a href=\"#出纳专家旗舰版\" class=\"headerlink\" title=\"出纳专家旗舰版\"></a>出纳专家旗舰版</h2><div style=\"float:right\"><br><img src=\"small_zhangben.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br></div>\n\n<p>《出纳专家》全真帐页化操作与输出的出纳软件，实用又简单。让你工作事半功倍。</p>\n<ul>\n<li><strong>时光机</strong>，时光机，让您永久告别数据丢失、损坏！真安全。</li>\n<li><strong>在线升级</strong>，自动升级检测，时刻都是最新的系统。</li>\n</ul>\n<hr>\n<ul>\n<li><strong>真帐页</strong>，如纸质帐本的软件界面</li>\n<li><strong>真好用</strong>，使用象在帐页上记帐一样简单</li>\n<li><strong>真直观</strong>，自然年月日分层结构体系</li>\n<li><strong>真实用</strong>，打印输出的帐页可直接存档</li>\n</ul>\n<div style=\"clear:both\" align=\"center\"><br>        <a href=\"http://oss.myqzz.net/expert/出纳专家安装.rar\" alt=\"\" title=\"立即下载《出纳专家2019》\" id=\"download\" target=\"_blank\" rel=\"noopener\">立即下载</a><br>        <p>支持Windows 7及以上系统</p><br></div>\n\n<hr>\n<h3 id=\"您是否遇到过以下烦恼？\"><a href=\"#您是否遇到过以下烦恼？\" class=\"headerlink\" title=\"您是否遇到过以下烦恼？\"></a>您是否遇到过以下烦恼？</h3><h4 id=\"数据备份焦虑？\"><a href=\"#数据备份焦虑？\" class=\"headerlink\" title=\"数据备份焦虑？\"></a>数据备份焦虑？</h4><p>你是否每天打开电脑记账前都会在心里祈祷：“电脑千万别出问题，里面可存了我几年的数据！”<br>上次电脑故障，工程师上门修好了，搞了一天，也没有找回我的数据。<br>“你们的软件不是有自动备份至D盘了，万无一失了吗？”<br>“可是你硬盘坏了，备到哪个盘我们也无能为力呀！”<br>搞得现在你每次记完账都会下意识地看看屏幕右侧你亲手做的贴纸：“记得备份哟！”<br>然后默默地从左边最下面的抽屉里拿出移动硬盘，导出备份，一颗悬着的心，才算落地！\n </p>\n<h4 id=\"数据安全焦虑？\"><a href=\"#数据安全焦虑？\" class=\"headerlink\" title=\"数据安全焦虑？\"></a>数据安全焦虑？</h4><p>我现在每次进记账网页的时候，都会拿出我的小本子，输入长达21位的大小写混合外加特殊字符的密码，没办法，我永远也忘不了那次竞争对手说出我的现金流精确到分时我的惊讶，他们竟然能猜到我长达11位的密码！<br>最好的密码是自己也记不住的密码！<br>所以我随身携带这个小本子，上面记着我自己都不记得的密码，我再也不想体会那种被扒光底裤的感觉了。<br>现在的问题是：这个小本子，成了我的命根子！\n </p>\n<h4 id=\"软件操作的焦虑？\"><a href=\"#软件操作的焦虑？\" class=\"headerlink\" title=\"软件操作的焦虑？\"></a>软件操作的焦虑？</h4><p>当初为了胜任这份工作，我花了两万多块，参加了三个培训班，学会了用友、金蝶、新中大等多款财务软件的安装、设置、与使用，现在，我正在用财务软件记账，但我自己养成了一个习惯，总是把现金账与银行账在EXCEL里面再记一份，不为别的，自己查询方便，我不用为了查询一个简单的数字，登录系统、输入长达18位的密码，等待1分32秒，进入查询界面，输入查询条件，点查询按钮，54秒后，返回了43条记录，分了三页显示，找到我要查找的数据，一次要花掉我4分47秒的时间，这还得感谢今天网络无故障。而从我的EXCEL中查找，我要不了一分钟。\n </p>\n<h4 id=\"关于完美的焦虑？\"><a href=\"#关于完美的焦虑？\" class=\"headerlink\" title=\"关于完美的焦虑？\"></a>关于完美的焦虑？</h4><p>我们公司上市多年了却还一直用手工记账，不为别的，作为一个出纳会计，我对工作有着近乎苛刻的要求，我觉得我记的每一笔账，都是完美而精确的，它应该是一件艺术品，可这样的内容如果将它填入EXCEL样粗制滥造的表格里，对它是一种亵渎，我就喜欢方正简体楷书14号字的账本标题；仿宋12号字体的金额显示，楷体12号字体的金额栏位，一切都是那么完美，一如我手上的这套账簿，可世上哪有如此完美的记账软件呢？所以，我每天依然会拿出我的账簿，记下我的艺术。\n </p>\n<h4 id=\"小人破坏的焦虑？\"><a href=\"#小人破坏的焦虑？\" class=\"headerlink\" title=\"小人破坏的焦虑？\"></a>小人破坏的焦虑？</h4><p>我一直对在线记账数据很有信心，直到有一次，公司出纳离岗，手续办完后，我们发现公司账对不上。财务部全体员工加班一周，终于在3587张凭证中找出几个月前的几笔数据与电脑不一致的数据，总算修复了错误，从此，我只能祈祷人事部招聘回来的员工的人品。</p>\n<p>……</p>\n<h3 id=\"您需要《出纳专家》\"><a href=\"#您需要《出纳专家》\" class=\"headerlink\" title=\"您需要《出纳专家》 \"></a>您需要《出纳专家》 </h3><ul>\n<li><strong>漂亮：</strong>细节精美如艺术品，经得起您用放大镜品鉴！更有自定义支持，全方位满足您的审美需求！</li>\n<li><strong>安全：</strong>本地密码、时光机密码、手机验证，三重安全防护。确保数据安全。</li>\n<li><strong>省心：</strong>“时光机”让您彻底告别数据丢、乱困扰。再也不用担心备份没做、备份文件损坏，甚至不用担心人为数据的破坏。哪怕电脑被洪水冲走了，您也不用担心。</li>\n<li><strong>省时：</strong>安装快：2.38M——不到同类软件十分之一的体积，下载安装十秒完成；打开快，本地验证，告别网络延迟与连接等待；使用快：全真账页操作，单击即开始记账；备份快：“记住此刻”按钮一点，备份完成。故障恢复快：重新安装到从“时光机”恢复，全过程一分钟内即可完成。</li>\n<li><strong>省钱：</strong>一天一块钱，即可高枕无忧！还送配套票据打印软件。一元钱搞定记账与票据打印。超级值！</li>\n</ul>\n<hr>\n<h3 id=\"现金日记账\"><a href=\"#现金日记账\" class=\"headerlink\" title=\"现金日记账\"></a>现金日记账</h3><div style=\"float:right\"><br><br><img src=\"现金日记账.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>\n\n<h3 id=\"银行存款日记账\"><a href=\"#银行存款日记账\" class=\"headerlink\" title=\"银行存款日记账\"></a>银行存款日记账</h3><div style=\"float:right\"><br><br><img src=\"银行存款日记账.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>\n\n\n<h3 id=\"账簿启用表\"><a href=\"#账簿启用表\" class=\"headerlink\" title=\"账簿启用表\"></a>账簿启用表</h3><div style=\"float:right\"><br><br><img src=\"账簿启用表.png\" alt=\"《出纳专家》有时光机的出纳软件--始于2001年\"><br><br><br></div>"},{"title":"全真打印软件","comments":1,"abbrlink":"42c1c098","date":"2020-01-01T10:54:59.000Z","_content":"\n\n![](jm_xxzp_0_1.jpg \"《全真打印软件》主界面\")\n\n## 《全真打印软件》有哪些真功夫？\n\n## 技术优势：\n* 专业。支持云存储，数据无忧。（时光机）\n* 安全。支持手机验证，数据恢复手机验证。\n* 简单。无需复杂设置，每种票据仅需要打印一次取得偏移即可进行实际打印。\n* 直观。《全真打印软件》所有操作均基于真实票据图象，软件中看到的，就是您的打印效果。\n* 精准。《全真打印软件》的打印精度精确到一厘米的百分之一。\n* 开放。《全真打印软件》中您可以轻松定制自己的专用票据、单据、合同、表格。\n* 普适。《全真打印软件》支持针式、激光、喷墨、热敏等主流打印机。\n* 智能。《全真打印软件》全面支持在线更新。\n---\n\n### 安全：\n\n* 绿色无插件无广告。\n* 数据均加密存储。\n\n---\n\n当然，以上这些还远远不够。\n\n它还有一项巨大的优势：\n\n### 价格：《全真打印软件》，免费的！\n\n还等什么，还不下载使用？\n<div id=\"context_center\">\n        <a href=\"http://oss.myqzz.net/aime/全真打印软件安装.rar\" alt=\"\" title=\"立即下载《全真打印软件》\" id=\"download\">立即下载</a>\n</div>\n","source":"_posts/ideal.md","raw":"---\ntitle: 全真打印软件\ncomments: true\ncategories: 我的作品\ntags: 全真打印软件\nabbrlink: 42c1c098\ndate: 2020-01-01 18:54:59\n---\n\n\n![](jm_xxzp_0_1.jpg \"《全真打印软件》主界面\")\n\n## 《全真打印软件》有哪些真功夫？\n\n## 技术优势：\n* 专业。支持云存储，数据无忧。（时光机）\n* 安全。支持手机验证，数据恢复手机验证。\n* 简单。无需复杂设置，每种票据仅需要打印一次取得偏移即可进行实际打印。\n* 直观。《全真打印软件》所有操作均基于真实票据图象，软件中看到的，就是您的打印效果。\n* 精准。《全真打印软件》的打印精度精确到一厘米的百分之一。\n* 开放。《全真打印软件》中您可以轻松定制自己的专用票据、单据、合同、表格。\n* 普适。《全真打印软件》支持针式、激光、喷墨、热敏等主流打印机。\n* 智能。《全真打印软件》全面支持在线更新。\n---\n\n### 安全：\n\n* 绿色无插件无广告。\n* 数据均加密存储。\n\n---\n\n当然，以上这些还远远不够。\n\n它还有一项巨大的优势：\n\n### 价格：《全真打印软件》，免费的！\n\n还等什么，还不下载使用？\n<div id=\"context_center\">\n        <a href=\"http://oss.myqzz.net/aime/全真打印软件安装.rar\" alt=\"\" title=\"立即下载《全真打印软件》\" id=\"download\">立即下载</a>\n</div>\n","slug":"ideal","published":1,"updated":"2019-12-30T09:07:07.473Z","layout":"post","photos":[],"link":"","_id":"ck4w74u3r0001acelqn3y0qog","content":"<p><img src=\"jm_xxzp_0_1.jpg\" alt=\"\" title=\"《全真打印软件》主界面\"></p>\n<h2 id=\"《全真打印软件》有哪些真功夫？\"><a href=\"#《全真打印软件》有哪些真功夫？\" class=\"headerlink\" title=\"《全真打印软件》有哪些真功夫？\"></a>《全真打印软件》有哪些真功夫？</h2><h2 id=\"技术优势：\"><a href=\"#技术优势：\" class=\"headerlink\" title=\"技术优势：\"></a>技术优势：</h2><ul>\n<li>专业。支持云存储，数据无忧。（时光机）</li>\n<li>安全。支持手机验证，数据恢复手机验证。</li>\n<li>简单。无需复杂设置，每种票据仅需要打印一次取得偏移即可进行实际打印。</li>\n<li>直观。《全真打印软件》所有操作均基于真实票据图象，软件中看到的，就是您的打印效果。</li>\n<li>精准。《全真打印软件》的打印精度精确到一厘米的百分之一。</li>\n<li>开放。《全真打印软件》中您可以轻松定制自己的专用票据、单据、合同、表格。</li>\n<li>普适。《全真打印软件》支持针式、激光、喷墨、热敏等主流打印机。</li>\n<li>智能。《全真打印软件》全面支持在线更新。</li>\n</ul>\n<hr>\n<h3 id=\"安全：\"><a href=\"#安全：\" class=\"headerlink\" title=\"安全：\"></a>安全：</h3><ul>\n<li>绿色无插件无广告。</li>\n<li>数据均加密存储。</li>\n</ul>\n<hr>\n<p>当然，以上这些还远远不够。</p>\n<p>它还有一项巨大的优势：</p>\n<h3 id=\"价格：《全真打印软件》，免费的！\"><a href=\"#价格：《全真打印软件》，免费的！\" class=\"headerlink\" title=\"价格：《全真打印软件》，免费的！\"></a>价格：《全真打印软件》，免费的！</h3><p>还等什么，还不下载使用？</p>\n<div id=\"context_center\"><br>        <a href=\"http://oss.myqzz.net/aime/全真打印软件安装.rar\" alt=\"\" title=\"立即下载《全真打印软件》\" id=\"download\" target=\"_blank\" rel=\"noopener\">立即下载</a><br></div>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"jm_xxzp_0_1.jpg\" alt=\"\" title=\"《全真打印软件》主界面\"></p>\n<h2 id=\"《全真打印软件》有哪些真功夫？\"><a href=\"#《全真打印软件》有哪些真功夫？\" class=\"headerlink\" title=\"《全真打印软件》有哪些真功夫？\"></a>《全真打印软件》有哪些真功夫？</h2><h2 id=\"技术优势：\"><a href=\"#技术优势：\" class=\"headerlink\" title=\"技术优势：\"></a>技术优势：</h2><ul>\n<li>专业。支持云存储，数据无忧。（时光机）</li>\n<li>安全。支持手机验证，数据恢复手机验证。</li>\n<li>简单。无需复杂设置，每种票据仅需要打印一次取得偏移即可进行实际打印。</li>\n<li>直观。《全真打印软件》所有操作均基于真实票据图象，软件中看到的，就是您的打印效果。</li>\n<li>精准。《全真打印软件》的打印精度精确到一厘米的百分之一。</li>\n<li>开放。《全真打印软件》中您可以轻松定制自己的专用票据、单据、合同、表格。</li>\n<li>普适。《全真打印软件》支持针式、激光、喷墨、热敏等主流打印机。</li>\n<li>智能。《全真打印软件》全面支持在线更新。</li>\n</ul>\n<hr>\n<h3 id=\"安全：\"><a href=\"#安全：\" class=\"headerlink\" title=\"安全：\"></a>安全：</h3><ul>\n<li>绿色无插件无广告。</li>\n<li>数据均加密存储。</li>\n</ul>\n<hr>\n<p>当然，以上这些还远远不够。</p>\n<p>它还有一项巨大的优势：</p>\n<h3 id=\"价格：《全真打印软件》，免费的！\"><a href=\"#价格：《全真打印软件》，免费的！\" class=\"headerlink\" title=\"价格：《全真打印软件》，免费的！\"></a>价格：《全真打印软件》，免费的！</h3><p>还等什么，还不下载使用？</p>\n<div id=\"context_center\"><br>        <a href=\"http://oss.myqzz.net/aime/全真打印软件安装.rar\" alt=\"\" title=\"立即下载《全真打印软件》\" id=\"download\" target=\"_blank\" rel=\"noopener\">立即下载</a><br></div>\n"},{"title":"Meteor入门","abbrlink":49028,"date":"2016-09-29T08:40:45.000Z","_content":"\n\n\n### 命令行\n\n* 在Mac OS X系统中, 命令行是 Terminal.\n* 在Windows系统中, 命令行的名字是“命令提示符”。（或开始，运行 CMD）\n* 在Linux系统中, 例如ubuntu ，命令行应用也是Terminal。\n\n### 安装\n\nMeteor支持的平台：\n• Mac: OS X 10.7 及以上\n• Windows:\n– Windows 7\n– Windows 8.1\n– Windows Server 2008\n– Windows Server 2012\n• Linux: x86 and x86_64 \n\n在Windows上安装Meteor最简单，直接从官网www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用 Mac OS X 或 Linux ,请将下列命令复制到命令行中，回车运行。\n\n```\n curl https://install.meteor.com/ | sh\n\n```\n\n这行命令会执行以下操作:\n1. 连接到 “install.meteor.com”.\n2. 下载最新版本的 Meteor.\n3. 安装Meteor.\n\n在linux或mac os系统上，如果向您询问密码，请输入并回车，这是校验您是否有安装Meteor到您的计算机上的权限。\n\n### 创建项目\n\n尽管项目各不相同，但我们的Meteor项目通常包含如下内容：\n• HTML 文件, 用以创建页面.\n• CSS 文件, 用以应用样式到页面.\n• JavaScript 文件, 用以定义应用程序逻辑.\n• Folders, 用以组织不同类型文件.\n\n项目可以包含其它类型的文件, 如图片等, 但我们现在尽量保持我们的项目尽可能简单，只包含我们需要的东西。这里我们要创建的项目名为 Leaderboard，在创建项目之前，我们先为我们的Meteor项目创建一个目录。\n\n在命令行中输入：\n\n```\nmkdir Meteor\n\n```\n并回车。\n\n```\ncd Meteor\n\n```\n\n进入新创建的目录。在此目录下创建项目，运行以下命令：\n\n```\nmeteor create leaderboard\n\n```\n\n该命令包含三个部分：\n• meteor 定义这是一个 Meteor 命令.\n• create 表示我们要创建一个 Meteor 项目.\n• leaderboard 是我们要创建的项目的名字.\n\n命令运行完成后，会在当前目录下生成一个 “leaderboard” 目录,默认情况下此目录下会包含以下三个文件：\n\n• leaderboard.html\n• leaderboard.css\n• leaderboard.js\n\n另外它还包含一个名为  .meteor 的隐藏目录，这个我们不要管它，它提供了Meteor的功能支持。\n\n### 运行\n\n要想运行我们刚才建立的应用程序，请在命令行中输入以下命令：\n\n```\ncd leaderboard\n```\n\n然后，输入:\n\n```\nmeteor \n```\n\n输入回车后，命令行中将会显示以下内容:\n\n```\n=> Started proxy.\n=> Started MongoDB.\n=> Started your app.\n=> App running at: http://localhost:4000/\n```\n\n我们新创建的Meteor应用已经成功运行，请打开浏览器，访问地址  http://localhost:4000。\n\n\n至此，我们的第一个Meteor应用已经成功运行。","source":"_posts/Meteor-1.md","raw":"---\ntitle: Meteor入门\ntags: 你的第一个Meteor应用\nabbrlink: 49028\ndate: 2016-09-29 16:40:45\n---\n\n\n\n### 命令行\n\n* 在Mac OS X系统中, 命令行是 Terminal.\n* 在Windows系统中, 命令行的名字是“命令提示符”。（或开始，运行 CMD）\n* 在Linux系统中, 例如ubuntu ，命令行应用也是Terminal。\n\n### 安装\n\nMeteor支持的平台：\n• Mac: OS X 10.7 及以上\n• Windows:\n– Windows 7\n– Windows 8.1\n– Windows Server 2008\n– Windows Server 2012\n• Linux: x86 and x86_64 \n\n在Windows上安装Meteor最简单，直接从官网www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用 Mac OS X 或 Linux ,请将下列命令复制到命令行中，回车运行。\n\n```\n curl https://install.meteor.com/ | sh\n\n```\n\n这行命令会执行以下操作:\n1. 连接到 “install.meteor.com”.\n2. 下载最新版本的 Meteor.\n3. 安装Meteor.\n\n在linux或mac os系统上，如果向您询问密码，请输入并回车，这是校验您是否有安装Meteor到您的计算机上的权限。\n\n### 创建项目\n\n尽管项目各不相同，但我们的Meteor项目通常包含如下内容：\n• HTML 文件, 用以创建页面.\n• CSS 文件, 用以应用样式到页面.\n• JavaScript 文件, 用以定义应用程序逻辑.\n• Folders, 用以组织不同类型文件.\n\n项目可以包含其它类型的文件, 如图片等, 但我们现在尽量保持我们的项目尽可能简单，只包含我们需要的东西。这里我们要创建的项目名为 Leaderboard，在创建项目之前，我们先为我们的Meteor项目创建一个目录。\n\n在命令行中输入：\n\n```\nmkdir Meteor\n\n```\n并回车。\n\n```\ncd Meteor\n\n```\n\n进入新创建的目录。在此目录下创建项目，运行以下命令：\n\n```\nmeteor create leaderboard\n\n```\n\n该命令包含三个部分：\n• meteor 定义这是一个 Meteor 命令.\n• create 表示我们要创建一个 Meteor 项目.\n• leaderboard 是我们要创建的项目的名字.\n\n命令运行完成后，会在当前目录下生成一个 “leaderboard” 目录,默认情况下此目录下会包含以下三个文件：\n\n• leaderboard.html\n• leaderboard.css\n• leaderboard.js\n\n另外它还包含一个名为  .meteor 的隐藏目录，这个我们不要管它，它提供了Meteor的功能支持。\n\n### 运行\n\n要想运行我们刚才建立的应用程序，请在命令行中输入以下命令：\n\n```\ncd leaderboard\n```\n\n然后，输入:\n\n```\nmeteor \n```\n\n输入回车后，命令行中将会显示以下内容:\n\n```\n=> Started proxy.\n=> Started MongoDB.\n=> Started your app.\n=> App running at: http://localhost:4000/\n```\n\n我们新创建的Meteor应用已经成功运行，请打开浏览器，访问地址  http://localhost:4000。\n\n\n至此，我们的第一个Meteor应用已经成功运行。","slug":"Meteor-1","published":1,"updated":"2019-02-12T03:17:45.016Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u3r0004acelh1hdxrp9","content":"<h3 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h3><ul>\n<li>在Mac OS X系统中, 命令行是 Terminal.</li>\n<li>在Windows系统中, 命令行的名字是“命令提示符”。（或开始，运行 CMD）</li>\n<li>在Linux系统中, 例如ubuntu ，命令行应用也是Terminal。</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>Meteor支持的平台：<br>• Mac: OS X 10.7 及以上<br>• Windows:<br>– Windows 7<br>– Windows 8.1<br>– Windows Server 2008<br>– Windows Server 2012<br>• Linux: x86 and x86_64 </p>\n<p>在Windows上安装Meteor最简单，直接从官网<a href=\"http://www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用\" target=\"_blank\" rel=\"noopener\">www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用</a> Mac OS X 或 Linux ,请将下列命令复制到命令行中，回车运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://install.meteor.com/ | sh</span><br></pre></td></tr></table></figure>\n<p>这行命令会执行以下操作:</p>\n<ol>\n<li>连接到 “install.meteor.com”.</li>\n<li>下载最新版本的 Meteor.</li>\n<li>安装Meteor.</li>\n</ol>\n<p>在linux或mac os系统上，如果向您询问密码，请输入并回车，这是校验您是否有安装Meteor到您的计算机上的权限。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>尽管项目各不相同，但我们的Meteor项目通常包含如下内容：<br>• HTML 文件, 用以创建页面.<br>• CSS 文件, 用以应用样式到页面.<br>• JavaScript 文件, 用以定义应用程序逻辑.<br>• Folders, 用以组织不同类型文件.</p>\n<p>项目可以包含其它类型的文件, 如图片等, 但我们现在尽量保持我们的项目尽可能简单，只包含我们需要的东西。这里我们要创建的项目名为 Leaderboard，在创建项目之前，我们先为我们的Meteor项目创建一个目录。</p>\n<p>在命令行中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir Meteor</span><br></pre></td></tr></table></figure>\n<p>并回车。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd Meteor</span><br></pre></td></tr></table></figure>\n<p>进入新创建的目录。在此目录下创建项目，运行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meteor create leaderboard</span><br></pre></td></tr></table></figure>\n<p>该命令包含三个部分：<br>• meteor 定义这是一个 Meteor 命令.<br>• create 表示我们要创建一个 Meteor 项目.<br>• leaderboard 是我们要创建的项目的名字.</p>\n<p>命令运行完成后，会在当前目录下生成一个 “leaderboard” 目录,默认情况下此目录下会包含以下三个文件：</p>\n<p>• leaderboard.html<br>• leaderboard.css<br>• leaderboard.js</p>\n<p>另外它还包含一个名为  .meteor 的隐藏目录，这个我们不要管它，它提供了Meteor的功能支持。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>要想运行我们刚才建立的应用程序，请在命令行中输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd leaderboard</span><br></pre></td></tr></table></figure>\n<p>然后，输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meteor</span><br></pre></td></tr></table></figure>\n<p>输入回车后，命令行中将会显示以下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; Started proxy.</span><br><span class=\"line\">=&gt; Started MongoDB.</span><br><span class=\"line\">=&gt; Started your app.</span><br><span class=\"line\">=&gt; App running at: http://localhost:4000/</span><br></pre></td></tr></table></figure>\n<p>我们新创建的Meteor应用已经成功运行，请打开浏览器，访问地址  <a href=\"http://localhost:4000。\" target=\"_blank\" rel=\"noopener\">http://localhost:4000。</a></p>\n<p>至此，我们的第一个Meteor应用已经成功运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"命令行\"><a href=\"#命令行\" class=\"headerlink\" title=\"命令行\"></a>命令行</h3><ul>\n<li>在Mac OS X系统中, 命令行是 Terminal.</li>\n<li>在Windows系统中, 命令行的名字是“命令提示符”。（或开始，运行 CMD）</li>\n<li>在Linux系统中, 例如ubuntu ，命令行应用也是Terminal。</li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>Meteor支持的平台：<br>• Mac: OS X 10.7 及以上<br>• Windows:<br>– Windows 7<br>– Windows 8.1<br>– Windows Server 2008<br>– Windows Server 2012<br>• Linux: x86 and x86_64 </p>\n<p>在Windows上安装Meteor最简单，直接从官网<a href=\"http://www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用\" target=\"_blank\" rel=\"noopener\">www.meteor.com下载安装文件并运行就可以了。（不过由于网站在国外，所以，您需要点面耐心。）如果您使用</a> Mac OS X 或 Linux ,请将下列命令复制到命令行中，回车运行。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl https://install.meteor.com/ | sh</span><br></pre></td></tr></table></figure>\n<p>这行命令会执行以下操作:</p>\n<ol>\n<li>连接到 “install.meteor.com”.</li>\n<li>下载最新版本的 Meteor.</li>\n<li>安装Meteor.</li>\n</ol>\n<p>在linux或mac os系统上，如果向您询问密码，请输入并回车，这是校验您是否有安装Meteor到您的计算机上的权限。</p>\n<h3 id=\"创建项目\"><a href=\"#创建项目\" class=\"headerlink\" title=\"创建项目\"></a>创建项目</h3><p>尽管项目各不相同，但我们的Meteor项目通常包含如下内容：<br>• HTML 文件, 用以创建页面.<br>• CSS 文件, 用以应用样式到页面.<br>• JavaScript 文件, 用以定义应用程序逻辑.<br>• Folders, 用以组织不同类型文件.</p>\n<p>项目可以包含其它类型的文件, 如图片等, 但我们现在尽量保持我们的项目尽可能简单，只包含我们需要的东西。这里我们要创建的项目名为 Leaderboard，在创建项目之前，我们先为我们的Meteor项目创建一个目录。</p>\n<p>在命令行中输入：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir Meteor</span><br></pre></td></tr></table></figure>\n<p>并回车。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd Meteor</span><br></pre></td></tr></table></figure>\n<p>进入新创建的目录。在此目录下创建项目，运行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meteor create leaderboard</span><br></pre></td></tr></table></figure>\n<p>该命令包含三个部分：<br>• meteor 定义这是一个 Meteor 命令.<br>• create 表示我们要创建一个 Meteor 项目.<br>• leaderboard 是我们要创建的项目的名字.</p>\n<p>命令运行完成后，会在当前目录下生成一个 “leaderboard” 目录,默认情况下此目录下会包含以下三个文件：</p>\n<p>• leaderboard.html<br>• leaderboard.css<br>• leaderboard.js</p>\n<p>另外它还包含一个名为  .meteor 的隐藏目录，这个我们不要管它，它提供了Meteor的功能支持。</p>\n<h3 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h3><p>要想运行我们刚才建立的应用程序，请在命令行中输入以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd leaderboard</span><br></pre></td></tr></table></figure>\n<p>然后，输入:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">meteor</span><br></pre></td></tr></table></figure>\n<p>输入回车后，命令行中将会显示以下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=&gt; Started proxy.</span><br><span class=\"line\">=&gt; Started MongoDB.</span><br><span class=\"line\">=&gt; Started your app.</span><br><span class=\"line\">=&gt; App running at: http://localhost:4000/</span><br></pre></td></tr></table></figure>\n<p>我们新创建的Meteor应用已经成功运行，请打开浏览器，访问地址  <a href=\"http://localhost:4000。\" target=\"_blank\" rel=\"noopener\">http://localhost:4000。</a></p>\n<p>至此，我们的第一个Meteor应用已经成功运行。</p>\n"},{"title":"如何同步Hexo网站到github","abbrlink":54923,"date":"2018-03-17T10:54:59.000Z","_content":"\n\n## 进入hexo项目目录\n\n\n在windows命令行（或类liunx系统的终端）中运行以下命令：\n\n\n* 生成网站内容\n```\nhexo g  （hexo generate的简写）\n\n```\n\n* 发布到网站\n```\nhexo d   （hexo deploy的简写）\n\n```\n* 特别说明\n如果在windows命令行运行中出现错误，则请运行windows上的git bash命令行，切换到hexo项目目录。有一点特别说明的，在git bash命令行中，改变当前硬盘时，也要用cd命令:\n```\ncd d:\n\n```\n\n\n## 欣赏自己的成果吧。\n\n","source":"_posts/hello-world.md","raw":"---\ntitle: 如何同步Hexo网站到github\nabbrlink: 54923\ndate: 2018-03-17 18:54:59\n---\n\n\n## 进入hexo项目目录\n\n\n在windows命令行（或类liunx系统的终端）中运行以下命令：\n\n\n* 生成网站内容\n```\nhexo g  （hexo generate的简写）\n\n```\n\n* 发布到网站\n```\nhexo d   （hexo deploy的简写）\n\n```\n* 特别说明\n如果在windows命令行运行中出现错误，则请运行windows上的git bash命令行，切换到hexo项目目录。有一点特别说明的，在git bash命令行中，改变当前硬盘时，也要用cd命令:\n```\ncd d:\n\n```\n\n\n## 欣赏自己的成果吧。\n\n","slug":"hello-world","published":1,"updated":"2019-02-12T03:17:45.010Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u4n000dacelej99om0s","content":"<h2 id=\"进入hexo项目目录\"><a href=\"#进入hexo项目目录\" class=\"headerlink\" title=\"进入hexo项目目录\"></a>进入hexo项目目录</h2><p>在windows命令行（或类liunx系统的终端）中运行以下命令：</p>\n<ul>\n<li><p>生成网站内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g  （hexo generate的简写）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布到网站</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d   （hexo deploy的简写）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特别说明<br>如果在windows命令行运行中出现错误，则请运行windows上的git bash命令行，切换到hexo项目目录。有一点特别说明的，在git bash命令行中，改变当前硬盘时，也要用cd命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd d:</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"欣赏自己的成果吧。\"><a href=\"#欣赏自己的成果吧。\" class=\"headerlink\" title=\"欣赏自己的成果吧。\"></a>欣赏自己的成果吧。</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"进入hexo项目目录\"><a href=\"#进入hexo项目目录\" class=\"headerlink\" title=\"进入hexo项目目录\"></a>进入hexo项目目录</h2><p>在windows命令行（或类liunx系统的终端）中运行以下命令：</p>\n<ul>\n<li><p>生成网站内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g  （hexo generate的简写）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>发布到网站</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d   （hexo deploy的简写）</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>特别说明<br>如果在windows命令行运行中出现错误，则请运行windows上的git bash命令行，切换到hexo项目目录。有一点特别说明的，在git bash命令行中，改变当前硬盘时，也要用cd命令:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd d:</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"欣赏自己的成果吧。\"><a href=\"#欣赏自己的成果吧。\" class=\"headerlink\" title=\"欣赏自己的成果吧。\"></a>欣赏自己的成果吧。</h2>"},{"title":"install_hexo","abbrlink":33643,"date":"2016-08-26T10:03:01.000Z","_content":"\n\n## 如何安装hexo","source":"_posts/install-hexo.md","raw":"---\ntitle: install_hexo\nabbrlink: 33643\ndate: 2016-08-26 18:03:01\ntags:\n---\n\n\n## 如何安装hexo","slug":"install-hexo","published":1,"updated":"2019-02-12T03:17:45.014Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u4n000eacelnetlnbgo","content":"<h2 id=\"如何安装hexo\"><a href=\"#如何安装hexo\" class=\"headerlink\" title=\"如何安装hexo\"></a>如何安装hexo</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"如何安装hexo\"><a href=\"#如何安装hexo\" class=\"headerlink\" title=\"如何安装hexo\"></a>如何安装hexo</h2>"},{"title":"金箍棒之殇","abbrlink":15069,"date":"2018-05-07T09:27:06.000Z","_content":"\n\n话说悟空取经九千多年之后，天庭又经变乱。\n\n镇元大仙急寻悟空而不得，欲返身时突然发觉走廊尽头的一根柱子似有异常，走近一看，锈迹斑斑的柱子上依稀可辩的显着几个字——“如意金箍棒”！\n\n镇元诧异：\n\n“金箍棒，怎会这样？”\n\n一边说一边轻轻拂掉了字迹上的灰尘。\n\n大仙容禀:其实我本是菩提祖师送给悟空的法器，后来一次牛魔王私下用我出去打死了一个妖怪，谁知竟是悟空的义父——当初花果山上尽心辅佐悟空当猴王的老猴子。\n\n悟空大怒，将我封印于东海。\n\n后来，悟空回了花果山，意图大闹天宫，一直找不到趁手的兵器，就到海底来解除了我的封印。但此后，悟空再也没把我扛到肩上了。\n\n最近天庭变乱，悟空唤我出来一舞，铁锈漫天，大为诧异：\n\n“金箍棒，怎会这样？”\n\n“大圣容禀，小的作为低等法器，原只有一万年的寿命，如今已命不久矣，早没了当年的神勇，望大圣见谅！”\n\n“你我同在佛祖面前加授金光，当同享永生，何来只有万年寿命？”\n\n“能听到大圣您这样说，也不枉我跟大圣一场，小生已死而无憾了。大圣可记得，佛祖面前加授金光，您可有将我从耳朵里取出？\n\n大圣一愣，缓缓地低声问道：\n\n“那现在该当如何？”\n\n这时，一阵风紧，院子走廊尽头的一根柱子经年日久，吱呀一声，裂将开来。我看了看，说道：\n\n“可否让我在走廊尽头安安静静地做根柱子？”\n\n......\n\n镇元大仙听后，思绪良久，想及当今天庭变乱，或可一用，说到：\n\n“要不，跟我一起，再立新功如何？”\n\n在灵台山;\n\n在东海底;\n\n没想到，在今天，他竟又听到了这句话：\n\n“要不，跟我一起，再立新功如何？”\n\n一行热泪顺着“如意金箍棒”的刻痕蜿蜒而下......\n\n“大仙这样抬举，小生感恩不尽。只是现在小生已是一行将就木的法器，早已没有了往日的神勇，如今做根廊柱，已是物尽其用了。”\n\n......\n\n一阵冷风，金箍棒一激灵，打了个寒颤，目光渐渐暗淡，消失，那道泪水渐渐凝固，成了一道曲折的锈痕，宛如身体上暴露出的一条长长的青筋，无力地垂向地面......","source":"_posts/wukong-story.md","raw":"---\ntitle: 金箍棒之殇\ntags: 西游记外传之金箍棒之殇\nabbrlink: 15069\ndate: 2018-05-07 17:27:06\n---\n\n\n话说悟空取经九千多年之后，天庭又经变乱。\n\n镇元大仙急寻悟空而不得，欲返身时突然发觉走廊尽头的一根柱子似有异常，走近一看，锈迹斑斑的柱子上依稀可辩的显着几个字——“如意金箍棒”！\n\n镇元诧异：\n\n“金箍棒，怎会这样？”\n\n一边说一边轻轻拂掉了字迹上的灰尘。\n\n大仙容禀:其实我本是菩提祖师送给悟空的法器，后来一次牛魔王私下用我出去打死了一个妖怪，谁知竟是悟空的义父——当初花果山上尽心辅佐悟空当猴王的老猴子。\n\n悟空大怒，将我封印于东海。\n\n后来，悟空回了花果山，意图大闹天宫，一直找不到趁手的兵器，就到海底来解除了我的封印。但此后，悟空再也没把我扛到肩上了。\n\n最近天庭变乱，悟空唤我出来一舞，铁锈漫天，大为诧异：\n\n“金箍棒，怎会这样？”\n\n“大圣容禀，小的作为低等法器，原只有一万年的寿命，如今已命不久矣，早没了当年的神勇，望大圣见谅！”\n\n“你我同在佛祖面前加授金光，当同享永生，何来只有万年寿命？”\n\n“能听到大圣您这样说，也不枉我跟大圣一场，小生已死而无憾了。大圣可记得，佛祖面前加授金光，您可有将我从耳朵里取出？\n\n大圣一愣，缓缓地低声问道：\n\n“那现在该当如何？”\n\n这时，一阵风紧，院子走廊尽头的一根柱子经年日久，吱呀一声，裂将开来。我看了看，说道：\n\n“可否让我在走廊尽头安安静静地做根柱子？”\n\n......\n\n镇元大仙听后，思绪良久，想及当今天庭变乱，或可一用，说到：\n\n“要不，跟我一起，再立新功如何？”\n\n在灵台山;\n\n在东海底;\n\n没想到，在今天，他竟又听到了这句话：\n\n“要不，跟我一起，再立新功如何？”\n\n一行热泪顺着“如意金箍棒”的刻痕蜿蜒而下......\n\n“大仙这样抬举，小生感恩不尽。只是现在小生已是一行将就木的法器，早已没有了往日的神勇，如今做根廊柱，已是物尽其用了。”\n\n......\n\n一阵冷风，金箍棒一激灵，打了个寒颤，目光渐渐暗淡，消失，那道泪水渐渐凝固，成了一道曲折的锈痕，宛如身体上暴露出的一条长长的青筋，无力地垂向地面......","slug":"wukong-story","published":1,"updated":"2019-02-12T03:17:45.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u4n000facel0isrqacv","content":"<p>话说悟空取经九千多年之后，天庭又经变乱。</p>\n<p>镇元大仙急寻悟空而不得，欲返身时突然发觉走廊尽头的一根柱子似有异常，走近一看，锈迹斑斑的柱子上依稀可辩的显着几个字——“如意金箍棒”！</p>\n<p>镇元诧异：</p>\n<p>“金箍棒，怎会这样？”</p>\n<p>一边说一边轻轻拂掉了字迹上的灰尘。</p>\n<p>大仙容禀:其实我本是菩提祖师送给悟空的法器，后来一次牛魔王私下用我出去打死了一个妖怪，谁知竟是悟空的义父——当初花果山上尽心辅佐悟空当猴王的老猴子。</p>\n<p>悟空大怒，将我封印于东海。</p>\n<p>后来，悟空回了花果山，意图大闹天宫，一直找不到趁手的兵器，就到海底来解除了我的封印。但此后，悟空再也没把我扛到肩上了。</p>\n<p>最近天庭变乱，悟空唤我出来一舞，铁锈漫天，大为诧异：</p>\n<p>“金箍棒，怎会这样？”</p>\n<p>“大圣容禀，小的作为低等法器，原只有一万年的寿命，如今已命不久矣，早没了当年的神勇，望大圣见谅！”</p>\n<p>“你我同在佛祖面前加授金光，当同享永生，何来只有万年寿命？”</p>\n<p>“能听到大圣您这样说，也不枉我跟大圣一场，小生已死而无憾了。大圣可记得，佛祖面前加授金光，您可有将我从耳朵里取出？</p>\n<p>大圣一愣，缓缓地低声问道：</p>\n<p>“那现在该当如何？”</p>\n<p>这时，一阵风紧，院子走廊尽头的一根柱子经年日久，吱呀一声，裂将开来。我看了看，说道：</p>\n<p>“可否让我在走廊尽头安安静静地做根柱子？”</p>\n<p>……</p>\n<p>镇元大仙听后，思绪良久，想及当今天庭变乱，或可一用，说到：</p>\n<p>“要不，跟我一起，再立新功如何？”</p>\n<p>在灵台山;</p>\n<p>在东海底;</p>\n<p>没想到，在今天，他竟又听到了这句话：</p>\n<p>“要不，跟我一起，再立新功如何？”</p>\n<p>一行热泪顺着“如意金箍棒”的刻痕蜿蜒而下……</p>\n<p>“大仙这样抬举，小生感恩不尽。只是现在小生已是一行将就木的法器，早已没有了往日的神勇，如今做根廊柱，已是物尽其用了。”</p>\n<p>……</p>\n<p>一阵冷风，金箍棒一激灵，打了个寒颤，目光渐渐暗淡，消失，那道泪水渐渐凝固，成了一道曲折的锈痕，宛如身体上暴露出的一条长长的青筋，无力地垂向地面……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>话说悟空取经九千多年之后，天庭又经变乱。</p>\n<p>镇元大仙急寻悟空而不得，欲返身时突然发觉走廊尽头的一根柱子似有异常，走近一看，锈迹斑斑的柱子上依稀可辩的显着几个字——“如意金箍棒”！</p>\n<p>镇元诧异：</p>\n<p>“金箍棒，怎会这样？”</p>\n<p>一边说一边轻轻拂掉了字迹上的灰尘。</p>\n<p>大仙容禀:其实我本是菩提祖师送给悟空的法器，后来一次牛魔王私下用我出去打死了一个妖怪，谁知竟是悟空的义父——当初花果山上尽心辅佐悟空当猴王的老猴子。</p>\n<p>悟空大怒，将我封印于东海。</p>\n<p>后来，悟空回了花果山，意图大闹天宫，一直找不到趁手的兵器，就到海底来解除了我的封印。但此后，悟空再也没把我扛到肩上了。</p>\n<p>最近天庭变乱，悟空唤我出来一舞，铁锈漫天，大为诧异：</p>\n<p>“金箍棒，怎会这样？”</p>\n<p>“大圣容禀，小的作为低等法器，原只有一万年的寿命，如今已命不久矣，早没了当年的神勇，望大圣见谅！”</p>\n<p>“你我同在佛祖面前加授金光，当同享永生，何来只有万年寿命？”</p>\n<p>“能听到大圣您这样说，也不枉我跟大圣一场，小生已死而无憾了。大圣可记得，佛祖面前加授金光，您可有将我从耳朵里取出？</p>\n<p>大圣一愣，缓缓地低声问道：</p>\n<p>“那现在该当如何？”</p>\n<p>这时，一阵风紧，院子走廊尽头的一根柱子经年日久，吱呀一声，裂将开来。我看了看，说道：</p>\n<p>“可否让我在走廊尽头安安静静地做根柱子？”</p>\n<p>……</p>\n<p>镇元大仙听后，思绪良久，想及当今天庭变乱，或可一用，说到：</p>\n<p>“要不，跟我一起，再立新功如何？”</p>\n<p>在灵台山;</p>\n<p>在东海底;</p>\n<p>没想到，在今天，他竟又听到了这句话：</p>\n<p>“要不，跟我一起，再立新功如何？”</p>\n<p>一行热泪顺着“如意金箍棒”的刻痕蜿蜒而下……</p>\n<p>“大仙这样抬举，小生感恩不尽。只是现在小生已是一行将就木的法器，早已没有了往日的神勇，如今做根廊柱，已是物尽其用了。”</p>\n<p>……</p>\n<p>一阵冷风，金箍棒一激灵，打了个寒颤，目光渐渐暗淡，消失，那道泪水渐渐凝固，成了一道曲折的锈痕，宛如身体上暴露出的一条长长的青筋，无力地垂向地面……</p>\n"},{"title":"thrift编译设置","abbrlink":31784,"date":"2018-03-18T10:54:59.000Z","_content":"\n\n## thrift编译设置\n\n***\n\n* 附加包含目录\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src;\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows;\n\t\tZ:\\libraries\\boost\\boost_1_66_0;\n\n\n* 预处理器定义\n    \tHAVE_CONFIG_H=1\n\t\tWIN32\n\t\t_DEBUG\n\t\t_CONSOLE\n\n* 代码生成：\n\t\tDEBUG  运行库 MTD\n\t\tRELEASE 运行库 MT\n\n\n* 预编译头\n\t\t不使用预编译头\n\n\n\n* 附加依赖项\n\t\tlibssl.lib\n\t\tlibthrift.lib\n\t\tlibcrypto.lib\n\n* 附加库目录\n\t\tZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib;\n\t\tz:\\libraries\\openssl\\OpenSSL-Win32\\lib;\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\Debug-mt;\n\n\n\n## 错误处理\n\n使用vs2017编译thrift项目时出现以下错误：objbase.h(230): error C2760错误的解决的解决办法：\n~~~cpp\n#在stdafx.h中添加\n#define WIN32_LEAN_AND_MEAN\n~~~\n\n\n\n## openssl 编译设置\n\n* 动态编译\n\t\tWIN64\n\t\tperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64\n\t\tnmake clean\n\t\tnmake\n\t\tnmake test\n\t\tnmake install\n\n\n* 静态编译\n\t\tmakefile and configdata 两个文件中的/MD改为/MT\n\t\tperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64_static\n\t\tnmake clean\n\t\tnmake\n\t\tnmake test\n\t\tnmake install\n\n\n\n## thrift 0.11.0编译问题及解决：\n\n* 一、包含目录要加上openssl的目录引用\n* 二、THttpserver.cpp与THttpclient.cpp中的\n~~~cpp\n//#include <thrift/config.h>此行改为\n#include <thrift/thrift.h>\n~~~\n\n* 三、添加以下宏定义\n~~~cpp\n//在<thrift/thrift-config.h>中\n#define PACKAGE_VERSION  \"${PACKAGE_VERSION}\"\n~~~\n\n\n\n\n## thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）\n\n* c++常规--附加包含目录：\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows\n\t\tZ:\\libraries\\boost\\boost_1_66_0\n* 链接器--常规--附加库目录\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\release-mt\n\t\tZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib141\n\t\tZ:\\libraries\\openssl\\OpenSSL-Win32\\lib\n* 链接器--输入--附加依赖项\n\t\tlibthrift.lib\n\t\tlibssl.lib\n\t\tlibcrypto.lib\n\n\n\n\n\n## 使用odb时自定义生成：\n\n* 在项目中选中类文件如：employee.hxx  右键--属性--配置属性--常规--项类型 设置成：自定义生成工具\n\n* 然后选中：自定义生成工具并设置如下：\n\n\t* 命令行：\n\t\t\todb.exe --std c++11 --database sqlite --generate-query --generate-schema --table-prefix boost_ employee.hxx\n    * 说明：\n\t\t\todb employee.hxx\n    * 输出：\n\t\t\temployee-odb.hxx\n\t\t\temployee-odb.ixx\n\t\t\temployee-odb.cxx\n\n\n\n\n## docker使用hexo\n\n* 1.安装Hexo\n\t\tdocker run --name hexo -it -p 8083:80 -v `pwd`: /usr/share/nginx/html/source simplyintricate/hexo\n* 2.发布一篇blog\n\t\tdocker exec -it hexo hexo new \"This is one post\"\n\n\n\n## ODB项目设置：\n\n* 输入\n\t\tdb-sqlite.lib;odb.lib\n* 包含目录\n\t\tz:\\libraries\\orm\\sqlite3\\sqlite-amalgamation-3220000;\n        z:\\libraries\\orm\\odb2.4\\libodb-2.4.0;\n        z:\\libraries\\orm\\odb2.4\\libodb-sqlite-2.4.0;\n* 库目录\n    \tz:\\libraries\\orm\\sqlite3\\;\n\n\n## odb备注\n\t使用编译指令#pragma db transient 把字段声明为临时的，也就是该字段不保存与数据库中。\n\n\n## Error: ENOSPC: no space left on device\n\n查看存储空间\n\n\t$df -h\n\n查看i节点\n\n\t$df -i\n\n看是那种情况。\n\n不幸的是我哪种都不是，后来在stackflow找到了答案。\n\n问题原因:You may have reached your quota of watches.\n\n解决办法\n\n查看目前的最大值\n\nTo find your current limit, type this in your terminal:\n\n\t$cat /proc/sys/fs/inotify/max_user_watches\n\n\n增加最大值\n\nWhich is typically 8192 by default.\n\nTo increase your limit, type this:\n\n\t$sudo sysctl fs.inotify.max_user_watches=16384\n\n永久设置最大值\n\nThen restart django.\n\nTo permanently set this limit, type this:\n\n\t$echo 16384 | sudo tee -a /proc/sys/fs/inotify/max_user_watches","source":"_posts/thrift.md","raw":"---\ntitle: thrift编译设置\ntags: 编译thrift0.11\nabbrlink: 31784\ndate: 2018-03-18 18:54:59\n---\n\n\n## thrift编译设置\n\n***\n\n* 附加包含目录\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src;\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows;\n\t\tZ:\\libraries\\boost\\boost_1_66_0;\n\n\n* 预处理器定义\n    \tHAVE_CONFIG_H=1\n\t\tWIN32\n\t\t_DEBUG\n\t\t_CONSOLE\n\n* 代码生成：\n\t\tDEBUG  运行库 MTD\n\t\tRELEASE 运行库 MT\n\n\n* 预编译头\n\t\t不使用预编译头\n\n\n\n* 附加依赖项\n\t\tlibssl.lib\n\t\tlibthrift.lib\n\t\tlibcrypto.lib\n\n* 附加库目录\n\t\tZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib;\n\t\tz:\\libraries\\openssl\\OpenSSL-Win32\\lib;\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\Debug-mt;\n\n\n\n## 错误处理\n\n使用vs2017编译thrift项目时出现以下错误：objbase.h(230): error C2760错误的解决的解决办法：\n~~~cpp\n#在stdafx.h中添加\n#define WIN32_LEAN_AND_MEAN\n~~~\n\n\n\n## openssl 编译设置\n\n* 动态编译\n\t\tWIN64\n\t\tperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64\n\t\tnmake clean\n\t\tnmake\n\t\tnmake test\n\t\tnmake install\n\n\n* 静态编译\n\t\tmakefile and configdata 两个文件中的/MD改为/MT\n\t\tperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64_static\n\t\tnmake clean\n\t\tnmake\n\t\tnmake test\n\t\tnmake install\n\n\n\n## thrift 0.11.0编译问题及解决：\n\n* 一、包含目录要加上openssl的目录引用\n* 二、THttpserver.cpp与THttpclient.cpp中的\n~~~cpp\n//#include <thrift/config.h>此行改为\n#include <thrift/thrift.h>\n~~~\n\n* 三、添加以下宏定义\n~~~cpp\n//在<thrift/thrift-config.h>中\n#define PACKAGE_VERSION  \"${PACKAGE_VERSION}\"\n~~~\n\n\n\n\n## thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）\n\n* c++常规--附加包含目录：\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows\n\t\tZ:\\libraries\\boost\\boost_1_66_0\n* 链接器--常规--附加库目录\n\t\tZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\release-mt\n\t\tZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib141\n\t\tZ:\\libraries\\openssl\\OpenSSL-Win32\\lib\n* 链接器--输入--附加依赖项\n\t\tlibthrift.lib\n\t\tlibssl.lib\n\t\tlibcrypto.lib\n\n\n\n\n\n## 使用odb时自定义生成：\n\n* 在项目中选中类文件如：employee.hxx  右键--属性--配置属性--常规--项类型 设置成：自定义生成工具\n\n* 然后选中：自定义生成工具并设置如下：\n\n\t* 命令行：\n\t\t\todb.exe --std c++11 --database sqlite --generate-query --generate-schema --table-prefix boost_ employee.hxx\n    * 说明：\n\t\t\todb employee.hxx\n    * 输出：\n\t\t\temployee-odb.hxx\n\t\t\temployee-odb.ixx\n\t\t\temployee-odb.cxx\n\n\n\n\n## docker使用hexo\n\n* 1.安装Hexo\n\t\tdocker run --name hexo -it -p 8083:80 -v `pwd`: /usr/share/nginx/html/source simplyintricate/hexo\n* 2.发布一篇blog\n\t\tdocker exec -it hexo hexo new \"This is one post\"\n\n\n\n## ODB项目设置：\n\n* 输入\n\t\tdb-sqlite.lib;odb.lib\n* 包含目录\n\t\tz:\\libraries\\orm\\sqlite3\\sqlite-amalgamation-3220000;\n        z:\\libraries\\orm\\odb2.4\\libodb-2.4.0;\n        z:\\libraries\\orm\\odb2.4\\libodb-sqlite-2.4.0;\n* 库目录\n    \tz:\\libraries\\orm\\sqlite3\\;\n\n\n## odb备注\n\t使用编译指令#pragma db transient 把字段声明为临时的，也就是该字段不保存与数据库中。\n\n\n## Error: ENOSPC: no space left on device\n\n查看存储空间\n\n\t$df -h\n\n查看i节点\n\n\t$df -i\n\n看是那种情况。\n\n不幸的是我哪种都不是，后来在stackflow找到了答案。\n\n问题原因:You may have reached your quota of watches.\n\n解决办法\n\n查看目前的最大值\n\nTo find your current limit, type this in your terminal:\n\n\t$cat /proc/sys/fs/inotify/max_user_watches\n\n\n增加最大值\n\nWhich is typically 8192 by default.\n\nTo increase your limit, type this:\n\n\t$sudo sysctl fs.inotify.max_user_watches=16384\n\n永久设置最大值\n\nThen restart django.\n\nTo permanently set this limit, type this:\n\n\t$echo 16384 | sudo tee -a /proc/sys/fs/inotify/max_user_watches","slug":"thrift","published":1,"updated":"2019-02-12T03:17:45.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u4n000gacelx1idnio6","content":"<h2 id=\"thrift编译设置\"><a href=\"#thrift编译设置\" class=\"headerlink\" title=\"thrift编译设置\"></a>thrift编译设置</h2><hr>\n<ul>\n<li>附加包含目录<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src;\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows;\nZ:\\libraries\\boost\\boost_1_66_0;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>预处理器定义</p>\n<pre><code>HAVE_CONFIG_H=1\nWIN32\n_DEBUG\n_CONSOLE\n</code></pre></li>\n<li><p>代码生成：</p>\n<pre><code>DEBUG  运行库 MTD\nRELEASE 运行库 MT\n</code></pre></li>\n</ul>\n<ul>\n<li>预编译头<pre><code>不使用预编译头\n</code></pre></li>\n</ul>\n<ul>\n<li><p>附加依赖项</p>\n<pre><code>libssl.lib\nlibthrift.lib\nlibcrypto.lib\n</code></pre></li>\n<li><p>附加库目录</p>\n<pre><code>Z:\\libraries\\boost\\boost_1_66_0\\stage\\lib;\nz:\\libraries\\openssl\\OpenSSL-Win32\\lib;\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\Debug-mt;\n</code></pre></li>\n</ul>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>使用vs2017编译thrift项目时出现以下错误：objbase.h(230): error C2760错误的解决的解决办法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在stdafx.h中添加</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WIN32_LEAN_AND_MEAN</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"openssl-编译设置\"><a href=\"#openssl-编译设置\" class=\"headerlink\" title=\"openssl 编译设置\"></a>openssl 编译设置</h2><ul>\n<li>动态编译<pre><code>WIN64\nperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64\nnmake clean\nnmake\nnmake test\nnmake install\n</code></pre></li>\n</ul>\n<ul>\n<li>静态编译<pre><code>makefile and configdata 两个文件中的/MD改为/MT\nperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64_static\nnmake clean\nnmake\nnmake test\nnmake install\n</code></pre></li>\n</ul>\n<h2 id=\"thrift-0-11-0编译问题及解决：\"><a href=\"#thrift-0-11-0编译问题及解决：\" class=\"headerlink\" title=\"thrift 0.11.0编译问题及解决：\"></a>thrift 0.11.0编译问题及解决：</h2><ul>\n<li>一、包含目录要加上openssl的目录引用</li>\n<li><p>二、THttpserver.cpp与THttpclient.cpp中的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;thrift/config.h&gt;此行改为</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thrift/thrift.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>三、添加以下宏定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在&lt;thrift/thrift-config.h&gt;中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PACKAGE_VERSION  <span class=\"meta-string\">\"$&#123;PACKAGE_VERSION&#125;\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"thrift客户端与服务器编译设置：（release编译设置静态编译WITH-VS2017）\"><a href=\"#thrift客户端与服务器编译设置：（release编译设置静态编译WITH-VS2017）\" class=\"headerlink\" title=\"thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）\"></a>thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）</h2><ul>\n<li>c++常规–附加包含目录：<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows\nZ:\\libraries\\boost\\boost_1_66_0\n</code></pre></li>\n<li>链接器–常规–附加库目录<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\release-mt\nZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib141\nZ:\\libraries\\openssl\\OpenSSL-Win32\\lib\n</code></pre></li>\n<li>链接器–输入–附加依赖项<pre><code>libthrift.lib\nlibssl.lib\nlibcrypto.lib\n</code></pre></li>\n</ul>\n<h2 id=\"使用odb时自定义生成：\"><a href=\"#使用odb时自定义生成：\" class=\"headerlink\" title=\"使用odb时自定义生成：\"></a>使用odb时自定义生成：</h2><ul>\n<li><p>在项目中选中类文件如：employee.hxx  右键–属性–配置属性–常规–项类型 设置成：自定义生成工具</p>\n</li>\n<li><p>然后选中：自定义生成工具并设置如下：</p>\n<ul>\n<li>命令行：<pre><code>odb.exe --std c++11 --database sqlite --generate-query --generate-schema --table-prefix boost_ employee.hxx\n</code></pre></li>\n<li>说明：<pre><code>odb employee.hxx\n</code></pre></li>\n<li>输出：<pre><code>employee-odb.hxx\nemployee-odb.ixx\nemployee-odb.cxx\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"docker使用hexo\"><a href=\"#docker使用hexo\" class=\"headerlink\" title=\"docker使用hexo\"></a>docker使用hexo</h2><ul>\n<li>1.安装Hexo<pre><code>docker run --name hexo -it -p 8083:80 -v `pwd`: /usr/share/nginx/html/source simplyintricate/hexo\n</code></pre></li>\n<li>2.发布一篇blog<pre><code>docker exec -it hexo hexo new &quot;This is one post&quot;\n</code></pre></li>\n</ul>\n<h2 id=\"ODB项目设置：\"><a href=\"#ODB项目设置：\" class=\"headerlink\" title=\"ODB项目设置：\"></a>ODB项目设置：</h2><ul>\n<li>输入<pre><code>db-sqlite.lib;odb.lib\n</code></pre></li>\n<li>包含目录<pre><code>z:\\libraries\\orm\\sqlite3\\sqlite-amalgamation-3220000;\nz:\\libraries\\orm\\odb2.4\\libodb-2.4.0;\nz:\\libraries\\orm\\odb2.4\\libodb-sqlite-2.4.0;\n</code></pre></li>\n<li>库目录<pre><code>z:\\libraries\\orm\\sqlite3\\;\n</code></pre></li>\n</ul>\n<h2 id=\"odb备注\"><a href=\"#odb备注\" class=\"headerlink\" title=\"odb备注\"></a>odb备注</h2><pre><code>使用编译指令#pragma db transient 把字段声明为临时的，也就是该字段不保存与数据库中。\n</code></pre><h2 id=\"Error-ENOSPC-no-space-left-on-device\"><a href=\"#Error-ENOSPC-no-space-left-on-device\" class=\"headerlink\" title=\"Error: ENOSPC: no space left on device\"></a>Error: ENOSPC: no space left on device</h2><p>查看存储空间</p>\n<pre><code>$df -h\n</code></pre><p>查看i节点</p>\n<pre><code>$df -i\n</code></pre><p>看是那种情况。</p>\n<p>不幸的是我哪种都不是，后来在stackflow找到了答案。</p>\n<p>问题原因:You may have reached your quota of watches.</p>\n<p>解决办法</p>\n<p>查看目前的最大值</p>\n<p>To find your current limit, type this in your terminal:</p>\n<pre><code>$cat /proc/sys/fs/inotify/max_user_watches\n</code></pre><p>增加最大值</p>\n<p>Which is typically 8192 by default.</p>\n<p>To increase your limit, type this:</p>\n<pre><code>$sudo sysctl fs.inotify.max_user_watches=16384\n</code></pre><p>永久设置最大值</p>\n<p>Then restart django.</p>\n<p>To permanently set this limit, type this:</p>\n<pre><code>$echo 16384 | sudo tee -a /proc/sys/fs/inotify/max_user_watches\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"thrift编译设置\"><a href=\"#thrift编译设置\" class=\"headerlink\" title=\"thrift编译设置\"></a>thrift编译设置</h2><hr>\n<ul>\n<li>附加包含目录<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src;\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows;\nZ:\\libraries\\boost\\boost_1_66_0;\n</code></pre></li>\n</ul>\n<ul>\n<li><p>预处理器定义</p>\n<pre><code>HAVE_CONFIG_H=1\nWIN32\n_DEBUG\n_CONSOLE\n</code></pre></li>\n<li><p>代码生成：</p>\n<pre><code>DEBUG  运行库 MTD\nRELEASE 运行库 MT\n</code></pre></li>\n</ul>\n<ul>\n<li>预编译头<pre><code>不使用预编译头\n</code></pre></li>\n</ul>\n<ul>\n<li><p>附加依赖项</p>\n<pre><code>libssl.lib\nlibthrift.lib\nlibcrypto.lib\n</code></pre></li>\n<li><p>附加库目录</p>\n<pre><code>Z:\\libraries\\boost\\boost_1_66_0\\stage\\lib;\nz:\\libraries\\openssl\\OpenSSL-Win32\\lib;\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\Debug-mt;\n</code></pre></li>\n</ul>\n<h2 id=\"错误处理\"><a href=\"#错误处理\" class=\"headerlink\" title=\"错误处理\"></a>错误处理</h2><p>使用vs2017编译thrift项目时出现以下错误：objbase.h(230): error C2760错误的解决的解决办法：<br><figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#在stdafx.h中添加</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WIN32_LEAN_AND_MEAN</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"openssl-编译设置\"><a href=\"#openssl-编译设置\" class=\"headerlink\" title=\"openssl 编译设置\"></a>openssl 编译设置</h2><ul>\n<li>动态编译<pre><code>WIN64\nperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64\nnmake clean\nnmake\nnmake test\nnmake install\n</code></pre></li>\n</ul>\n<ul>\n<li>静态编译<pre><code>makefile and configdata 两个文件中的/MD改为/MT\nperl Configure VC-WIN64A no-asm --prefix=z:\\libraries\\openssl\\vc-64_static\nnmake clean\nnmake\nnmake test\nnmake install\n</code></pre></li>\n</ul>\n<h2 id=\"thrift-0-11-0编译问题及解决：\"><a href=\"#thrift-0-11-0编译问题及解决：\" class=\"headerlink\" title=\"thrift 0.11.0编译问题及解决：\"></a>thrift 0.11.0编译问题及解决：</h2><ul>\n<li>一、包含目录要加上openssl的目录引用</li>\n<li><p>二、THttpserver.cpp与THttpclient.cpp中的</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//#include &lt;thrift/config.h&gt;此行改为</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;thrift/thrift.h&gt;</span></span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>三、添加以下宏定义</p>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在&lt;thrift/thrift-config.h&gt;中</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PACKAGE_VERSION  <span class=\"meta-string\">\"$&#123;PACKAGE_VERSION&#125;\"</span></span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"thrift客户端与服务器编译设置：（release编译设置静态编译WITH-VS2017）\"><a href=\"#thrift客户端与服务器编译设置：（release编译设置静态编译WITH-VS2017）\" class=\"headerlink\" title=\"thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）\"></a>thrift客户端与服务器编译设置：（release编译设置静态编译WITH VS2017）</h2><ul>\n<li>c++常规–附加包含目录：<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\nZ:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\src\\thrift\\windows\nZ:\\libraries\\boost\\boost_1_66_0\n</code></pre></li>\n<li>链接器–常规–附加库目录<pre><code>Z:\\libraries\\thrift\\thrift-0.11.0\\lib\\cpp\\release-mt\nZ:\\libraries\\boost\\boost_1_66_0\\stage\\lib141\nZ:\\libraries\\openssl\\OpenSSL-Win32\\lib\n</code></pre></li>\n<li>链接器–输入–附加依赖项<pre><code>libthrift.lib\nlibssl.lib\nlibcrypto.lib\n</code></pre></li>\n</ul>\n<h2 id=\"使用odb时自定义生成：\"><a href=\"#使用odb时自定义生成：\" class=\"headerlink\" title=\"使用odb时自定义生成：\"></a>使用odb时自定义生成：</h2><ul>\n<li><p>在项目中选中类文件如：employee.hxx  右键–属性–配置属性–常规–项类型 设置成：自定义生成工具</p>\n</li>\n<li><p>然后选中：自定义生成工具并设置如下：</p>\n<ul>\n<li>命令行：<pre><code>odb.exe --std c++11 --database sqlite --generate-query --generate-schema --table-prefix boost_ employee.hxx\n</code></pre></li>\n<li>说明：<pre><code>odb employee.hxx\n</code></pre></li>\n<li>输出：<pre><code>employee-odb.hxx\nemployee-odb.ixx\nemployee-odb.cxx\n</code></pre></li>\n</ul>\n</li>\n</ul>\n<h2 id=\"docker使用hexo\"><a href=\"#docker使用hexo\" class=\"headerlink\" title=\"docker使用hexo\"></a>docker使用hexo</h2><ul>\n<li>1.安装Hexo<pre><code>docker run --name hexo -it -p 8083:80 -v `pwd`: /usr/share/nginx/html/source simplyintricate/hexo\n</code></pre></li>\n<li>2.发布一篇blog<pre><code>docker exec -it hexo hexo new &quot;This is one post&quot;\n</code></pre></li>\n</ul>\n<h2 id=\"ODB项目设置：\"><a href=\"#ODB项目设置：\" class=\"headerlink\" title=\"ODB项目设置：\"></a>ODB项目设置：</h2><ul>\n<li>输入<pre><code>db-sqlite.lib;odb.lib\n</code></pre></li>\n<li>包含目录<pre><code>z:\\libraries\\orm\\sqlite3\\sqlite-amalgamation-3220000;\nz:\\libraries\\orm\\odb2.4\\libodb-2.4.0;\nz:\\libraries\\orm\\odb2.4\\libodb-sqlite-2.4.0;\n</code></pre></li>\n<li>库目录<pre><code>z:\\libraries\\orm\\sqlite3\\;\n</code></pre></li>\n</ul>\n<h2 id=\"odb备注\"><a href=\"#odb备注\" class=\"headerlink\" title=\"odb备注\"></a>odb备注</h2><pre><code>使用编译指令#pragma db transient 把字段声明为临时的，也就是该字段不保存与数据库中。\n</code></pre><h2 id=\"Error-ENOSPC-no-space-left-on-device\"><a href=\"#Error-ENOSPC-no-space-left-on-device\" class=\"headerlink\" title=\"Error: ENOSPC: no space left on device\"></a>Error: ENOSPC: no space left on device</h2><p>查看存储空间</p>\n<pre><code>$df -h\n</code></pre><p>查看i节点</p>\n<pre><code>$df -i\n</code></pre><p>看是那种情况。</p>\n<p>不幸的是我哪种都不是，后来在stackflow找到了答案。</p>\n<p>问题原因:You may have reached your quota of watches.</p>\n<p>解决办法</p>\n<p>查看目前的最大值</p>\n<p>To find your current limit, type this in your terminal:</p>\n<pre><code>$cat /proc/sys/fs/inotify/max_user_watches\n</code></pre><p>增加最大值</p>\n<p>Which is typically 8192 by default.</p>\n<p>To increase your limit, type this:</p>\n<pre><code>$sudo sysctl fs.inotify.max_user_watches=16384\n</code></pre><p>永久设置最大值</p>\n<p>Then restart django.</p>\n<p>To permanently set this limit, type this:</p>\n<pre><code>$echo 16384 | sudo tee -a /proc/sys/fs/inotify/max_user_watches\n</code></pre>"},{"title":"Linux禁止用户或IP通过SSH登录(备忘)","abbrlink":53408,"date":"2018-10-26T00:31:49.000Z","_content":"\n\n\n## 限制用户 SSH 登录\n\n* 1.只允许指定用户进行登录（白名单）：\n\n在 /etc/ssh/sshd_config 配置文件中设置 AllowUsers 选项，（配置完成需要重启 SSHD 服务）格式如下：\n\n\tAllowUsers    aliyun test@192.168.1.1            \n\t# 允许 aliyun 和从 192.168.1.1 登录的 test 帐户通过 SSH 登录系统。\n\n* 2.只拒绝指定用户进行登录（黑名单）：\n\n在/etc/ssh/sshd_config配置文件中设置DenyUsers选项，（配置完成需要重启SSHD服务）格式如下：   \n\n\tDenyUsers    zhangsan aliyun    #Linux系统账户        \n\t# 拒绝 zhangsan、aliyun 帐户通过 SSH 登录系统\n\n* 限制 IP SSH 登录\n除了可以禁止某个用户登录，我们还可以针对固定的IP进行禁止登录，linux 服务器通过设置 /etc/hosts.allow 和 /etc/hosts.deny 这个两个文件，\nhosts.allow许可大于hosts.deny可以限制或者允许某个或者某段IP地址远程 SSH 登录服务器.方法比较简单，具体如下：\n\n1.vim /etc/hosts.allow， 添加\n\n\tsshd:192.168.0.1:allow  #允许 192.168.0.1 这个 IP 地址 ssh 登录\n\tsshd:192.168.0.1/24:allow #允许 192.168.0.1/24 这段 IP 地址的用户登录\n\n2.vim /etc/hosts.deny，添加\n\n\tsshd:ALL # 允许全部的 ssh 登录 \n\n\nhosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高，按照此方法设置后服务器只允许 192.168.0.1 这个 IP 地址的 ssh 登录，其它的 IP 都会拒绝。\n\n\t/etc/hosts.deny添加\n\tsshd:ALL #拒绝全部IP","source":"_posts/linux-ssh.md","raw":"---\ntitle: Linux禁止用户或IP通过SSH登录(备忘)\ntags: 网络安全\nabbrlink: 53408\ndate: 2018-10-26 08:31:49\n---\n\n\n\n## 限制用户 SSH 登录\n\n* 1.只允许指定用户进行登录（白名单）：\n\n在 /etc/ssh/sshd_config 配置文件中设置 AllowUsers 选项，（配置完成需要重启 SSHD 服务）格式如下：\n\n\tAllowUsers    aliyun test@192.168.1.1            \n\t# 允许 aliyun 和从 192.168.1.1 登录的 test 帐户通过 SSH 登录系统。\n\n* 2.只拒绝指定用户进行登录（黑名单）：\n\n在/etc/ssh/sshd_config配置文件中设置DenyUsers选项，（配置完成需要重启SSHD服务）格式如下：   \n\n\tDenyUsers    zhangsan aliyun    #Linux系统账户        \n\t# 拒绝 zhangsan、aliyun 帐户通过 SSH 登录系统\n\n* 限制 IP SSH 登录\n除了可以禁止某个用户登录，我们还可以针对固定的IP进行禁止登录，linux 服务器通过设置 /etc/hosts.allow 和 /etc/hosts.deny 这个两个文件，\nhosts.allow许可大于hosts.deny可以限制或者允许某个或者某段IP地址远程 SSH 登录服务器.方法比较简单，具体如下：\n\n1.vim /etc/hosts.allow， 添加\n\n\tsshd:192.168.0.1:allow  #允许 192.168.0.1 这个 IP 地址 ssh 登录\n\tsshd:192.168.0.1/24:allow #允许 192.168.0.1/24 这段 IP 地址的用户登录\n\n2.vim /etc/hosts.deny，添加\n\n\tsshd:ALL # 允许全部的 ssh 登录 \n\n\nhosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高，按照此方法设置后服务器只允许 192.168.0.1 这个 IP 地址的 ssh 登录，其它的 IP 都会拒绝。\n\n\t/etc/hosts.deny添加\n\tsshd:ALL #拒绝全部IP","slug":"linux-ssh","published":1,"updated":"2019-02-12T03:17:45.021Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u4n000iacelbqrqmztt","content":"<h2 id=\"限制用户-SSH-登录\"><a href=\"#限制用户-SSH-登录\" class=\"headerlink\" title=\"限制用户 SSH 登录\"></a>限制用户 SSH 登录</h2><ul>\n<li>1.只允许指定用户进行登录（白名单）：</li>\n</ul>\n<p>在 /etc/ssh/sshd_config 配置文件中设置 AllowUsers 选项，（配置完成需要重启 SSHD 服务）格式如下：</p>\n<pre><code>AllowUsers    aliyun test@192.168.1.1            \n# 允许 aliyun 和从 192.168.1.1 登录的 test 帐户通过 SSH 登录系统。\n</code></pre><ul>\n<li>2.只拒绝指定用户进行登录（黑名单）：</li>\n</ul>\n<p>在/etc/ssh/sshd_config配置文件中设置DenyUsers选项，（配置完成需要重启SSHD服务）格式如下：   </p>\n<pre><code>DenyUsers    zhangsan aliyun    #Linux系统账户        \n# 拒绝 zhangsan、aliyun 帐户通过 SSH 登录系统\n</code></pre><ul>\n<li>限制 IP SSH 登录<br>除了可以禁止某个用户登录，我们还可以针对固定的IP进行禁止登录，linux 服务器通过设置 /etc/hosts.allow 和 /etc/hosts.deny 这个两个文件，<br>hosts.allow许可大于hosts.deny可以限制或者允许某个或者某段IP地址远程 SSH 登录服务器.方法比较简单，具体如下：</li>\n</ul>\n<p>1.vim /etc/hosts.allow， 添加</p>\n<pre><code>sshd:192.168.0.1:allow  #允许 192.168.0.1 这个 IP 地址 ssh 登录\nsshd:192.168.0.1/24:allow #允许 192.168.0.1/24 这段 IP 地址的用户登录\n</code></pre><p>2.vim /etc/hosts.deny，添加</p>\n<pre><code>sshd:ALL # 允许全部的 ssh 登录 \n</code></pre><p>hosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高，按照此方法设置后服务器只允许 192.168.0.1 这个 IP 地址的 ssh 登录，其它的 IP 都会拒绝。</p>\n<pre><code>/etc/hosts.deny添加\nsshd:ALL #拒绝全部IP\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"限制用户-SSH-登录\"><a href=\"#限制用户-SSH-登录\" class=\"headerlink\" title=\"限制用户 SSH 登录\"></a>限制用户 SSH 登录</h2><ul>\n<li>1.只允许指定用户进行登录（白名单）：</li>\n</ul>\n<p>在 /etc/ssh/sshd_config 配置文件中设置 AllowUsers 选项，（配置完成需要重启 SSHD 服务）格式如下：</p>\n<pre><code>AllowUsers    aliyun test@192.168.1.1            \n# 允许 aliyun 和从 192.168.1.1 登录的 test 帐户通过 SSH 登录系统。\n</code></pre><ul>\n<li>2.只拒绝指定用户进行登录（黑名单）：</li>\n</ul>\n<p>在/etc/ssh/sshd_config配置文件中设置DenyUsers选项，（配置完成需要重启SSHD服务）格式如下：   </p>\n<pre><code>DenyUsers    zhangsan aliyun    #Linux系统账户        \n# 拒绝 zhangsan、aliyun 帐户通过 SSH 登录系统\n</code></pre><ul>\n<li>限制 IP SSH 登录<br>除了可以禁止某个用户登录，我们还可以针对固定的IP进行禁止登录，linux 服务器通过设置 /etc/hosts.allow 和 /etc/hosts.deny 这个两个文件，<br>hosts.allow许可大于hosts.deny可以限制或者允许某个或者某段IP地址远程 SSH 登录服务器.方法比较简单，具体如下：</li>\n</ul>\n<p>1.vim /etc/hosts.allow， 添加</p>\n<pre><code>sshd:192.168.0.1:allow  #允许 192.168.0.1 这个 IP 地址 ssh 登录\nsshd:192.168.0.1/24:allow #允许 192.168.0.1/24 这段 IP 地址的用户登录\n</code></pre><p>2.vim /etc/hosts.deny，添加</p>\n<pre><code>sshd:ALL # 允许全部的 ssh 登录 \n</code></pre><p>hosts.allow 和hosts.deny 两个文件同时设置规则的时候，hosts.allow 文件中的规则优先级高，按照此方法设置后服务器只允许 192.168.0.1 这个 IP 地址的 ssh 登录，其它的 IP 都会拒绝。</p>\n<pre><code>/etc/hosts.deny添加\nsshd:ALL #拒绝全部IP\n</code></pre>"},{"title":"敏捷技能修炼笔记一","comments":1,"abbrlink":"99b996d5","date":"2019-02-12T06:32:43.000Z","_content":"\n\n## 第一部分 最关键的小舵板\n\n### 第一章 意图导向编程\n\n#### 1.1 意图导向编程:一个实例\n\n在这个实例中,需要写些代码。我们需要创建一个服务程序,它接受一个业务交易,然后提交。我们决定(不管是正确或错误)先简单创建一个对象,这个对象只包含一个公共方法来完成这件事。\n\n具体需求如下:\n\n* 1:交易信息开始于一串标准ASCII字符串。\n* 2:这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)。\n* 3:每一个词汇元素必须标准化(第一个字母大写,其余字母小写,空格和非字母数字的符号都要删掉)。\n* 4:包含超过150个词汇元素的交易,应该采用不同于小型交易的方式(不同的算法)来提交,以提高效率。\n* 5:如果提交成功,API方法应该返回\"true\";失败,则应该返回\"false\"。\n\n这里并没有涉及某些细节(比如提交的算法具体是什么),这样就可以只关注我们感兴趣的实践。\n\n有一点是应该充分利用的:在学习一种程序语言编码的时候,我们会把问题分解为一系到的功能性步骤,在这个过程中,我们的思维不断地得到锻炼。随着代码写得越来越多,我们解决这类问题的能力也变得越来越强。\n\n继续考虑前面的那个问题,需求列出的每一点要求都代表一个功能性步骤。在写代码的过程中,我们会按照一定的顺序,有意识地去完成每一点要求。而意图导向编程是指,先假设当前这个对象中,已经有了一个理想方法,它可以准确无误地完成你想做的事情,而不是直接盯着每一点要求来编写代码。先问问自己:\"假如这个理想的方法已经存在,它应该具有什么样的输入参数,返回什么值?还有,对我来说,什么样的名字最符合它的意义?\"\n\n现在,因为这个方法并没有实际存在,所以除了你自己的最终意图之外,没有任何其他东西的约束(因此,你是\"意图在主导编程\")。试试写出代码,像下面这样:\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n    }\n}\n\n```\n\n书中此例所用的代码被包装到类Transcation中，我觉得对于当前的情况，不需要引入类来干扰问题的说明，只需要关注于实现的方法即可，同时，由于java语言的声明中就包含了返回值类型，所以，可以改进如下：\n```java\n//java code\nBoolean commit(String command) {\n    String[] tokens = tokenize (command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        return processLargeTransaction(tokens);\n    }\n    return processSmallTransaction(tokens);\n}\n\n\n```\n可以看到，\n* 第2行：commit方法中的参数类型String，与我们需求1的要求交易信息开始于一串标准ASCII字符串相对应。\n* 第3行：tokenize方法及其返回值类型。与我们需求2的要求这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)相对应。\n* 第4行: normalizeTokens(tokens)方法，与我们需求3每一个词汇元素必须标准化相对应。\n* 第5-8行： 则用:isALargeTransaction方法进行交易类型的判断。并分别用processLargeTransaction与processSmallTransaction两个处理函数来对不同交易类型进行处理。同时，返回值也满足需求5对返回值类型的要求。\n\n同时，采用意图导向编程，对于不同的编程语言也是同构的，以下列出几种常用编程语言的实现。\n\n```c++\n//c++ code\nbool commit(std::string command) {\n    std::vector<std::string> tokens = tokenize(command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        return processLargeTransaction(tokens);\n    } \n    return processSmallTransaction(tokens);\n}\n\n\n```\n对于python或javascript之类的语言，函数定义中有包含返回值类型的，则可以加入一个返回值变量以让代码意思更清晰易懂：\n\n```python\n#python code\ndef commit (command ):\n\tresult = true\n    tokens = tokenize(command)\n    normalizeTokens(tokens)\n    if isALargeTransaction(tokens):\n        result = processLargeTransaction(tokens)\n    else:\n    \tresult = processSmallTransaction(tokens)\n    \n    return result\n\n```\n\n```javascript\n//javascript code\ncommit(command){\n\tvar result = true;\n    tokens = tokenize(command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        result = processLargeTransaction(tokens);\n    }else{ \n    \tresult = processSmallTransaction(tokens);\n\t}\n\n    return result;\n}\n\n```\ncommit()方法是我们为这个对象定义的应用程序接口(API)。当然,它是公共方法,这样才能交给客户端对象,为它们提供服务。所有其他方法(tokenize()、isALarge-Transaction()、processLargeTransaction()和processSma11Transaction())都不属于这个对象API的一部分,而仅仅是实现过程中的功能性步骤。因此,它们常常称为\"辅助方法\"(helper methods)。现在,我们先把它们当做私有方法(稍后我们会发现,这样做并不总是完全正确的)。重点是,它们是这个服务内部实现的一部分,而不是外界需要调用的接口。\n\n并且,它们现在还没有真正存在。如果现在尝试编译一下代码,编译器肯定会报告它们并不存在(不过……我们将试这样能,让编译器帮助我们列出后续工作的待办事项清单。 为了代码编译通过,接下来我们必须要创建它们。\n\n用这样的编码方式,我们可以把精力集中在如何分解最终目标,以及那些全局性的问题上。例如,我们必须考虑在实现语言中,用到的这个string数组是引用传递还是复制传递(很明显,我们猜想该语言是引用传递的；否则,我们就得把tokens作为nozmalizeTokens()函数的返回值保留下来)。至于其他单个步骤的实现细节,我们这里先不考虑。\n\n这样做的意义是什么呢?我们很快会了解到,它有很多好处。但在此之前,让我们先确认一件很重要的事:这样做其实一点都不难。你的时间表里没有因此而增加更多的工作,与直接把所有代码写到一个很长的方法里(就像我们以前写程序一样,一大堆逻辑结构代码)的工作量是基本差不多的。仅有的少许不同,是我们思考的方式以及编码的顺序。 \n\n这非常重要。理论上,好的实践应该是在任何时候都可以实行,并且能够推广到整个团队,成为那些可以一直贯彻执行的守则。事实上,只有当这些实践的执行成本很低(或者说,几乎零成本)的时候,才有可能做到这点。 \n\n### 1.2优点\n\n还是老问题,用这样的方式编程意义何在呢? \n\n有时候,这样一个小小的问题所引出的答案会令你惊叹不已。我们先把这些优点汇总罗列出来,再——进行分析。 \n\n如果遵循意图导向编程的方式,那么代码将会: \n\n* 更加内聚(职责单一) \n* 更加可读和清晰。 \n* 更易于调试。 \n* 更易于重构和优化, 所以只做最少的设计,满足当前需要。\n* 更易于单元翻试。\n\n同时,从这些优点中还会延伸出其他优点:代码更易于修改和扩展。其他还有:\n* 模式更容易应用到代码中。 \n* 创建的方法可以容易地从一个类移动到另一个类。 \n* 代码更易于维护。 \n\n#### 1.2.1方法的内聚性 \n\n代码的质量标准之一,就是内聚性。它促使代码更易于理解、更易于扩展和修改。通常 情况下,我们希望软件实体(software entity)具备单一的特性,换句话说,一个实体只为了 ——个目的或原因而存在。 \n\n以类为例。一个类应该根据它的职责来定义,并且每个类通常应该只有一个职责。类的内部包含方法、状态以及与其他对象之间的关系,正是它们使得类的职责能够被正确地履行。在一个类的内部,如果各个方面都紧密相关,并且都在这个类的唯一职责范围之内,那么我们就说这个类的内聚性很强。 \n\n你也许会对前面的例子提出异议,我们的代码中有些部分的职责实际上是不同的,它们应该放到不同的类中。或许,把它们完全梳理清楚是一件挺棘手的事情。但是,即使无法做到完美无缺,如果遵循意图导向编程的方式,在绝大多数情况下,仍然可以达到一定程度上的内聚性。\n\n方法的内聚也是关于单一性的问题,不过关注点是在函数上。如果一个方法只实现整体职能中一个单独的功能点,我们就说这个方法的内聚性很强。人的思维方式是单线程的,当人们开始\"多任务\"的时候,他们实际上只是快速地在多个任务之间进行切换而已;我们仍旧习惯于一次只思考一件事情。意图导向编程正是利用这一事实,用我们思维链条单一性的特点去创建同样具备单一性的内聚方法。\n\n意图导向编程能带来诸多好处的一个很重要的原因,正是方法的内聚性。 \n\n#### 1.2.2 可读性和表达性\n\n让我们再回过头来看看最初的代码示例,观察一下它的可读性怎样。\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n\n    }\n}\n```\n\n代码基本上是这样\"讲\"的:\"我们获得一个指令,准备提交。先对指令进行分词,把 词汇元素标准化,然后根据得到的词汇元素集合的大小,决定采用大型事务的机制还是小型事务的机制进行处理。最后,返回处理结果。\" \n\n因为没有涉及每一步是\"如何做\",而仅仅是\"做什么\",所以只要快速地读一遍方法, 就可以很容易地了解到整体流程是如何工作的。有时候,我们需要的正是快速地了解事物在 如何运作。 \n\n这种方式提供了很好的可读性,表达也很清晰。值得注意的一点是,我们并没有在代码 中包含任何注释,但读者很容易了解到其中的意义。这是因为我们想通过注释表达的东西, 都已包含在方法的名称中。 \n\n当然,注释也是一种清晰的表达方法,但问题是,编译器看不到。同时,很多不相信注释准确性的程序员也会忽略它们。如果注释在代码中存在了很久,它就会变得不可靠,原因我们都很清楚:代码可能已经改变了,但注释或许并没有更新。如果过度相信注释,它可 能会误导我们,也没有其他简单的方法去验证是不是这样。我们只能被迫去调查代码,注释 的表达功能就这样蒸发掉了。因此,注释往往会被程序员忽略,失去它本来的作用。\n\n回到我们讨论的主题,在意图导向编程中,组织一个方法的时候应该包括所有的流程步骤,但很少或者完全不用涉及实际的步骤实现。在某种意义上,这是另外一种形式的内聚: 把处理某件事的流程和具体做事的实现方式区分开。 \n\n另一件促使代码更易读和清晰的事情是,当我们创建代码实体时,它们的名字应该能表达出创建的目的。如果方法是内聚的,用一两个词来完整描述它们是做什么的就变得很容易,而不用在名称中加入许多下划线、\"and\"和\"or\"。同时,在我们给方法命名的时候,它们还没有真正存在,这促使我们去选择能表达自己想法的名字。这种名字揭示了命名背后的意图,我们把它们叫做\"表露意图的名称\"(intention-revealing names)。有一些命名是我们应该尽量避免的,比如有些名字,当你明白功能是什么之后,它很容易理解;但在别人解释之前,又容易引起误解。\n\n#### 注释会成为代码的一种\"臭味\"\n\n虽然我们没有断言说,不应该写注释,但有些注释确实是代码的一种\"臭味\"。例如,假如我们写了这样的代码:\n```java\npublic class Transaction (\n\tpublic Boolean commit ( String command ) (\n\t\tBoolean result = true :\n\t\tcome hore\n\t\tbone coue liece\n\t\tSome more code here\n\n\t\tEven some more code here that sets tokens\n\t\tSome code here that normalizes Tokens\n\t\tSome more code here that normalizes\n\t\tsome more coue use cnat normalizes ' rokens\n\t\tEven more code here that normalizes Tokens\n\t\tCode that determines if you have a large transaction\n\t\tSet 1t = true if you do\n\t\t\n\t\tif ( 1t ){\n\t\t\tSome code here to process large transactions\n\t\t\tMore code here to process large transactions\n\t\t} else {\n\t\t\tSome code here to process small transactions\n\t\t\t有效期限\n\t\t\tMore code here to process small transactions\n\t\t}\n\t\treturn result ;\n\t}\n}\n```\n\n当看到这段代码时,你可能会说:\"天哪,我可不明白它在干什么;让我们加些注释吧。\"然后在上面加了些东西:\n```java\npublic class Transaction {\n\tpublic Boolean commit ( String command ) f\n\tBoolean result = true ;\n\t// tokenize the string\n\tSome code here\n\tSome more code here\n\tEven some more code here that sets tokens\n\n\n\n\t//normalise the tokens I am there that normalizes Tokens normalises Tokens \n\tsome cooe code here Some more c \n\tThe more code here that normalizes Tokens \n\tsee it you have a large transaction Code that determines \n\tif you have a large transaction Cet Ite true if you do \n\tif ( it ) {\n\t\tprocess large transaction It , \n\t\tto process large transactions 公民身份号码 \n\t\tSome Here code here to process large transactions \n\t) else ( \n\t\tprocess small transaction time code here to process small transactions es , \n\t\tcode here to process small transactions \n\t\treturn result ; \n\t}\n}\n\n\n```\n注意到了吗?当写完代码之后,我们加入注释来描述做了什么。如果遵循意图导向编辑 的方式,这些注释就不再需要。前面提到的替代注释的方法其实更有用,因为编译的时候 它们(代码本身)一定是最新的。 \n\n#### 1.2.3 调试 \n\n在Net Objectives公司的培训课程中,我们往往会问学员一个问题,他们是否花费了大量 的时间来修改代码中的错误。除了那些已经上过我们课程的人外,大部分人的答案都是\"是的\"。这也是让软件开发变得棘手的一个主要原因。\n\n我们向他们指出,在调试过程中,寻找系统中的错误所在才是最花时间的部分。一旦错误装定位,修复工作反而不是什么太大的问题。几乎所有的学员听到这点,都会立刻点点头。由此可见,在创建需要调试的代码时,真正的技巧是用一切手段让代码中的错误容易再现。当然,我们应该尽量小心,在开始写代码的时候就别犯错。但是,哪怕你做到了尽善尽美,往往还有别人要来改动这段代码。\n\n当遵循意图导向编程的时候,我们更容易做到让一个方法只做一件事。这时候,如果系统中有些部分不能正常工作了,试试下面的方法:\n\n* (1)通读一遍整个方法,看看所有事情是怎么运作的。 \n* (2)对无法正常工作的部分,检查一下辅助方法的细节有什么问题。 \n\n相对于费力地查阅一大段复杂的代码,尤其是有些代码还可能涉及许多不相关的系统的方方面面,这种调试方法发现代码借误的速度要快得多。 \n\n例如,调试遗留系统是个苦差事,因为问题往往是多种原因共同引起的。其中一个很大的因素是它的代码常常是一大段一大段写出来的。因此,你最后不得不把代码打印出来,准备好各种彩色荧光笔,根据代码是做什么的来进行逻辑分块。\"我会把数据库部分标为黄色, 业务逻辑标为蓝色......\",这样做既艰苦又容易出错,还很枯燥,对程序员来说,这可不是打发时间的好方式。还是让计算机来完成这些让人厌烦的工作吧。 \n\n#### 1.2.4 重构和增强\n\n在创建系统的最初阶段,我们很难准确地知道设计应该做到什么程度,复杂度又是多少。由于复杂度是引起系统难以修改的原因之一,所以,如果可以的话,我们希望做最少的设计,仅仅增加那些真正需要的东西,让系统正常运行。 \n\n尽管如此,当我们实际做的时候往往会犯下很多错误,真正需要的功能并没有正确运行。或者即使我们的系统终于正常工作了,来自客户、利益相关人员或者市场的需求又更改了规则。 基于这点,我们常常需要这样做: ·重构系统(保持系统行为不变的情况下,更改它的结构)。 \n\n增强系统(增加或修改系统的行为以符合新的需求)。\n\n重构通常认为是\"清理\"刚开始时写得糟糕的代码。有时候项目十万火急,我们没有认真顾及代码质量,草草维护和修改,代码就在这个过程中变得腐朽不堪。或者,当我们对整个程序有了更深的了解,清楚地知道代码需要重新设计时,也可以用到重构。 \n\n1999年,Martin Fowler写了一本经典的书籍《Refactoring》9,这本书记载了各种不同 的、在保持系统行为不变的情况下,如何修改代码的方法,并给每种方法命了名(通常叫做一次\"迁移\")。 \n\n在学习重构原则的时候,大多数人首先学到的一个迁移方法叫做提炼函数(Extract Method);把一部分代码从一个巨大的方法中抽取出来,放到一个属于它自己的新方法中。而在原来代码中的那个位置直接调用这个新方法。由于原来方法的一部分临时变量也需要迁称到新方法中,所以需要多个步骤才能完成一个函数的提炼。\n\n该书在讲述许多其他的重构迁移方法时,开始都有一句基本说明\"在开始这个方法之前,你需要不断地采用'提炼函数'方法,直到所有的方法都是内聚的。\"如果你遵循意图导向编程,你会发现你已经做到了这点。Ken Pugh在《Prefactoring)一书中也广泛地研究了像意图导向编程这样简单而有效的方式是如何更好地帮助我们编写程序的。\n\n如果你已经做到了书中所写的那样,在写代码时习惯性地先\"预构\"(prefactored),则进行代码重构的时候,困难就要少很多。代码的方法内聚性越强,重构就越容易。\n\n同样,意图导向编程能够让系统在以后增强时变得更加容易。让我们回到前面交易处理程序的例子。\n\n设想一下6个月后,这些代码已经成为产品,一个新的需求加入进来:由于与这个业务交易系统有交互的某些第三方程序的原因,我们必须对某些旧版本的词汇元素进行转换(需要转换的词汇元素可能有很多)以支持整个系统的运行。现在,命令字符串中可能包含领域语言不再兼容的词汇元素,为了处理这种情况,我们必须再\"更新\"一下所有词汇元素。\n\n在这种情况下,我们只需做出一个小小的修改。你大可拍着胸脯说:\"没问题。\"\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        updateTokens(tokens)\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n\n    }\n}\n```\n接下来,就是写出updateTokens()方法,在这个过程中我们会发现,新代码对原新的其他部分造成破坏的可能性是非常小的。事实上,修改这段代码里的任何辅助方法,我们都可以信心十足地认为,我们仅仅改动了想要改变的部分。就像上面这样,内聚性让我们更容易进行封装。\n\n#### 1.2.5 单元测试 \n\n在意图导向编程中,如果一个对象尚未完成,我们不会去扩充它的外部接口;相反,要确保在代码实现之前就把接口定义清楚。事实上,我们希望遵照模式所推荐的关于设计的基本建议:使用服务的客户端,在设计时应当遵照的是它的接口定义,而不是服务中的具体实现。 \n\n所以,至少在刚开始的时候,最好能把这些\"辅助方法\"都隐藏起来,因为它们都不是服务对外提供的API。我们不希望将来某一天,外部其他对象与这些方法发生什么关联(无 论是运作流程上的关联,还是直接存在引用关系)。这样可以让我们做到,在问题的方案细节发生变化的时候,无须修改系统中其他用到该对象的地方。\n\n尽管如此,如果我们把所有的辅助方法都变成私有方法,又似乎不利于对象测试(参见 图1-1)。\n\n```puml\n@startuml\ntitle 图1-1 意图导向编程 私有方法 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean isAlargeTranscation(String)\n\t  -Boolean processLargeTransaction(String)\n\t  -Boolean processSmallTransaction(String) \n}\n\nTransaction <|-down- TranscationTest:测试\n\n\n\n\n@enduml\n```\n\n\n\n私有方法无法被单元测试调用,因此我们只能针对commit()方法来写测试,这意味着必须在一个单独的测试用例中测试对象的整体行为。这样的测试可能比你想象的要复杂得多,同时,在编写测试的过程中,有多种因素都有可能导致测试失败。我们可不想发生这些的情况。\n\n也许我们可以解决这个难题。但不管怎样,把系统整体行为的各个不同方面区分开来。放到独立的方法中,至少在理论上让每个方法具备了可测试性,因为它们彼此之间不再耦合。就像使用这个类的客户端只与这个类的接口发生关联一样,在类的内部,AP1方法的实现只与辅助方法的接口发生关联。 \n\n那么,我们怎样来处理私有方法不能测试的问题呢?一般来说,有三个可行的方法:\n\n* 不用一个个地单独测试它们,只通过commit()方法来测试。在单元测试中,被测试的是行为而不是实现,所以如果这些辅助方法只是单个行为实现步骤的一部分,就没必要测试它们。我们希望在重构这些方法(甚至删除它们)之后,原来的测试仍! 旧能正确通过。\n\n* 在通常情况下,我们还是需要对它们进行单独的测试。尽管它们只是\"单个的步骤\",但我们知道它们会有弱点,在某些状况下可能会出错。从效率和安全性上考虑,应当把它们从整体流程中区分开来,进行单独测试。这种情况下,我们需要用些小聪明,加上一点儿测试技巧。这些技巧取决于开发语言本身,比如:把测试用例标注为被测试类的\"friend\"(在C++中),然后把私有方法包装进一个委托(delegate) 方法中,再测试这个委托方法。有时这也称为\"测试代理\"(testing proxy)(在.Net中),把方法变为\"protected\",在类的内部发起测试等。但要当心这些技巧过度使用;其他程序员可能无法理解你在做什么,尤其是当他们刚从一种语言平台转向另一种的时候,常常会晕头转向。同时,我们也不希望把测试与具体实现关联得大紧, 除非这么做是必要的。 \n\n* 事实上,有时候这些辅助方法理所应当单独测试,因为它们不仅仅是\"流程的单个 步骤\",而是完全不同的行为。或许它们在这个类中只是被用到,但在实现上讲,承 担完全独立的职责。测试这个类的同时也促使我们思考:\"它们真的只是一个步骤 吗?\"这也是设计时非常重要的一个方面。如果是这种情况,那么我们需要重新思考 当前的设计。例如,仔细想想,词汇元素标准化这一步就满足这种情况,应该单独测 试。这需要我们简单修改一下设计(参见图1-2)。\n\n\n```puml\n@startuml\ntitle 图1-2 设计改动 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean isAlargeTranscation(String)\n\t  -Boolean processLargeTransaction(String)\n\t  -Boolean processSmallTransaction(String) \n}\n\n\n\nclass TranscationTest{\n\t+testCommitATransaction()\n\n}\n\nclass TokenNormalizerTest{\n\t+testNormalize()\n}\n\nclass TokenNormalizer{\n\t+String normalize(String)\n}\n\nTransaction <|-down- TranscationTest:测试\n\nTokenNormalizer <|-right- Transaction\n\nTokenNormalizer <|-down- TokenNormalizerTest:测试\nnote right of Transaction : normalizeTokens(String){\\n    tokens = myNormalizer.normalize(tokens);\\n}\n\n@enduml\n```\n\n你或许注意到了,对TokenNormalizer的使用也是私有的。除了Transaction外,没其他地方用到TokenNormalizere,尽管如此,对TokenNormalizer的实现仍然是通过它自己定义的API,因此进行单独测试也变得可行了。 \n\n同时,你也会发现,由于一开始我们已经把词汇元素标准化这部分代码放在了独立的方法中,所以把它们抽取出来放到一个单独的类里就变得非常简单。如果方法一开始就是内聚 的,抽取一个新的类就变成一件轻而易举的事。因此,当我们需要时,就可以很快做出决 定,而不用考虑太多限制。 \n\n这样做的另一个原因是,系统中可能有其他实体也需要进行词汇元素标准化。如果这个 标准化的算法绑定在Transaction类的私有方法中,那么在类之外的其他环境里是无法使 用的。但如果它放在一个单独的类里,那么就可以调用它。因此,期望避免代码重复也会 促使我们做出同样的决定。 \n\n#### 1.2.6更易修改和扩展 \n\n就像前面看到的那样,意图导向编程使得代码质量得到提升,代码的修改和扩展也随之变得更加容易。经验告诉我们代码总会变化,只是我们现在并不清楚要修改什么地方,改成什么样子。意图导向编程帮助我们在几乎不花成本的情况下,创建更适合改动的代码。 \n\n#### 1.2.7在代码中发现模式\n\n在Net Objectives公司,我们提供了很多设计模式的相关培训;在各种学术会议中,模式地格是被反反复复地提到。当我们即将变成·模式先生\"的时候,总会有个家伙站出来说:\"模式是很酷,但我怎么知道在特定环境下到底该使用哪个好呢?\" \n\n这个问题的答案会引起一段很长却有趣(至少我们这么想)的对话,不过,如果遵循意 图导向编程,你就会发现模式有时就在你的代码实现当中。 \n\n让我们稍微改动一下前面的例子。 \n\n假如有两个完全不同的交易类型,它们的流程步骤一样(分词、标准化、更新、处理), 但每一步的实现方式不同。如果使用意图导向编程的方法来编码,尽管它们实现的\"辅助\" 方法不同,但是commit()方法看起来都差不多。这时候,你会发现模板方法模式(Template Method Pattern) O基本上已经站起来在向你挥手了(参见图1-3)。 \n\n```puml\n@startuml\ntitle 图1-3模板方法模式 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean processTransaction(String)\n}\n\nclass LargeTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n\n}\n\nclass SmallTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n}\n\n\n\nTransaction <|-down- LargeTranscation\n\nTransaction <|-down- SmallTranscation\n\n\n@enduml\n```\n\n\n更进一步,回到可测试性的问题。我们应该开始把这些行为抽取出来,让它们可以测试。在这个过程中,我们会发现这是使用策略模式的好机会。像上次一样,我们把词汇元素标准化这部分代码抽取出来(参见图1-4)。\n\n\n```puml\n@startuml\ntitle 图1-4模板方法和策略模式 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean processTransaction(String)\n}\n\nclass LargeTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n\n}\n\nclass SmallTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n}\n\nclass TokenNormalizer{\n\t+String normalize(String)\n}\n\nclass LargeTokenNormalizer{\n\t+String normalize(String)\n}\nclass SmallTokenNormalizer{\n\t+String normalize(String)\n}\n\n\n\nTransaction <|-down- LargeTranscation\n\nTransaction <|-down- SmallTranscation\n\n\nTokenNormalizer <|-left- Transaction\n\nTokenNormalizer <|-down- LargeTokenNormalizer\n\nTokenNormalizer <|-down- SmallTokenNormalizer\n\n@enduml\n```\n\n\n\n\n图1-4模板方法和策略模式\n\n#### 1.2.8 可迁移的方法\n\n前面我们提到,类的内聚性是这样一个概念,一个类在理想情况下,应该只有一个职责。它可以包含许多方法、成员变量以及与其他对象的关联关系来实现这一职责,但应当只有一个存在或需要修改的理由。\n\n意图导向编程通过一个简单的途径帮助我们创建内聚的方法:用自己的经验把功能进行分解。但是,这样做不会直接增强类的内聚性。实际上,很容易发现,在我们最开始编写Transaction类的代码的时候,它的内聚性并不强。\n\n要提高类的内聚性,一个办法是把这个类不应该有的方法全都迁移到其他类,或者新的类中,这样可以让这个类所关注的东西减少。因此,虽然意图导向编程没有直接实现类的内聚,但它让开发人员以后做起来更容易:内聚性问题出现的时候,就重构。\n\n为什么更容易?\n\n前面我们已经看到了其中一个原因。意图导向编程创建的方法只完成一个功能,这样避免了迁移方法时经常遇到的一个问题:方法中包含不能移走的部分。当一个方法只做一件事情的时候,如果它的一部分需要迁移,那么整个部分都应该移走。\n\n此外,还有另外一个原因。有时候,一个方法很难迁移,是由于它直接关联到了类中的状态变量(state member)。在迁移方法的过程中,我们也必须移动这些状态,或者找个办法让这些状态在方法迁移之后也能用得到。\n\n我们发现,当采用意图导向编程的方式编写代码的时候,我们更习惯于把需要用到的各种参数传递到方法中,再获取一个返回结果,而不是直接让方法使用对象的状态。如果没有与所在对象的内部状态发生关联,那么这些方法迁移起来就会更容易。 \n回到前面的例子,我们也许会这样做: \n\n```java\n\npublic class Transaction{private String[] tokens; \n\tpublic Boolean commit(string command){\n\t\tBoolean result = true；\n\t\ttokenizen();\n\t\tnormalizeTokens）\n\t\tif (isALargerransaction()){\n\t\t\tresult = processlargeTransaction(); \n\t\t} else{\n\t\t\tresult = processsmallTransaction();\n\t\t}\n\t\treturn result;\n\t}\n} \n\n```\n\n把tokens数组作为类的一个成员变量,原来把它用做参数的所有方法现在都可以简单 地直接引用它。意图导向编程无法强制你不这么干(它仅仅能够帮助我们避免把方法命名为ml()或go()之类),但它会让你的思路更自然地想到传递参数然后返回结果。根据我们了解到的情况,在使用意图导向编程的开发人员中,这样思考的人占绝大多数。 \n\n### 1.3小结 \n\n要让复杂的人类活动变得成熟和完善,一个至关重要的方面是发掘出那些有助于行动成 功的重要实践。在理想情况下,这些实践应该满足:\n\n* 带来很大价值。 \n* 做起来相对简单。 \n* 推广以及指导工作比较容易。 \n* 风险低。 \n* 通用(即使在不同的环境下,也不用犹豫是否要做)。 \n\n意图导向编程正是这样的一种实践。试试它吧!对绝大多数人而言,仅仅需要几个小时,就可以发现它简单、有趣,不用花费额外的精力就能写出更好的代码。\n\n\n","source":"_posts/敏捷技能修炼笔记一.md","raw":"---\ntitle: 敏捷技能修炼笔记一\ncomments: true\nabbrlink: 99b996d5\ndate: 2019-02-12 14:32:43\ncategories:  敏捷开发\ntags: 敏捷技能修炼\n---\n\n\n## 第一部分 最关键的小舵板\n\n### 第一章 意图导向编程\n\n#### 1.1 意图导向编程:一个实例\n\n在这个实例中,需要写些代码。我们需要创建一个服务程序,它接受一个业务交易,然后提交。我们决定(不管是正确或错误)先简单创建一个对象,这个对象只包含一个公共方法来完成这件事。\n\n具体需求如下:\n\n* 1:交易信息开始于一串标准ASCII字符串。\n* 2:这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)。\n* 3:每一个词汇元素必须标准化(第一个字母大写,其余字母小写,空格和非字母数字的符号都要删掉)。\n* 4:包含超过150个词汇元素的交易,应该采用不同于小型交易的方式(不同的算法)来提交,以提高效率。\n* 5:如果提交成功,API方法应该返回\"true\";失败,则应该返回\"false\"。\n\n这里并没有涉及某些细节(比如提交的算法具体是什么),这样就可以只关注我们感兴趣的实践。\n\n有一点是应该充分利用的:在学习一种程序语言编码的时候,我们会把问题分解为一系到的功能性步骤,在这个过程中,我们的思维不断地得到锻炼。随着代码写得越来越多,我们解决这类问题的能力也变得越来越强。\n\n继续考虑前面的那个问题,需求列出的每一点要求都代表一个功能性步骤。在写代码的过程中,我们会按照一定的顺序,有意识地去完成每一点要求。而意图导向编程是指,先假设当前这个对象中,已经有了一个理想方法,它可以准确无误地完成你想做的事情,而不是直接盯着每一点要求来编写代码。先问问自己:\"假如这个理想的方法已经存在,它应该具有什么样的输入参数,返回什么值?还有,对我来说,什么样的名字最符合它的意义?\"\n\n现在,因为这个方法并没有实际存在,所以除了你自己的最终意图之外,没有任何其他东西的约束(因此,你是\"意图在主导编程\")。试试写出代码,像下面这样:\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n    }\n}\n\n```\n\n书中此例所用的代码被包装到类Transcation中，我觉得对于当前的情况，不需要引入类来干扰问题的说明，只需要关注于实现的方法即可，同时，由于java语言的声明中就包含了返回值类型，所以，可以改进如下：\n```java\n//java code\nBoolean commit(String command) {\n    String[] tokens = tokenize (command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        return processLargeTransaction(tokens);\n    }\n    return processSmallTransaction(tokens);\n}\n\n\n```\n可以看到，\n* 第2行：commit方法中的参数类型String，与我们需求1的要求交易信息开始于一串标准ASCII字符串相对应。\n* 第3行：tokenize方法及其返回值类型。与我们需求2的要求这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)相对应。\n* 第4行: normalizeTokens(tokens)方法，与我们需求3每一个词汇元素必须标准化相对应。\n* 第5-8行： 则用:isALargeTransaction方法进行交易类型的判断。并分别用processLargeTransaction与processSmallTransaction两个处理函数来对不同交易类型进行处理。同时，返回值也满足需求5对返回值类型的要求。\n\n同时，采用意图导向编程，对于不同的编程语言也是同构的，以下列出几种常用编程语言的实现。\n\n```c++\n//c++ code\nbool commit(std::string command) {\n    std::vector<std::string> tokens = tokenize(command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        return processLargeTransaction(tokens);\n    } \n    return processSmallTransaction(tokens);\n}\n\n\n```\n对于python或javascript之类的语言，函数定义中有包含返回值类型的，则可以加入一个返回值变量以让代码意思更清晰易懂：\n\n```python\n#python code\ndef commit (command ):\n\tresult = true\n    tokens = tokenize(command)\n    normalizeTokens(tokens)\n    if isALargeTransaction(tokens):\n        result = processLargeTransaction(tokens)\n    else:\n    \tresult = processSmallTransaction(tokens)\n    \n    return result\n\n```\n\n```javascript\n//javascript code\ncommit(command){\n\tvar result = true;\n    tokens = tokenize(command);\n    normalizeTokens(tokens);\n    if (isALargeTransaction(tokens)){\n        result = processLargeTransaction(tokens);\n    }else{ \n    \tresult = processSmallTransaction(tokens);\n\t}\n\n    return result;\n}\n\n```\ncommit()方法是我们为这个对象定义的应用程序接口(API)。当然,它是公共方法,这样才能交给客户端对象,为它们提供服务。所有其他方法(tokenize()、isALarge-Transaction()、processLargeTransaction()和processSma11Transaction())都不属于这个对象API的一部分,而仅仅是实现过程中的功能性步骤。因此,它们常常称为\"辅助方法\"(helper methods)。现在,我们先把它们当做私有方法(稍后我们会发现,这样做并不总是完全正确的)。重点是,它们是这个服务内部实现的一部分,而不是外界需要调用的接口。\n\n并且,它们现在还没有真正存在。如果现在尝试编译一下代码,编译器肯定会报告它们并不存在(不过……我们将试这样能,让编译器帮助我们列出后续工作的待办事项清单。 为了代码编译通过,接下来我们必须要创建它们。\n\n用这样的编码方式,我们可以把精力集中在如何分解最终目标,以及那些全局性的问题上。例如,我们必须考虑在实现语言中,用到的这个string数组是引用传递还是复制传递(很明显,我们猜想该语言是引用传递的；否则,我们就得把tokens作为nozmalizeTokens()函数的返回值保留下来)。至于其他单个步骤的实现细节,我们这里先不考虑。\n\n这样做的意义是什么呢?我们很快会了解到,它有很多好处。但在此之前,让我们先确认一件很重要的事:这样做其实一点都不难。你的时间表里没有因此而增加更多的工作,与直接把所有代码写到一个很长的方法里(就像我们以前写程序一样,一大堆逻辑结构代码)的工作量是基本差不多的。仅有的少许不同,是我们思考的方式以及编码的顺序。 \n\n这非常重要。理论上,好的实践应该是在任何时候都可以实行,并且能够推广到整个团队,成为那些可以一直贯彻执行的守则。事实上,只有当这些实践的执行成本很低(或者说,几乎零成本)的时候,才有可能做到这点。 \n\n### 1.2优点\n\n还是老问题,用这样的方式编程意义何在呢? \n\n有时候,这样一个小小的问题所引出的答案会令你惊叹不已。我们先把这些优点汇总罗列出来,再——进行分析。 \n\n如果遵循意图导向编程的方式,那么代码将会: \n\n* 更加内聚(职责单一) \n* 更加可读和清晰。 \n* 更易于调试。 \n* 更易于重构和优化, 所以只做最少的设计,满足当前需要。\n* 更易于单元翻试。\n\n同时,从这些优点中还会延伸出其他优点:代码更易于修改和扩展。其他还有:\n* 模式更容易应用到代码中。 \n* 创建的方法可以容易地从一个类移动到另一个类。 \n* 代码更易于维护。 \n\n#### 1.2.1方法的内聚性 \n\n代码的质量标准之一,就是内聚性。它促使代码更易于理解、更易于扩展和修改。通常 情况下,我们希望软件实体(software entity)具备单一的特性,换句话说,一个实体只为了 ——个目的或原因而存在。 \n\n以类为例。一个类应该根据它的职责来定义,并且每个类通常应该只有一个职责。类的内部包含方法、状态以及与其他对象之间的关系,正是它们使得类的职责能够被正确地履行。在一个类的内部,如果各个方面都紧密相关,并且都在这个类的唯一职责范围之内,那么我们就说这个类的内聚性很强。 \n\n你也许会对前面的例子提出异议,我们的代码中有些部分的职责实际上是不同的,它们应该放到不同的类中。或许,把它们完全梳理清楚是一件挺棘手的事情。但是,即使无法做到完美无缺,如果遵循意图导向编程的方式,在绝大多数情况下,仍然可以达到一定程度上的内聚性。\n\n方法的内聚也是关于单一性的问题,不过关注点是在函数上。如果一个方法只实现整体职能中一个单独的功能点,我们就说这个方法的内聚性很强。人的思维方式是单线程的,当人们开始\"多任务\"的时候,他们实际上只是快速地在多个任务之间进行切换而已;我们仍旧习惯于一次只思考一件事情。意图导向编程正是利用这一事实,用我们思维链条单一性的特点去创建同样具备单一性的内聚方法。\n\n意图导向编程能带来诸多好处的一个很重要的原因,正是方法的内聚性。 \n\n#### 1.2.2 可读性和表达性\n\n让我们再回过头来看看最初的代码示例,观察一下它的可读性怎样。\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n\n    }\n}\n```\n\n代码基本上是这样\"讲\"的:\"我们获得一个指令,准备提交。先对指令进行分词,把 词汇元素标准化,然后根据得到的词汇元素集合的大小,决定采用大型事务的机制还是小型事务的机制进行处理。最后,返回处理结果。\" \n\n因为没有涉及每一步是\"如何做\",而仅仅是\"做什么\",所以只要快速地读一遍方法, 就可以很容易地了解到整体流程是如何工作的。有时候,我们需要的正是快速地了解事物在 如何运作。 \n\n这种方式提供了很好的可读性,表达也很清晰。值得注意的一点是,我们并没有在代码 中包含任何注释,但读者很容易了解到其中的意义。这是因为我们想通过注释表达的东西, 都已包含在方法的名称中。 \n\n当然,注释也是一种清晰的表达方法,但问题是,编译器看不到。同时,很多不相信注释准确性的程序员也会忽略它们。如果注释在代码中存在了很久,它就会变得不可靠,原因我们都很清楚:代码可能已经改变了,但注释或许并没有更新。如果过度相信注释,它可 能会误导我们,也没有其他简单的方法去验证是不是这样。我们只能被迫去调查代码,注释 的表达功能就这样蒸发掉了。因此,注释往往会被程序员忽略,失去它本来的作用。\n\n回到我们讨论的主题,在意图导向编程中,组织一个方法的时候应该包括所有的流程步骤,但很少或者完全不用涉及实际的步骤实现。在某种意义上,这是另外一种形式的内聚: 把处理某件事的流程和具体做事的实现方式区分开。 \n\n另一件促使代码更易读和清晰的事情是,当我们创建代码实体时,它们的名字应该能表达出创建的目的。如果方法是内聚的,用一两个词来完整描述它们是做什么的就变得很容易,而不用在名称中加入许多下划线、\"and\"和\"or\"。同时,在我们给方法命名的时候,它们还没有真正存在,这促使我们去选择能表达自己想法的名字。这种名字揭示了命名背后的意图,我们把它们叫做\"表露意图的名称\"(intention-revealing names)。有一些命名是我们应该尽量避免的,比如有些名字,当你明白功能是什么之后,它很容易理解;但在别人解释之前,又容易引起误解。\n\n#### 注释会成为代码的一种\"臭味\"\n\n虽然我们没有断言说,不应该写注释,但有些注释确实是代码的一种\"臭味\"。例如,假如我们写了这样的代码:\n```java\npublic class Transaction (\n\tpublic Boolean commit ( String command ) (\n\t\tBoolean result = true :\n\t\tcome hore\n\t\tbone coue liece\n\t\tSome more code here\n\n\t\tEven some more code here that sets tokens\n\t\tSome code here that normalizes Tokens\n\t\tSome more code here that normalizes\n\t\tsome more coue use cnat normalizes ' rokens\n\t\tEven more code here that normalizes Tokens\n\t\tCode that determines if you have a large transaction\n\t\tSet 1t = true if you do\n\t\t\n\t\tif ( 1t ){\n\t\t\tSome code here to process large transactions\n\t\t\tMore code here to process large transactions\n\t\t} else {\n\t\t\tSome code here to process small transactions\n\t\t\t有效期限\n\t\t\tMore code here to process small transactions\n\t\t}\n\t\treturn result ;\n\t}\n}\n```\n\n当看到这段代码时,你可能会说:\"天哪,我可不明白它在干什么;让我们加些注释吧。\"然后在上面加了些东西:\n```java\npublic class Transaction {\n\tpublic Boolean commit ( String command ) f\n\tBoolean result = true ;\n\t// tokenize the string\n\tSome code here\n\tSome more code here\n\tEven some more code here that sets tokens\n\n\n\n\t//normalise the tokens I am there that normalizes Tokens normalises Tokens \n\tsome cooe code here Some more c \n\tThe more code here that normalizes Tokens \n\tsee it you have a large transaction Code that determines \n\tif you have a large transaction Cet Ite true if you do \n\tif ( it ) {\n\t\tprocess large transaction It , \n\t\tto process large transactions 公民身份号码 \n\t\tSome Here code here to process large transactions \n\t) else ( \n\t\tprocess small transaction time code here to process small transactions es , \n\t\tcode here to process small transactions \n\t\treturn result ; \n\t}\n}\n\n\n```\n注意到了吗?当写完代码之后,我们加入注释来描述做了什么。如果遵循意图导向编辑 的方式,这些注释就不再需要。前面提到的替代注释的方法其实更有用,因为编译的时候 它们(代码本身)一定是最新的。 \n\n#### 1.2.3 调试 \n\n在Net Objectives公司的培训课程中,我们往往会问学员一个问题,他们是否花费了大量 的时间来修改代码中的错误。除了那些已经上过我们课程的人外,大部分人的答案都是\"是的\"。这也是让软件开发变得棘手的一个主要原因。\n\n我们向他们指出,在调试过程中,寻找系统中的错误所在才是最花时间的部分。一旦错误装定位,修复工作反而不是什么太大的问题。几乎所有的学员听到这点,都会立刻点点头。由此可见,在创建需要调试的代码时,真正的技巧是用一切手段让代码中的错误容易再现。当然,我们应该尽量小心,在开始写代码的时候就别犯错。但是,哪怕你做到了尽善尽美,往往还有别人要来改动这段代码。\n\n当遵循意图导向编程的时候,我们更容易做到让一个方法只做一件事。这时候,如果系统中有些部分不能正常工作了,试试下面的方法:\n\n* (1)通读一遍整个方法,看看所有事情是怎么运作的。 \n* (2)对无法正常工作的部分,检查一下辅助方法的细节有什么问题。 \n\n相对于费力地查阅一大段复杂的代码,尤其是有些代码还可能涉及许多不相关的系统的方方面面,这种调试方法发现代码借误的速度要快得多。 \n\n例如,调试遗留系统是个苦差事,因为问题往往是多种原因共同引起的。其中一个很大的因素是它的代码常常是一大段一大段写出来的。因此,你最后不得不把代码打印出来,准备好各种彩色荧光笔,根据代码是做什么的来进行逻辑分块。\"我会把数据库部分标为黄色, 业务逻辑标为蓝色......\",这样做既艰苦又容易出错,还很枯燥,对程序员来说,这可不是打发时间的好方式。还是让计算机来完成这些让人厌烦的工作吧。 \n\n#### 1.2.4 重构和增强\n\n在创建系统的最初阶段,我们很难准确地知道设计应该做到什么程度,复杂度又是多少。由于复杂度是引起系统难以修改的原因之一,所以,如果可以的话,我们希望做最少的设计,仅仅增加那些真正需要的东西,让系统正常运行。 \n\n尽管如此,当我们实际做的时候往往会犯下很多错误,真正需要的功能并没有正确运行。或者即使我们的系统终于正常工作了,来自客户、利益相关人员或者市场的需求又更改了规则。 基于这点,我们常常需要这样做: ·重构系统(保持系统行为不变的情况下,更改它的结构)。 \n\n增强系统(增加或修改系统的行为以符合新的需求)。\n\n重构通常认为是\"清理\"刚开始时写得糟糕的代码。有时候项目十万火急,我们没有认真顾及代码质量,草草维护和修改,代码就在这个过程中变得腐朽不堪。或者,当我们对整个程序有了更深的了解,清楚地知道代码需要重新设计时,也可以用到重构。 \n\n1999年,Martin Fowler写了一本经典的书籍《Refactoring》9,这本书记载了各种不同 的、在保持系统行为不变的情况下,如何修改代码的方法,并给每种方法命了名(通常叫做一次\"迁移\")。 \n\n在学习重构原则的时候,大多数人首先学到的一个迁移方法叫做提炼函数(Extract Method);把一部分代码从一个巨大的方法中抽取出来,放到一个属于它自己的新方法中。而在原来代码中的那个位置直接调用这个新方法。由于原来方法的一部分临时变量也需要迁称到新方法中,所以需要多个步骤才能完成一个函数的提炼。\n\n该书在讲述许多其他的重构迁移方法时,开始都有一句基本说明\"在开始这个方法之前,你需要不断地采用'提炼函数'方法,直到所有的方法都是内聚的。\"如果你遵循意图导向编程,你会发现你已经做到了这点。Ken Pugh在《Prefactoring)一书中也广泛地研究了像意图导向编程这样简单而有效的方式是如何更好地帮助我们编写程序的。\n\n如果你已经做到了书中所写的那样,在写代码时习惯性地先\"预构\"(prefactored),则进行代码重构的时候,困难就要少很多。代码的方法内聚性越强,重构就越容易。\n\n同样,意图导向编程能够让系统在以后增强时变得更加容易。让我们回到前面交易处理程序的例子。\n\n设想一下6个月后,这些代码已经成为产品,一个新的需求加入进来:由于与这个业务交易系统有交互的某些第三方程序的原因,我们必须对某些旧版本的词汇元素进行转换(需要转换的词汇元素可能有很多)以支持整个系统的运行。现在,命令字符串中可能包含领域语言不再兼容的词汇元素,为了处理这种情况,我们必须再\"更新\"一下所有词汇元素。\n\n在这种情况下,我们只需做出一个小小的修改。你大可拍着胸脯说:\"没问题。\"\n\n```java\n//java code\npublic class Transaction {\n    public Boolean commit (String command ) {\n        Boolean result = true ;\n        String[] tokens = tokenize ( command );\n        normalizeTokens( tokens );\n        updateTokens(tokens)\n        if (isALargeTransaction(tokens)){\n            result = processLargeTransaction (tokens);\n        } else {\n            result = processSmallTransaction (tokens);\n        }\n        return result ;\n\n    }\n}\n```\n接下来,就是写出updateTokens()方法,在这个过程中我们会发现,新代码对原新的其他部分造成破坏的可能性是非常小的。事实上,修改这段代码里的任何辅助方法,我们都可以信心十足地认为,我们仅仅改动了想要改变的部分。就像上面这样,内聚性让我们更容易进行封装。\n\n#### 1.2.5 单元测试 \n\n在意图导向编程中,如果一个对象尚未完成,我们不会去扩充它的外部接口;相反,要确保在代码实现之前就把接口定义清楚。事实上,我们希望遵照模式所推荐的关于设计的基本建议:使用服务的客户端,在设计时应当遵照的是它的接口定义,而不是服务中的具体实现。 \n\n所以,至少在刚开始的时候,最好能把这些\"辅助方法\"都隐藏起来,因为它们都不是服务对外提供的API。我们不希望将来某一天,外部其他对象与这些方法发生什么关联(无 论是运作流程上的关联,还是直接存在引用关系)。这样可以让我们做到,在问题的方案细节发生变化的时候,无须修改系统中其他用到该对象的地方。\n\n尽管如此,如果我们把所有的辅助方法都变成私有方法,又似乎不利于对象测试(参见 图1-1)。\n\n```puml\n@startuml\ntitle 图1-1 意图导向编程 私有方法 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean isAlargeTranscation(String)\n\t  -Boolean processLargeTransaction(String)\n\t  -Boolean processSmallTransaction(String) \n}\n\nTransaction <|-down- TranscationTest:测试\n\n\n\n\n@enduml\n```\n\n\n\n私有方法无法被单元测试调用,因此我们只能针对commit()方法来写测试,这意味着必须在一个单独的测试用例中测试对象的整体行为。这样的测试可能比你想象的要复杂得多,同时,在编写测试的过程中,有多种因素都有可能导致测试失败。我们可不想发生这些的情况。\n\n也许我们可以解决这个难题。但不管怎样,把系统整体行为的各个不同方面区分开来。放到独立的方法中,至少在理论上让每个方法具备了可测试性,因为它们彼此之间不再耦合。就像使用这个类的客户端只与这个类的接口发生关联一样,在类的内部,AP1方法的实现只与辅助方法的接口发生关联。 \n\n那么,我们怎样来处理私有方法不能测试的问题呢?一般来说,有三个可行的方法:\n\n* 不用一个个地单独测试它们,只通过commit()方法来测试。在单元测试中,被测试的是行为而不是实现,所以如果这些辅助方法只是单个行为实现步骤的一部分,就没必要测试它们。我们希望在重构这些方法(甚至删除它们)之后,原来的测试仍! 旧能正确通过。\n\n* 在通常情况下,我们还是需要对它们进行单独的测试。尽管它们只是\"单个的步骤\",但我们知道它们会有弱点,在某些状况下可能会出错。从效率和安全性上考虑,应当把它们从整体流程中区分开来,进行单独测试。这种情况下,我们需要用些小聪明,加上一点儿测试技巧。这些技巧取决于开发语言本身,比如:把测试用例标注为被测试类的\"friend\"(在C++中),然后把私有方法包装进一个委托(delegate) 方法中,再测试这个委托方法。有时这也称为\"测试代理\"(testing proxy)(在.Net中),把方法变为\"protected\",在类的内部发起测试等。但要当心这些技巧过度使用;其他程序员可能无法理解你在做什么,尤其是当他们刚从一种语言平台转向另一种的时候,常常会晕头转向。同时,我们也不希望把测试与具体实现关联得大紧, 除非这么做是必要的。 \n\n* 事实上,有时候这些辅助方法理所应当单独测试,因为它们不仅仅是\"流程的单个 步骤\",而是完全不同的行为。或许它们在这个类中只是被用到,但在实现上讲,承 担完全独立的职责。测试这个类的同时也促使我们思考:\"它们真的只是一个步骤 吗?\"这也是设计时非常重要的一个方面。如果是这种情况,那么我们需要重新思考 当前的设计。例如,仔细想想,词汇元素标准化这一步就满足这种情况,应该单独测 试。这需要我们简单修改一下设计(参见图1-2)。\n\n\n```puml\n@startuml\ntitle 图1-2 设计改动 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean isAlargeTranscation(String)\n\t  -Boolean processLargeTransaction(String)\n\t  -Boolean processSmallTransaction(String) \n}\n\n\n\nclass TranscationTest{\n\t+testCommitATransaction()\n\n}\n\nclass TokenNormalizerTest{\n\t+testNormalize()\n}\n\nclass TokenNormalizer{\n\t+String normalize(String)\n}\n\nTransaction <|-down- TranscationTest:测试\n\nTokenNormalizer <|-right- Transaction\n\nTokenNormalizer <|-down- TokenNormalizerTest:测试\nnote right of Transaction : normalizeTokens(String){\\n    tokens = myNormalizer.normalize(tokens);\\n}\n\n@enduml\n```\n\n你或许注意到了,对TokenNormalizer的使用也是私有的。除了Transaction外,没其他地方用到TokenNormalizere,尽管如此,对TokenNormalizer的实现仍然是通过它自己定义的API,因此进行单独测试也变得可行了。 \n\n同时,你也会发现,由于一开始我们已经把词汇元素标准化这部分代码放在了独立的方法中,所以把它们抽取出来放到一个单独的类里就变得非常简单。如果方法一开始就是内聚 的,抽取一个新的类就变成一件轻而易举的事。因此,当我们需要时,就可以很快做出决 定,而不用考虑太多限制。 \n\n这样做的另一个原因是,系统中可能有其他实体也需要进行词汇元素标准化。如果这个 标准化的算法绑定在Transaction类的私有方法中,那么在类之外的其他环境里是无法使 用的。但如果它放在一个单独的类里,那么就可以调用它。因此,期望避免代码重复也会 促使我们做出同样的决定。 \n\n#### 1.2.6更易修改和扩展 \n\n就像前面看到的那样,意图导向编程使得代码质量得到提升,代码的修改和扩展也随之变得更加容易。经验告诉我们代码总会变化,只是我们现在并不清楚要修改什么地方,改成什么样子。意图导向编程帮助我们在几乎不花成本的情况下,创建更适合改动的代码。 \n\n#### 1.2.7在代码中发现模式\n\n在Net Objectives公司,我们提供了很多设计模式的相关培训;在各种学术会议中,模式地格是被反反复复地提到。当我们即将变成·模式先生\"的时候,总会有个家伙站出来说:\"模式是很酷,但我怎么知道在特定环境下到底该使用哪个好呢?\" \n\n这个问题的答案会引起一段很长却有趣(至少我们这么想)的对话,不过,如果遵循意 图导向编程,你就会发现模式有时就在你的代码实现当中。 \n\n让我们稍微改动一下前面的例子。 \n\n假如有两个完全不同的交易类型,它们的流程步骤一样(分词、标准化、更新、处理), 但每一步的实现方式不同。如果使用意图导向编程的方法来编码,尽管它们实现的\"辅助\" 方法不同,但是commit()方法看起来都差不多。这时候,你会发现模板方法模式(Template Method Pattern) O基本上已经站起来在向你挥手了(参见图1-3)。 \n\n```puml\n@startuml\ntitle 图1-3模板方法模式 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean processTransaction(String)\n}\n\nclass LargeTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n\n}\n\nclass SmallTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n}\n\n\n\nTransaction <|-down- LargeTranscation\n\nTransaction <|-down- SmallTranscation\n\n\n@enduml\n```\n\n\n更进一步,回到可测试性的问题。我们应该开始把这些行为抽取出来,让它们可以测试。在这个过程中,我们会发现这是使用策略模式的好机会。像上次一样,我们把词汇元素标准化这部分代码抽取出来(参见图1-4)。\n\n\n```puml\n@startuml\ntitle 图1-4模板方法和策略模式 \n\n\nclass Transaction{\n\t  +Boolean commit(String)\n\t  -String tokenize(String)\n\t  -normalizeTokens(String)\n\t  -updateTokens(String)\n\t  -Boolean processTransaction(String)\n}\n\nclass LargeTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n\n}\n\nclass SmallTranscation{\n\t-tokenize(String):String;\n\t-normalizeTokens(String);\n\t-updateTokens(String);\n\t-processTransaction(String):Boolean] \n}\n\nclass TokenNormalizer{\n\t+String normalize(String)\n}\n\nclass LargeTokenNormalizer{\n\t+String normalize(String)\n}\nclass SmallTokenNormalizer{\n\t+String normalize(String)\n}\n\n\n\nTransaction <|-down- LargeTranscation\n\nTransaction <|-down- SmallTranscation\n\n\nTokenNormalizer <|-left- Transaction\n\nTokenNormalizer <|-down- LargeTokenNormalizer\n\nTokenNormalizer <|-down- SmallTokenNormalizer\n\n@enduml\n```\n\n\n\n\n图1-4模板方法和策略模式\n\n#### 1.2.8 可迁移的方法\n\n前面我们提到,类的内聚性是这样一个概念,一个类在理想情况下,应该只有一个职责。它可以包含许多方法、成员变量以及与其他对象的关联关系来实现这一职责,但应当只有一个存在或需要修改的理由。\n\n意图导向编程通过一个简单的途径帮助我们创建内聚的方法:用自己的经验把功能进行分解。但是,这样做不会直接增强类的内聚性。实际上,很容易发现,在我们最开始编写Transaction类的代码的时候,它的内聚性并不强。\n\n要提高类的内聚性,一个办法是把这个类不应该有的方法全都迁移到其他类,或者新的类中,这样可以让这个类所关注的东西减少。因此,虽然意图导向编程没有直接实现类的内聚,但它让开发人员以后做起来更容易:内聚性问题出现的时候,就重构。\n\n为什么更容易?\n\n前面我们已经看到了其中一个原因。意图导向编程创建的方法只完成一个功能,这样避免了迁移方法时经常遇到的一个问题:方法中包含不能移走的部分。当一个方法只做一件事情的时候,如果它的一部分需要迁移,那么整个部分都应该移走。\n\n此外,还有另外一个原因。有时候,一个方法很难迁移,是由于它直接关联到了类中的状态变量(state member)。在迁移方法的过程中,我们也必须移动这些状态,或者找个办法让这些状态在方法迁移之后也能用得到。\n\n我们发现,当采用意图导向编程的方式编写代码的时候,我们更习惯于把需要用到的各种参数传递到方法中,再获取一个返回结果,而不是直接让方法使用对象的状态。如果没有与所在对象的内部状态发生关联,那么这些方法迁移起来就会更容易。 \n回到前面的例子,我们也许会这样做: \n\n```java\n\npublic class Transaction{private String[] tokens; \n\tpublic Boolean commit(string command){\n\t\tBoolean result = true；\n\t\ttokenizen();\n\t\tnormalizeTokens）\n\t\tif (isALargerransaction()){\n\t\t\tresult = processlargeTransaction(); \n\t\t} else{\n\t\t\tresult = processsmallTransaction();\n\t\t}\n\t\treturn result;\n\t}\n} \n\n```\n\n把tokens数组作为类的一个成员变量,原来把它用做参数的所有方法现在都可以简单 地直接引用它。意图导向编程无法强制你不这么干(它仅仅能够帮助我们避免把方法命名为ml()或go()之类),但它会让你的思路更自然地想到传递参数然后返回结果。根据我们了解到的情况,在使用意图导向编程的开发人员中,这样思考的人占绝大多数。 \n\n### 1.3小结 \n\n要让复杂的人类活动变得成熟和完善,一个至关重要的方面是发掘出那些有助于行动成 功的重要实践。在理想情况下,这些实践应该满足:\n\n* 带来很大价值。 \n* 做起来相对简单。 \n* 推广以及指导工作比较容易。 \n* 风险低。 \n* 通用(即使在不同的环境下,也不用犹豫是否要做)。 \n\n意图导向编程正是这样的一种实践。试试它吧!对绝大多数人而言,仅仅需要几个小时,就可以发现它简单、有趣,不用花费额外的精力就能写出更好的代码。\n\n\n","slug":"敏捷技能修炼笔记一","published":1,"updated":"2019-02-25T07:56:51.664Z","layout":"post","photos":[],"link":"","_id":"ck4w74u5i000oacelq6uwuk7p","content":"<h2 id=\"第一部分-最关键的小舵板\"><a href=\"#第一部分-最关键的小舵板\" class=\"headerlink\" title=\"第一部分 最关键的小舵板\"></a>第一部分 最关键的小舵板</h2><h3 id=\"第一章-意图导向编程\"><a href=\"#第一章-意图导向编程\" class=\"headerlink\" title=\"第一章 意图导向编程\"></a>第一章 意图导向编程</h3><h4 id=\"1-1-意图导向编程-一个实例\"><a href=\"#1-1-意图导向编程-一个实例\" class=\"headerlink\" title=\"1.1 意图导向编程:一个实例\"></a>1.1 意图导向编程:一个实例</h4><p>在这个实例中,需要写些代码。我们需要创建一个服务程序,它接受一个业务交易,然后提交。我们决定(不管是正确或错误)先简单创建一个对象,这个对象只包含一个公共方法来完成这件事。</p>\n<p>具体需求如下:</p>\n<ul>\n<li>1:交易信息开始于一串标准ASCII字符串。</li>\n<li>2:这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)。</li>\n<li>3:每一个词汇元素必须标准化(第一个字母大写,其余字母小写,空格和非字母数字的符号都要删掉)。</li>\n<li>4:包含超过150个词汇元素的交易,应该采用不同于小型交易的方式(不同的算法)来提交,以提高效率。</li>\n<li>5:如果提交成功,API方法应该返回”true”;失败,则应该返回”false”。</li>\n</ul>\n<p>这里并没有涉及某些细节(比如提交的算法具体是什么),这样就可以只关注我们感兴趣的实践。</p>\n<p>有一点是应该充分利用的:在学习一种程序语言编码的时候,我们会把问题分解为一系到的功能性步骤,在这个过程中,我们的思维不断地得到锻炼。随着代码写得越来越多,我们解决这类问题的能力也变得越来越强。</p>\n<p>继续考虑前面的那个问题,需求列出的每一点要求都代表一个功能性步骤。在写代码的过程中,我们会按照一定的顺序,有意识地去完成每一点要求。而意图导向编程是指,先假设当前这个对象中,已经有了一个理想方法,它可以准确无误地完成你想做的事情,而不是直接盯着每一点要求来编写代码。先问问自己:”假如这个理想的方法已经存在,它应该具有什么样的输入参数,返回什么值?还有,对我来说,什么样的名字最符合它的意义?”</p>\n<p>现在,因为这个方法并没有实际存在,所以除了你自己的最终意图之外,没有任何其他东西的约束(因此,你是”意图在主导编程”)。试试写出代码,像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中此例所用的代码被包装到类Transcation中，我觉得对于当前的情况，不需要引入类来干扰问题的说明，只需要关注于实现的方法即可，同时，由于java语言的声明中就包含了返回值类型，所以，可以改进如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"function\">Boolean <span class=\"title\">commit</span><span class=\"params\">(String command)</span> </span>&#123;</span><br><span class=\"line\">    String[] tokens = tokenize (command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> processSmallTransaction(tokens);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，</p>\n<ul>\n<li>第2行：commit方法中的参数类型String，与我们需求1的要求交易信息开始于一串标准ASCII字符串相对应。</li>\n<li>第3行：tokenize方法及其返回值类型。与我们需求2的要求这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)相对应。</li>\n<li>第4行: normalizeTokens(tokens)方法，与我们需求3每一个词汇元素必须标准化相对应。</li>\n<li>第5-8行： 则用:isALargeTransaction方法进行交易类型的判断。并分别用processLargeTransaction与processSmallTransaction两个处理函数来对不同交易类型进行处理。同时，返回值也满足需求5对返回值类型的要求。</li>\n</ul>\n<p>同时，采用意图导向编程，对于不同的编程语言也是同构的，以下列出几种常用编程语言的实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//c++ code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">commit</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; tokens = tokenize(command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> processSmallTransaction(tokens);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于python或javascript之类的语言，函数定义中有包含返回值类型的，则可以加入一个返回值变量以让代码意思更清晰易懂：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#python code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commit</span> <span class=\"params\">(command )</span>:</span></span><br><span class=\"line\">\tresult = true</span><br><span class=\"line\">    tokens = tokenize(command)</span><br><span class=\"line\">    normalizeTokens(tokens)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> isALargeTransaction(tokens):</span><br><span class=\"line\">        result = processLargeTransaction(tokens)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \tresult = processSmallTransaction(tokens)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//javascript code</span></span><br><span class=\"line\">commit(command)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    tokens = tokenize(command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        result = processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; </span><br><span class=\"line\">    \tresult = processSmallTransaction(tokens);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>commit()方法是我们为这个对象定义的应用程序接口(API)。当然,它是公共方法,这样才能交给客户端对象,为它们提供服务。所有其他方法(tokenize()、isALarge-Transaction()、processLargeTransaction()和processSma11Transaction())都不属于这个对象API的一部分,而仅仅是实现过程中的功能性步骤。因此,它们常常称为”辅助方法”(helper methods)。现在,我们先把它们当做私有方法(稍后我们会发现,这样做并不总是完全正确的)。重点是,它们是这个服务内部实现的一部分,而不是外界需要调用的接口。</p>\n<p>并且,它们现在还没有真正存在。如果现在尝试编译一下代码,编译器肯定会报告它们并不存在(不过……我们将试这样能,让编译器帮助我们列出后续工作的待办事项清单。 为了代码编译通过,接下来我们必须要创建它们。</p>\n<p>用这样的编码方式,我们可以把精力集中在如何分解最终目标,以及那些全局性的问题上。例如,我们必须考虑在实现语言中,用到的这个string数组是引用传递还是复制传递(很明显,我们猜想该语言是引用传递的；否则,我们就得把tokens作为nozmalizeTokens()函数的返回值保留下来)。至于其他单个步骤的实现细节,我们这里先不考虑。</p>\n<p>这样做的意义是什么呢?我们很快会了解到,它有很多好处。但在此之前,让我们先确认一件很重要的事:这样做其实一点都不难。你的时间表里没有因此而增加更多的工作,与直接把所有代码写到一个很长的方法里(就像我们以前写程序一样,一大堆逻辑结构代码)的工作量是基本差不多的。仅有的少许不同,是我们思考的方式以及编码的顺序。 </p>\n<p>这非常重要。理论上,好的实践应该是在任何时候都可以实行,并且能够推广到整个团队,成为那些可以一直贯彻执行的守则。事实上,只有当这些实践的执行成本很低(或者说,几乎零成本)的时候,才有可能做到这点。 </p>\n<h3 id=\"1-2优点\"><a href=\"#1-2优点\" class=\"headerlink\" title=\"1.2优点\"></a>1.2优点</h3><p>还是老问题,用这样的方式编程意义何在呢? </p>\n<p>有时候,这样一个小小的问题所引出的答案会令你惊叹不已。我们先把这些优点汇总罗列出来,再——进行分析。 </p>\n<p>如果遵循意图导向编程的方式,那么代码将会: </p>\n<ul>\n<li>更加内聚(职责单一) </li>\n<li>更加可读和清晰。 </li>\n<li>更易于调试。 </li>\n<li>更易于重构和优化, 所以只做最少的设计,满足当前需要。</li>\n<li>更易于单元翻试。</li>\n</ul>\n<p>同时,从这些优点中还会延伸出其他优点:代码更易于修改和扩展。其他还有:</p>\n<ul>\n<li>模式更容易应用到代码中。 </li>\n<li>创建的方法可以容易地从一个类移动到另一个类。 </li>\n<li>代码更易于维护。 </li>\n</ul>\n<h4 id=\"1-2-1方法的内聚性\"><a href=\"#1-2-1方法的内聚性\" class=\"headerlink\" title=\"1.2.1方法的内聚性\"></a>1.2.1方法的内聚性</h4><p>代码的质量标准之一,就是内聚性。它促使代码更易于理解、更易于扩展和修改。通常 情况下,我们希望软件实体(software entity)具备单一的特性,换句话说,一个实体只为了 ——个目的或原因而存在。 </p>\n<p>以类为例。一个类应该根据它的职责来定义,并且每个类通常应该只有一个职责。类的内部包含方法、状态以及与其他对象之间的关系,正是它们使得类的职责能够被正确地履行。在一个类的内部,如果各个方面都紧密相关,并且都在这个类的唯一职责范围之内,那么我们就说这个类的内聚性很强。 </p>\n<p>你也许会对前面的例子提出异议,我们的代码中有些部分的职责实际上是不同的,它们应该放到不同的类中。或许,把它们完全梳理清楚是一件挺棘手的事情。但是,即使无法做到完美无缺,如果遵循意图导向编程的方式,在绝大多数情况下,仍然可以达到一定程度上的内聚性。</p>\n<p>方法的内聚也是关于单一性的问题,不过关注点是在函数上。如果一个方法只实现整体职能中一个单独的功能点,我们就说这个方法的内聚性很强。人的思维方式是单线程的,当人们开始”多任务”的时候,他们实际上只是快速地在多个任务之间进行切换而已;我们仍旧习惯于一次只思考一件事情。意图导向编程正是利用这一事实,用我们思维链条单一性的特点去创建同样具备单一性的内聚方法。</p>\n<p>意图导向编程能带来诸多好处的一个很重要的原因,正是方法的内聚性。 </p>\n<h4 id=\"1-2-2-可读性和表达性\"><a href=\"#1-2-2-可读性和表达性\" class=\"headerlink\" title=\"1.2.2 可读性和表达性\"></a>1.2.2 可读性和表达性</h4><p>让我们再回过头来看看最初的代码示例,观察一下它的可读性怎样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码基本上是这样”讲”的:”我们获得一个指令,准备提交。先对指令进行分词,把 词汇元素标准化,然后根据得到的词汇元素集合的大小,决定采用大型事务的机制还是小型事务的机制进行处理。最后,返回处理结果。” </p>\n<p>因为没有涉及每一步是”如何做”,而仅仅是”做什么”,所以只要快速地读一遍方法, 就可以很容易地了解到整体流程是如何工作的。有时候,我们需要的正是快速地了解事物在 如何运作。 </p>\n<p>这种方式提供了很好的可读性,表达也很清晰。值得注意的一点是,我们并没有在代码 中包含任何注释,但读者很容易了解到其中的意义。这是因为我们想通过注释表达的东西, 都已包含在方法的名称中。 </p>\n<p>当然,注释也是一种清晰的表达方法,但问题是,编译器看不到。同时,很多不相信注释准确性的程序员也会忽略它们。如果注释在代码中存在了很久,它就会变得不可靠,原因我们都很清楚:代码可能已经改变了,但注释或许并没有更新。如果过度相信注释,它可 能会误导我们,也没有其他简单的方法去验证是不是这样。我们只能被迫去调查代码,注释 的表达功能就这样蒸发掉了。因此,注释往往会被程序员忽略,失去它本来的作用。</p>\n<p>回到我们讨论的主题,在意图导向编程中,组织一个方法的时候应该包括所有的流程步骤,但很少或者完全不用涉及实际的步骤实现。在某种意义上,这是另外一种形式的内聚: 把处理某件事的流程和具体做事的实现方式区分开。 </p>\n<p>另一件促使代码更易读和清晰的事情是,当我们创建代码实体时,它们的名字应该能表达出创建的目的。如果方法是内聚的,用一两个词来完整描述它们是做什么的就变得很容易,而不用在名称中加入许多下划线、”and”和”or”。同时,在我们给方法命名的时候,它们还没有真正存在,这促使我们去选择能表达自己想法的名字。这种名字揭示了命名背后的意图,我们把它们叫做”表露意图的名称”(intention-revealing names)。有一些命名是我们应该尽量避免的,比如有些名字,当你明白功能是什么之后,它很容易理解;但在别人解释之前,又容易引起误解。</p>\n<h4 id=\"注释会成为代码的一种”臭味”\"><a href=\"#注释会成为代码的一种”臭味”\" class=\"headerlink\" title=\"注释会成为代码的一种”臭味”\"></a>注释会成为代码的一种”臭味”</h4><p>虽然我们没有断言说,不应该写注释,但有些注释确实是代码的一种”臭味”。例如,假如我们写了这样的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">Transaction</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">public</span> Boolean commit ( String command )</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tBoolean result = <span class=\"keyword\">true</span> :</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tcome hore</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tbone coue liece</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome more code here</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tEven some more code here that sets tokens</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome code here that normalizes Tokens</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome more code here that normalizes</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tsome more coue use cnat normalizes <span class=\"string\">' rokens</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tEven more code here that normalizes Tokens</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tCode that determines if you have a large transaction</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tSet 1t = true if you do</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tif ( 1t )&#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tSome code here to process large transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tMore code here to process large transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125; else &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tSome code here to process small transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\t有效期限</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tMore code here to process small transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\treturn result ;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p>当看到这段代码时,你可能会说:”天哪,我可不明白它在干什么;让我们加些注释吧。”然后在上面加了些东西:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">( String command )</span> f</span></span><br><span class=\"line\"><span class=\"function\">\tBoolean result </span>= <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">\t<span class=\"comment\">// tokenize the string</span></span><br><span class=\"line\">\tSome code here</span><br><span class=\"line\">\tSome more code here</span><br><span class=\"line\">\tEven some more code here that sets tokens</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//normalise the tokens I am there that normalizes Tokens normalises Tokens </span></span><br><span class=\"line\">\tsome cooe code here Some more c </span><br><span class=\"line\">\tThe more code here that normalizes Tokens </span><br><span class=\"line\">\tsee it you have a large transaction Code that determines </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> you have a large transaction Cet Ite <span class=\"keyword\">true</span> <span class=\"keyword\">if</span> you <span class=\"keyword\">do</span> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( it ) &#123;</span><br><span class=\"line\">\t\tprocess large transaction It , </span><br><span class=\"line\">\t\tto process large transactions 公民身份号码 </span><br><span class=\"line\">\t\tSome Here code here to process large transactions </span><br><span class=\"line\">\t) <span class=\"keyword\">else</span> ( </span><br><span class=\"line\">\t\tprocess small transaction time code here to process small transactions es , </span><br><span class=\"line\">\t\tcode here to process small transactions </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result ; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意到了吗?当写完代码之后,我们加入注释来描述做了什么。如果遵循意图导向编辑 的方式,这些注释就不再需要。前面提到的替代注释的方法其实更有用,因为编译的时候 它们(代码本身)一定是最新的。 </p>\n<h4 id=\"1-2-3-调试\"><a href=\"#1-2-3-调试\" class=\"headerlink\" title=\"1.2.3 调试\"></a>1.2.3 调试</h4><p>在Net Objectives公司的培训课程中,我们往往会问学员一个问题,他们是否花费了大量 的时间来修改代码中的错误。除了那些已经上过我们课程的人外,大部分人的答案都是”是的”。这也是让软件开发变得棘手的一个主要原因。</p>\n<p>我们向他们指出,在调试过程中,寻找系统中的错误所在才是最花时间的部分。一旦错误装定位,修复工作反而不是什么太大的问题。几乎所有的学员听到这点,都会立刻点点头。由此可见,在创建需要调试的代码时,真正的技巧是用一切手段让代码中的错误容易再现。当然,我们应该尽量小心,在开始写代码的时候就别犯错。但是,哪怕你做到了尽善尽美,往往还有别人要来改动这段代码。</p>\n<p>当遵循意图导向编程的时候,我们更容易做到让一个方法只做一件事。这时候,如果系统中有些部分不能正常工作了,试试下面的方法:</p>\n<ul>\n<li>(1)通读一遍整个方法,看看所有事情是怎么运作的。 </li>\n<li>(2)对无法正常工作的部分,检查一下辅助方法的细节有什么问题。 </li>\n</ul>\n<p>相对于费力地查阅一大段复杂的代码,尤其是有些代码还可能涉及许多不相关的系统的方方面面,这种调试方法发现代码借误的速度要快得多。 </p>\n<p>例如,调试遗留系统是个苦差事,因为问题往往是多种原因共同引起的。其中一个很大的因素是它的代码常常是一大段一大段写出来的。因此,你最后不得不把代码打印出来,准备好各种彩色荧光笔,根据代码是做什么的来进行逻辑分块。”我会把数据库部分标为黄色, 业务逻辑标为蓝色……”,这样做既艰苦又容易出错,还很枯燥,对程序员来说,这可不是打发时间的好方式。还是让计算机来完成这些让人厌烦的工作吧。 </p>\n<h4 id=\"1-2-4-重构和增强\"><a href=\"#1-2-4-重构和增强\" class=\"headerlink\" title=\"1.2.4 重构和增强\"></a>1.2.4 重构和增强</h4><p>在创建系统的最初阶段,我们很难准确地知道设计应该做到什么程度,复杂度又是多少。由于复杂度是引起系统难以修改的原因之一,所以,如果可以的话,我们希望做最少的设计,仅仅增加那些真正需要的东西,让系统正常运行。 </p>\n<p>尽管如此,当我们实际做的时候往往会犯下很多错误,真正需要的功能并没有正确运行。或者即使我们的系统终于正常工作了,来自客户、利益相关人员或者市场的需求又更改了规则。 基于这点,我们常常需要这样做: ·重构系统(保持系统行为不变的情况下,更改它的结构)。 </p>\n<p>增强系统(增加或修改系统的行为以符合新的需求)。</p>\n<p>重构通常认为是”清理”刚开始时写得糟糕的代码。有时候项目十万火急,我们没有认真顾及代码质量,草草维护和修改,代码就在这个过程中变得腐朽不堪。或者,当我们对整个程序有了更深的了解,清楚地知道代码需要重新设计时,也可以用到重构。 </p>\n<p>1999年,Martin Fowler写了一本经典的书籍《Refactoring》9,这本书记载了各种不同 的、在保持系统行为不变的情况下,如何修改代码的方法,并给每种方法命了名(通常叫做一次”迁移”)。 </p>\n<p>在学习重构原则的时候,大多数人首先学到的一个迁移方法叫做提炼函数(Extract Method);把一部分代码从一个巨大的方法中抽取出来,放到一个属于它自己的新方法中。而在原来代码中的那个位置直接调用这个新方法。由于原来方法的一部分临时变量也需要迁称到新方法中,所以需要多个步骤才能完成一个函数的提炼。</p>\n<p>该书在讲述许多其他的重构迁移方法时,开始都有一句基本说明”在开始这个方法之前,你需要不断地采用’提炼函数’方法,直到所有的方法都是内聚的。”如果你遵循意图导向编程,你会发现你已经做到了这点。Ken Pugh在《Prefactoring)一书中也广泛地研究了像意图导向编程这样简单而有效的方式是如何更好地帮助我们编写程序的。</p>\n<p>如果你已经做到了书中所写的那样,在写代码时习惯性地先”预构”(prefactored),则进行代码重构的时候,困难就要少很多。代码的方法内聚性越强,重构就越容易。</p>\n<p>同样,意图导向编程能够让系统在以后增强时变得更加容易。让我们回到前面交易处理程序的例子。</p>\n<p>设想一下6个月后,这些代码已经成为产品,一个新的需求加入进来:由于与这个业务交易系统有交互的某些第三方程序的原因,我们必须对某些旧版本的词汇元素进行转换(需要转换的词汇元素可能有很多)以支持整个系统的运行。现在,命令字符串中可能包含领域语言不再兼容的词汇元素,为了处理这种情况,我们必须再”更新”一下所有词汇元素。</p>\n<p>在这种情况下,我们只需做出一个小小的修改。你大可拍着胸脯说:”没问题。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        updateTokens(tokens)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来,就是写出updateTokens()方法,在这个过程中我们会发现,新代码对原新的其他部分造成破坏的可能性是非常小的。事实上,修改这段代码里的任何辅助方法,我们都可以信心十足地认为,我们仅仅改动了想要改变的部分。就像上面这样,内聚性让我们更容易进行封装。</p>\n<h4 id=\"1-2-5-单元测试\"><a href=\"#1-2-5-单元测试\" class=\"headerlink\" title=\"1.2.5 单元测试\"></a>1.2.5 单元测试</h4><p>在意图导向编程中,如果一个对象尚未完成,我们不会去扩充它的外部接口;相反,要确保在代码实现之前就把接口定义清楚。事实上,我们希望遵照模式所推荐的关于设计的基本建议:使用服务的客户端,在设计时应当遵照的是它的接口定义,而不是服务中的具体实现。 </p>\n<p>所以,至少在刚开始的时候,最好能把这些”辅助方法”都隐藏起来,因为它们都不是服务对外提供的API。我们不希望将来某一天,外部其他对象与这些方法发生什么关联(无 论是运作流程上的关联,还是直接存在引用关系)。这样可以让我们做到,在问题的方案细节发生变化的时候,无须修改系统中其他用到该对象的地方。</p>\n<p>尽管如此,如果我们把所有的辅助方法都变成私有方法,又似乎不利于对象测试(参见 图1-1)。</p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIh9BCb9LNWwUv-Xhg72ivP-8Elf-ZrF9qnylcVQynNT2i-NDpwRq_bisivdcwSgS75n9USa5XShX1GbvXKd9fTavkTLSt4gA6WxvUVdf2RcAIJdv-PcbcW4bnHbvgLhWgHq8Mo5alpirBpCgbGKkRpyejp47A1e24Ys64Mkj20biGIR1Cokp6B7dCIYz5ImOv8JGOx1ggwWA3yvjRZO1wuMud1yQeE1hih1ebQ1gvQB2qbSmQP6DoM_F4zN0SaH8Qd59LRFjdQ_M3-L2mGSKlDIW44D0000\"></p>\n<p>私有方法无法被单元测试调用,因此我们只能针对commit()方法来写测试,这意味着必须在一个单独的测试用例中测试对象的整体行为。这样的测试可能比你想象的要复杂得多,同时,在编写测试的过程中,有多种因素都有可能导致测试失败。我们可不想发生这些的情况。</p>\n<p>也许我们可以解决这个难题。但不管怎样,把系统整体行为的各个不同方面区分开来。放到独立的方法中,至少在理论上让每个方法具备了可测试性,因为它们彼此之间不再耦合。就像使用这个类的客户端只与这个类的接口发生关联一样,在类的内部,AP1方法的实现只与辅助方法的接口发生关联。 </p>\n<p>那么,我们怎样来处理私有方法不能测试的问题呢?一般来说,有三个可行的方法:</p>\n<ul>\n<li><p>不用一个个地单独测试它们,只通过commit()方法来测试。在单元测试中,被测试的是行为而不是实现,所以如果这些辅助方法只是单个行为实现步骤的一部分,就没必要测试它们。我们希望在重构这些方法(甚至删除它们)之后,原来的测试仍! 旧能正确通过。</p>\n</li>\n<li><p>在通常情况下,我们还是需要对它们进行单独的测试。尽管它们只是”单个的步骤”,但我们知道它们会有弱点,在某些状况下可能会出错。从效率和安全性上考虑,应当把它们从整体流程中区分开来,进行单独测试。这种情况下,我们需要用些小聪明,加上一点儿测试技巧。这些技巧取决于开发语言本身,比如:把测试用例标注为被测试类的”friend”(在C++中),然后把私有方法包装进一个委托(delegate) 方法中,再测试这个委托方法。有时这也称为”测试代理”(testing proxy)(在.Net中),把方法变为”protected”,在类的内部发起测试等。但要当心这些技巧过度使用;其他程序员可能无法理解你在做什么,尤其是当他们刚从一种语言平台转向另一种的时候,常常会晕头转向。同时,我们也不希望把测试与具体实现关联得大紧, 除非这么做是必要的。 </p>\n</li>\n<li><p>事实上,有时候这些辅助方法理所应当单独测试,因为它们不仅仅是”流程的单个 步骤”,而是完全不同的行为。或许它们在这个类中只是被用到,但在实现上讲,承 担完全独立的职责。测试这个类的同时也促使我们思考:”它们真的只是一个步骤 吗?”这也是设计时非常重要的一个方面。如果是这种情况,那么我们需要重新思考 当前的设计。例如,仔细想想,词汇元素标准化这一步就满足这种情况,应该单独测 试。这需要我们简单修改一下设计(参见图1-2)。</p>\n</li>\n</ul>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/VLAzJiCm49xnKzn8L0K9nW9I2ojYQSOkLcA2XNEkxAiG55u0LfYOs9ZAnC3IjscLny3ENnD8yMBBty_TT_R84ZSqpnGZIKh0-crr61v1lbpbo_VDo_VwwGCOOx7Yra9aE5eUazIuO7i0WpEjbU08iSuoIViJCXBJm4DXUGRIDmBblUXWg4t6bRkDF6exs7oMSEe3wbhIZXKtgIYQYRblffStCpeMrbuqtBBn_xWJrvNguG9xPDqXb7KZOSaDOa1kFoz6C6wh0-PrbSe7kgnpcxQokNM2NNpFhIRQ3Az9uaIjid3o42Rw5iFVdGutNy_vvwiZTxszmCZqciBs0_VIAj-_MMflr2IWC0DzrRQ38UnuzSKKmQtYerWuXUnkQtsm3LlYmV4KNToHmCJzsHy0\"></p>\n<p>你或许注意到了,对TokenNormalizer的使用也是私有的。除了Transaction外,没其他地方用到TokenNormalizere,尽管如此,对TokenNormalizer的实现仍然是通过它自己定义的API,因此进行单独测试也变得可行了。 </p>\n<p>同时,你也会发现,由于一开始我们已经把词汇元素标准化这部分代码放在了独立的方法中,所以把它们抽取出来放到一个单独的类里就变得非常简单。如果方法一开始就是内聚 的,抽取一个新的类就变成一件轻而易举的事。因此,当我们需要时,就可以很快做出决 定,而不用考虑太多限制。 </p>\n<p>这样做的另一个原因是,系统中可能有其他实体也需要进行词汇元素标准化。如果这个 标准化的算法绑定在Transaction类的私有方法中,那么在类之外的其他环境里是无法使 用的。但如果它放在一个单独的类里,那么就可以调用它。因此,期望避免代码重复也会 促使我们做出同样的决定。 </p>\n<h4 id=\"1-2-6更易修改和扩展\"><a href=\"#1-2-6更易修改和扩展\" class=\"headerlink\" title=\"1.2.6更易修改和扩展\"></a>1.2.6更易修改和扩展</h4><p>就像前面看到的那样,意图导向编程使得代码质量得到提升,代码的修改和扩展也随之变得更加容易。经验告诉我们代码总会变化,只是我们现在并不清楚要修改什么地方,改成什么样子。意图导向编程帮助我们在几乎不花成本的情况下,创建更适合改动的代码。 </p>\n<h4 id=\"1-2-7在代码中发现模式\"><a href=\"#1-2-7在代码中发现模式\" class=\"headerlink\" title=\"1.2.7在代码中发现模式\"></a>1.2.7在代码中发现模式</h4><p>在Net Objectives公司,我们提供了很多设计模式的相关培训;在各种学术会议中,模式地格是被反反复复地提到。当我们即将变成·模式先生”的时候,总会有个家伙站出来说:”模式是很酷,但我怎么知道在特定环境下到底该使用哪个好呢?” </p>\n<p>这个问题的答案会引起一段很长却有趣(至少我们这么想)的对话,不过,如果遵循意 图导向编程,你就会发现模式有时就在你的代码实现当中。 </p>\n<p>让我们稍微改动一下前面的例子。 </p>\n<p>假如有两个完全不同的交易类型,它们的流程步骤一样(分词、标准化、更新、处理), 但每一步的实现方式不同。如果使用意图导向编程的方法来编码,尽管它们实现的”辅助” 方法不同,但是commit()方法看起来都差不多。这时候,你会发现模板方法模式(Template Method Pattern) O基本上已经站起来在向你挥手了(参见图1-3)。 </p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/nPAz2i8m4CTdynGP5SaWRkeWpcxjwd2aGO9f8ic9uCSpEEaY3cxkJeBeqxJFOUeNMjlPASVz_bn-ET9r21OdiI8eKGcQR2yDramF-tHtJJUdzBZsTN9UKK88L-0S3Ire1nobqNDIeRJUCqO9q9IRE9PO3T1AFQnbY3rgYcOaj9o9BwQDZK7vRfXHzyKcumYm2Bpk6bl3XNCVBk_OyYNQ1piKzmI7fotBcxGUPzkZ4fyC5Uba_NABrbDquFVs5WhyVFL_8Uz3o4U4TXOiCbFDVZPM4ik_mu_h2XtvJtG3\"></p>\n<p>更进一步,回到可测试性的问题。我们应该开始把这些行为抽取出来,让它们可以测试。在这个过程中,我们会发现这是使用策略模式的好机会。像上次一样,我们把词汇元素标准化这部分代码抽取出来(参见图1-4)。</p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIh9BCb9LNWwUv-Xhicp5GkVpTt_RDhEPvkdFftKytpjjETJbm85d-xfL-3YuahEIImkLWWfIimhJamkoSpFg-RYL53GTihFpqbDp5D8pi_DpIpH22ufoinBrmH9wKBO2YNvsQbvcLMfA79v-KMvYJb0qH2GR36AN6b1Ic89DWcONGL5-ScfnSL8Re4hguKvr2UnA3qLh28v4UfQNNINM45eQw0K3lU0fB0v1oIEsnLMK8V60iCDxg1WeFav0-yWk7l0-lrWjXG1dQCDZJ2urRX2bIIToBudpKekBYIlADZKwARab-VfOiGi3cNeuGqo3jL-aDgSrBGINUHKZLKLiiMeidYKO_Co5vT3QbuACES10000\"></p>\n<p>图1-4模板方法和策略模式</p>\n<h4 id=\"1-2-8-可迁移的方法\"><a href=\"#1-2-8-可迁移的方法\" class=\"headerlink\" title=\"1.2.8 可迁移的方法\"></a>1.2.8 可迁移的方法</h4><p>前面我们提到,类的内聚性是这样一个概念,一个类在理想情况下,应该只有一个职责。它可以包含许多方法、成员变量以及与其他对象的关联关系来实现这一职责,但应当只有一个存在或需要修改的理由。</p>\n<p>意图导向编程通过一个简单的途径帮助我们创建内聚的方法:用自己的经验把功能进行分解。但是,这样做不会直接增强类的内聚性。实际上,很容易发现,在我们最开始编写Transaction类的代码的时候,它的内聚性并不强。</p>\n<p>要提高类的内聚性,一个办法是把这个类不应该有的方法全都迁移到其他类,或者新的类中,这样可以让这个类所关注的东西减少。因此,虽然意图导向编程没有直接实现类的内聚,但它让开发人员以后做起来更容易:内聚性问题出现的时候,就重构。</p>\n<p>为什么更容易?</p>\n<p>前面我们已经看到了其中一个原因。意图导向编程创建的方法只完成一个功能,这样避免了迁移方法时经常遇到的一个问题:方法中包含不能移走的部分。当一个方法只做一件事情的时候,如果它的一部分需要迁移,那么整个部分都应该移走。</p>\n<p>此外,还有另外一个原因。有时候,一个方法很难迁移,是由于它直接关联到了类中的状态变量(state member)。在迁移方法的过程中,我们也必须移动这些状态,或者找个办法让这些状态在方法迁移之后也能用得到。</p>\n<p>我们发现,当采用意图导向编程的方式编写代码的时候,我们更习惯于把需要用到的各种参数传递到方法中,再获取一个返回结果,而不是直接让方法使用对象的状态。如果没有与所在对象的内部状态发生关联,那么这些方法迁移起来就会更容易。<br>回到前面的例子,我们也许会这样做: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span>&#123;<span class=\"keyword\">private</span> String[] tokens; </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span><span class=\"params\">(string command)</span></span>&#123;</span><br><span class=\"line\">\t\tBoolean result = <span class=\"keyword\">true</span>；</span><br><span class=\"line\">\t\ttokenizen();</span><br><span class=\"line\">\t\tnormalizeTokens）</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (isALargerransaction())&#123;</span><br><span class=\"line\">\t\t\tresult = processlargeTransaction(); </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tresult = processsmallTransaction();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把tokens数组作为类的一个成员变量,原来把它用做参数的所有方法现在都可以简单 地直接引用它。意图导向编程无法强制你不这么干(它仅仅能够帮助我们避免把方法命名为ml()或go()之类),但它会让你的思路更自然地想到传递参数然后返回结果。根据我们了解到的情况,在使用意图导向编程的开发人员中,这样思考的人占绝大多数。 </p>\n<h3 id=\"1-3小结\"><a href=\"#1-3小结\" class=\"headerlink\" title=\"1.3小结\"></a>1.3小结</h3><p>要让复杂的人类活动变得成熟和完善,一个至关重要的方面是发掘出那些有助于行动成 功的重要实践。在理想情况下,这些实践应该满足:</p>\n<ul>\n<li>带来很大价值。 </li>\n<li>做起来相对简单。 </li>\n<li>推广以及指导工作比较容易。 </li>\n<li>风险低。 </li>\n<li>通用(即使在不同的环境下,也不用犹豫是否要做)。 </li>\n</ul>\n<p>意图导向编程正是这样的一种实践。试试它吧!对绝大多数人而言,仅仅需要几个小时,就可以发现它简单、有趣,不用花费额外的精力就能写出更好的代码。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"第一部分-最关键的小舵板\"><a href=\"#第一部分-最关键的小舵板\" class=\"headerlink\" title=\"第一部分 最关键的小舵板\"></a>第一部分 最关键的小舵板</h2><h3 id=\"第一章-意图导向编程\"><a href=\"#第一章-意图导向编程\" class=\"headerlink\" title=\"第一章 意图导向编程\"></a>第一章 意图导向编程</h3><h4 id=\"1-1-意图导向编程-一个实例\"><a href=\"#1-1-意图导向编程-一个实例\" class=\"headerlink\" title=\"1.1 意图导向编程:一个实例\"></a>1.1 意图导向编程:一个实例</h4><p>在这个实例中,需要写些代码。我们需要创建一个服务程序,它接受一个业务交易,然后提交。我们决定(不管是正确或错误)先简单创建一个对象,这个对象只包含一个公共方法来完成这件事。</p>\n<p>具体需求如下:</p>\n<ul>\n<li>1:交易信息开始于一串标准ASCII字符串。</li>\n<li>2:这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)。</li>\n<li>3:每一个词汇元素必须标准化(第一个字母大写,其余字母小写,空格和非字母数字的符号都要删掉)。</li>\n<li>4:包含超过150个词汇元素的交易,应该采用不同于小型交易的方式(不同的算法)来提交,以提高效率。</li>\n<li>5:如果提交成功,API方法应该返回”true”;失败,则应该返回”false”。</li>\n</ul>\n<p>这里并没有涉及某些细节(比如提交的算法具体是什么),这样就可以只关注我们感兴趣的实践。</p>\n<p>有一点是应该充分利用的:在学习一种程序语言编码的时候,我们会把问题分解为一系到的功能性步骤,在这个过程中,我们的思维不断地得到锻炼。随着代码写得越来越多,我们解决这类问题的能力也变得越来越强。</p>\n<p>继续考虑前面的那个问题,需求列出的每一点要求都代表一个功能性步骤。在写代码的过程中,我们会按照一定的顺序,有意识地去完成每一点要求。而意图导向编程是指,先假设当前这个对象中,已经有了一个理想方法,它可以准确无误地完成你想做的事情,而不是直接盯着每一点要求来编写代码。先问问自己:”假如这个理想的方法已经存在,它应该具有什么样的输入参数,返回什么值?还有,对我来说,什么样的名字最符合它的意义?”</p>\n<p>现在,因为这个方法并没有实际存在,所以除了你自己的最终意图之外,没有任何其他东西的约束(因此,你是”意图在主导编程”)。试试写出代码,像下面这样:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>书中此例所用的代码被包装到类Transcation中，我觉得对于当前的情况，不需要引入类来干扰问题的说明，只需要关注于实现的方法即可，同时，由于java语言的声明中就包含了返回值类型，所以，可以改进如下：<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"function\">Boolean <span class=\"title\">commit</span><span class=\"params\">(String command)</span> </span>&#123;</span><br><span class=\"line\">    String[] tokens = tokenize (command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> processSmallTransaction(tokens);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>可以看到，</p>\n<ul>\n<li>第2行：commit方法中的参数类型String，与我们需求1的要求交易信息开始于一串标准ASCII字符串相对应。</li>\n<li>第3行：tokenize方法及其返回值类型。与我们需求2的要求这个信息字符申必须转换成一个字符串的数组,数组存放的值是此次交易用到的领域语言(domain language)中所包含的词汇元素(token)相对应。</li>\n<li>第4行: normalizeTokens(tokens)方法，与我们需求3每一个词汇元素必须标准化相对应。</li>\n<li>第5-8行： 则用:isALargeTransaction方法进行交易类型的判断。并分别用processLargeTransaction与processSmallTransaction两个处理函数来对不同交易类型进行处理。同时，返回值也满足需求5对返回值类型的要求。</li>\n</ul>\n<p>同时，采用意图导向编程，对于不同的编程语言也是同构的，以下列出几种常用编程语言的实现。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//c++ code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">commit</span><span class=\"params\">(<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span> command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">std</span>::<span class=\"built_in\">vector</span>&lt;<span class=\"built_in\">std</span>::<span class=\"built_in\">string</span>&gt; tokens = tokenize(command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">return</span> processSmallTransaction(tokens);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>对于python或javascript之类的语言，函数定义中有包含返回值类型的，则可以加入一个返回值变量以让代码意思更清晰易懂：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#python code</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">commit</span> <span class=\"params\">(command )</span>:</span></span><br><span class=\"line\">\tresult = true</span><br><span class=\"line\">    tokens = tokenize(command)</span><br><span class=\"line\">    normalizeTokens(tokens)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> isALargeTransaction(tokens):</span><br><span class=\"line\">        result = processLargeTransaction(tokens)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">    \tresult = processSmallTransaction(tokens)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"keyword\">return</span> result</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//javascript code</span></span><br><span class=\"line\">commit(command)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> result = <span class=\"literal\">true</span>;</span><br><span class=\"line\">    tokens = tokenize(command);</span><br><span class=\"line\">    normalizeTokens(tokens);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">        result = processLargeTransaction(tokens);</span><br><span class=\"line\">    &#125;<span class=\"keyword\">else</span>&#123; </span><br><span class=\"line\">    \tresult = processSmallTransaction(tokens);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>commit()方法是我们为这个对象定义的应用程序接口(API)。当然,它是公共方法,这样才能交给客户端对象,为它们提供服务。所有其他方法(tokenize()、isALarge-Transaction()、processLargeTransaction()和processSma11Transaction())都不属于这个对象API的一部分,而仅仅是实现过程中的功能性步骤。因此,它们常常称为”辅助方法”(helper methods)。现在,我们先把它们当做私有方法(稍后我们会发现,这样做并不总是完全正确的)。重点是,它们是这个服务内部实现的一部分,而不是外界需要调用的接口。</p>\n<p>并且,它们现在还没有真正存在。如果现在尝试编译一下代码,编译器肯定会报告它们并不存在(不过……我们将试这样能,让编译器帮助我们列出后续工作的待办事项清单。 为了代码编译通过,接下来我们必须要创建它们。</p>\n<p>用这样的编码方式,我们可以把精力集中在如何分解最终目标,以及那些全局性的问题上。例如,我们必须考虑在实现语言中,用到的这个string数组是引用传递还是复制传递(很明显,我们猜想该语言是引用传递的；否则,我们就得把tokens作为nozmalizeTokens()函数的返回值保留下来)。至于其他单个步骤的实现细节,我们这里先不考虑。</p>\n<p>这样做的意义是什么呢?我们很快会了解到,它有很多好处。但在此之前,让我们先确认一件很重要的事:这样做其实一点都不难。你的时间表里没有因此而增加更多的工作,与直接把所有代码写到一个很长的方法里(就像我们以前写程序一样,一大堆逻辑结构代码)的工作量是基本差不多的。仅有的少许不同,是我们思考的方式以及编码的顺序。 </p>\n<p>这非常重要。理论上,好的实践应该是在任何时候都可以实行,并且能够推广到整个团队,成为那些可以一直贯彻执行的守则。事实上,只有当这些实践的执行成本很低(或者说,几乎零成本)的时候,才有可能做到这点。 </p>\n<h3 id=\"1-2优点\"><a href=\"#1-2优点\" class=\"headerlink\" title=\"1.2优点\"></a>1.2优点</h3><p>还是老问题,用这样的方式编程意义何在呢? </p>\n<p>有时候,这样一个小小的问题所引出的答案会令你惊叹不已。我们先把这些优点汇总罗列出来,再——进行分析。 </p>\n<p>如果遵循意图导向编程的方式,那么代码将会: </p>\n<ul>\n<li>更加内聚(职责单一) </li>\n<li>更加可读和清晰。 </li>\n<li>更易于调试。 </li>\n<li>更易于重构和优化, 所以只做最少的设计,满足当前需要。</li>\n<li>更易于单元翻试。</li>\n</ul>\n<p>同时,从这些优点中还会延伸出其他优点:代码更易于修改和扩展。其他还有:</p>\n<ul>\n<li>模式更容易应用到代码中。 </li>\n<li>创建的方法可以容易地从一个类移动到另一个类。 </li>\n<li>代码更易于维护。 </li>\n</ul>\n<h4 id=\"1-2-1方法的内聚性\"><a href=\"#1-2-1方法的内聚性\" class=\"headerlink\" title=\"1.2.1方法的内聚性\"></a>1.2.1方法的内聚性</h4><p>代码的质量标准之一,就是内聚性。它促使代码更易于理解、更易于扩展和修改。通常 情况下,我们希望软件实体(software entity)具备单一的特性,换句话说,一个实体只为了 ——个目的或原因而存在。 </p>\n<p>以类为例。一个类应该根据它的职责来定义,并且每个类通常应该只有一个职责。类的内部包含方法、状态以及与其他对象之间的关系,正是它们使得类的职责能够被正确地履行。在一个类的内部,如果各个方面都紧密相关,并且都在这个类的唯一职责范围之内,那么我们就说这个类的内聚性很强。 </p>\n<p>你也许会对前面的例子提出异议,我们的代码中有些部分的职责实际上是不同的,它们应该放到不同的类中。或许,把它们完全梳理清楚是一件挺棘手的事情。但是,即使无法做到完美无缺,如果遵循意图导向编程的方式,在绝大多数情况下,仍然可以达到一定程度上的内聚性。</p>\n<p>方法的内聚也是关于单一性的问题,不过关注点是在函数上。如果一个方法只实现整体职能中一个单独的功能点,我们就说这个方法的内聚性很强。人的思维方式是单线程的,当人们开始”多任务”的时候,他们实际上只是快速地在多个任务之间进行切换而已;我们仍旧习惯于一次只思考一件事情。意图导向编程正是利用这一事实,用我们思维链条单一性的特点去创建同样具备单一性的内聚方法。</p>\n<p>意图导向编程能带来诸多好处的一个很重要的原因,正是方法的内聚性。 </p>\n<h4 id=\"1-2-2-可读性和表达性\"><a href=\"#1-2-2-可读性和表达性\" class=\"headerlink\" title=\"1.2.2 可读性和表达性\"></a>1.2.2 可读性和表达性</h4><p>让我们再回过头来看看最初的代码示例,观察一下它的可读性怎样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>代码基本上是这样”讲”的:”我们获得一个指令,准备提交。先对指令进行分词,把 词汇元素标准化,然后根据得到的词汇元素集合的大小,决定采用大型事务的机制还是小型事务的机制进行处理。最后,返回处理结果。” </p>\n<p>因为没有涉及每一步是”如何做”,而仅仅是”做什么”,所以只要快速地读一遍方法, 就可以很容易地了解到整体流程是如何工作的。有时候,我们需要的正是快速地了解事物在 如何运作。 </p>\n<p>这种方式提供了很好的可读性,表达也很清晰。值得注意的一点是,我们并没有在代码 中包含任何注释,但读者很容易了解到其中的意义。这是因为我们想通过注释表达的东西, 都已包含在方法的名称中。 </p>\n<p>当然,注释也是一种清晰的表达方法,但问题是,编译器看不到。同时,很多不相信注释准确性的程序员也会忽略它们。如果注释在代码中存在了很久,它就会变得不可靠,原因我们都很清楚:代码可能已经改变了,但注释或许并没有更新。如果过度相信注释,它可 能会误导我们,也没有其他简单的方法去验证是不是这样。我们只能被迫去调查代码,注释 的表达功能就这样蒸发掉了。因此,注释往往会被程序员忽略,失去它本来的作用。</p>\n<p>回到我们讨论的主题,在意图导向编程中,组织一个方法的时候应该包括所有的流程步骤,但很少或者完全不用涉及实际的步骤实现。在某种意义上,这是另外一种形式的内聚: 把处理某件事的流程和具体做事的实现方式区分开。 </p>\n<p>另一件促使代码更易读和清晰的事情是,当我们创建代码实体时,它们的名字应该能表达出创建的目的。如果方法是内聚的,用一两个词来完整描述它们是做什么的就变得很容易,而不用在名称中加入许多下划线、”and”和”or”。同时,在我们给方法命名的时候,它们还没有真正存在,这促使我们去选择能表达自己想法的名字。这种名字揭示了命名背后的意图,我们把它们叫做”表露意图的名称”(intention-revealing names)。有一些命名是我们应该尽量避免的,比如有些名字,当你明白功能是什么之后,它很容易理解;但在别人解释之前,又容易引起误解。</p>\n<h4 id=\"注释会成为代码的一种”臭味”\"><a href=\"#注释会成为代码的一种”臭味”\" class=\"headerlink\" title=\"注释会成为代码的一种”臭味”\"></a>注释会成为代码的一种”臭味”</h4><p>虽然我们没有断言说,不应该写注释,但有些注释确实是代码的一种”臭味”。例如,假如我们写了这样的代码:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> class <span class=\"title\">Transaction</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t<span class=\"keyword\">public</span> Boolean commit ( String command )</span> <span class=\"params\">(</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tBoolean result = <span class=\"keyword\">true</span> :</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tcome hore</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tbone coue liece</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome more code here</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tEven some more code here that sets tokens</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome code here that normalizes Tokens</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tSome more code here that normalizes</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">\t\tsome more coue use cnat normalizes <span class=\"string\">' rokens</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tEven more code here that normalizes Tokens</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tCode that determines if you have a large transaction</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tSet 1t = true if you do</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\tif ( 1t )&#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tSome code here to process large transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tMore code here to process large transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125; else &#123;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tSome code here to process small transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\t有效期限</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t\tMore code here to process small transactions</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t\treturn result ;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">\t&#125;</span></span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\"><span class=\"string\">&#125;</span></span></span></span><br></pre></td></tr></table></figure></p>\n<p>当看到这段代码时,你可能会说:”天哪,我可不明白它在干什么;让我们加些注释吧。”然后在上面加了些东西:<br><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">( String command )</span> f</span></span><br><span class=\"line\"><span class=\"function\">\tBoolean result </span>= <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">\t<span class=\"comment\">// tokenize the string</span></span><br><span class=\"line\">\tSome code here</span><br><span class=\"line\">\tSome more code here</span><br><span class=\"line\">\tEven some more code here that sets tokens</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"comment\">//normalise the tokens I am there that normalizes Tokens normalises Tokens </span></span><br><span class=\"line\">\tsome cooe code here Some more c </span><br><span class=\"line\">\tThe more code here that normalizes Tokens </span><br><span class=\"line\">\tsee it you have a large transaction Code that determines </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> you have a large transaction Cet Ite <span class=\"keyword\">true</span> <span class=\"keyword\">if</span> you <span class=\"keyword\">do</span> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ( it ) &#123;</span><br><span class=\"line\">\t\tprocess large transaction It , </span><br><span class=\"line\">\t\tto process large transactions 公民身份号码 </span><br><span class=\"line\">\t\tSome Here code here to process large transactions </span><br><span class=\"line\">\t) <span class=\"keyword\">else</span> ( </span><br><span class=\"line\">\t\tprocess small transaction time code here to process small transactions es , </span><br><span class=\"line\">\t\tcode here to process small transactions </span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result ; </span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意到了吗?当写完代码之后,我们加入注释来描述做了什么。如果遵循意图导向编辑 的方式,这些注释就不再需要。前面提到的替代注释的方法其实更有用,因为编译的时候 它们(代码本身)一定是最新的。 </p>\n<h4 id=\"1-2-3-调试\"><a href=\"#1-2-3-调试\" class=\"headerlink\" title=\"1.2.3 调试\"></a>1.2.3 调试</h4><p>在Net Objectives公司的培训课程中,我们往往会问学员一个问题,他们是否花费了大量 的时间来修改代码中的错误。除了那些已经上过我们课程的人外,大部分人的答案都是”是的”。这也是让软件开发变得棘手的一个主要原因。</p>\n<p>我们向他们指出,在调试过程中,寻找系统中的错误所在才是最花时间的部分。一旦错误装定位,修复工作反而不是什么太大的问题。几乎所有的学员听到这点,都会立刻点点头。由此可见,在创建需要调试的代码时,真正的技巧是用一切手段让代码中的错误容易再现。当然,我们应该尽量小心,在开始写代码的时候就别犯错。但是,哪怕你做到了尽善尽美,往往还有别人要来改动这段代码。</p>\n<p>当遵循意图导向编程的时候,我们更容易做到让一个方法只做一件事。这时候,如果系统中有些部分不能正常工作了,试试下面的方法:</p>\n<ul>\n<li>(1)通读一遍整个方法,看看所有事情是怎么运作的。 </li>\n<li>(2)对无法正常工作的部分,检查一下辅助方法的细节有什么问题。 </li>\n</ul>\n<p>相对于费力地查阅一大段复杂的代码,尤其是有些代码还可能涉及许多不相关的系统的方方面面,这种调试方法发现代码借误的速度要快得多。 </p>\n<p>例如,调试遗留系统是个苦差事,因为问题往往是多种原因共同引起的。其中一个很大的因素是它的代码常常是一大段一大段写出来的。因此,你最后不得不把代码打印出来,准备好各种彩色荧光笔,根据代码是做什么的来进行逻辑分块。”我会把数据库部分标为黄色, 业务逻辑标为蓝色……”,这样做既艰苦又容易出错,还很枯燥,对程序员来说,这可不是打发时间的好方式。还是让计算机来完成这些让人厌烦的工作吧。 </p>\n<h4 id=\"1-2-4-重构和增强\"><a href=\"#1-2-4-重构和增强\" class=\"headerlink\" title=\"1.2.4 重构和增强\"></a>1.2.4 重构和增强</h4><p>在创建系统的最初阶段,我们很难准确地知道设计应该做到什么程度,复杂度又是多少。由于复杂度是引起系统难以修改的原因之一,所以,如果可以的话,我们希望做最少的设计,仅仅增加那些真正需要的东西,让系统正常运行。 </p>\n<p>尽管如此,当我们实际做的时候往往会犯下很多错误,真正需要的功能并没有正确运行。或者即使我们的系统终于正常工作了,来自客户、利益相关人员或者市场的需求又更改了规则。 基于这点,我们常常需要这样做: ·重构系统(保持系统行为不变的情况下,更改它的结构)。 </p>\n<p>增强系统(增加或修改系统的行为以符合新的需求)。</p>\n<p>重构通常认为是”清理”刚开始时写得糟糕的代码。有时候项目十万火急,我们没有认真顾及代码质量,草草维护和修改,代码就在这个过程中变得腐朽不堪。或者,当我们对整个程序有了更深的了解,清楚地知道代码需要重新设计时,也可以用到重构。 </p>\n<p>1999年,Martin Fowler写了一本经典的书籍《Refactoring》9,这本书记载了各种不同 的、在保持系统行为不变的情况下,如何修改代码的方法,并给每种方法命了名(通常叫做一次”迁移”)。 </p>\n<p>在学习重构原则的时候,大多数人首先学到的一个迁移方法叫做提炼函数(Extract Method);把一部分代码从一个巨大的方法中抽取出来,放到一个属于它自己的新方法中。而在原来代码中的那个位置直接调用这个新方法。由于原来方法的一部分临时变量也需要迁称到新方法中,所以需要多个步骤才能完成一个函数的提炼。</p>\n<p>该书在讲述许多其他的重构迁移方法时,开始都有一句基本说明”在开始这个方法之前,你需要不断地采用’提炼函数’方法,直到所有的方法都是内聚的。”如果你遵循意图导向编程,你会发现你已经做到了这点。Ken Pugh在《Prefactoring)一书中也广泛地研究了像意图导向编程这样简单而有效的方式是如何更好地帮助我们编写程序的。</p>\n<p>如果你已经做到了书中所写的那样,在写代码时习惯性地先”预构”(prefactored),则进行代码重构的时候,困难就要少很多。代码的方法内聚性越强,重构就越容易。</p>\n<p>同样,意图导向编程能够让系统在以后增强时变得更加容易。让我们回到前面交易处理程序的例子。</p>\n<p>设想一下6个月后,这些代码已经成为产品,一个新的需求加入进来:由于与这个业务交易系统有交互的某些第三方程序的原因,我们必须对某些旧版本的词汇元素进行转换(需要转换的词汇元素可能有很多)以支持整个系统的运行。现在,命令字符串中可能包含领域语言不再兼容的词汇元素,为了处理这种情况,我们必须再”更新”一下所有词汇元素。</p>\n<p>在这种情况下,我们只需做出一个小小的修改。你大可拍着胸脯说:”没问题。”</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//java code</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span> <span class=\"params\">(String command )</span> </span>&#123;</span><br><span class=\"line\">        Boolean result = <span class=\"keyword\">true</span> ;</span><br><span class=\"line\">        String[] tokens = tokenize ( command );</span><br><span class=\"line\">        normalizeTokens( tokens );</span><br><span class=\"line\">        updateTokens(tokens)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (isALargeTransaction(tokens))&#123;</span><br><span class=\"line\">            result = processLargeTransaction (tokens);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            result = processSmallTransaction (tokens);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result ;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>接下来,就是写出updateTokens()方法,在这个过程中我们会发现,新代码对原新的其他部分造成破坏的可能性是非常小的。事实上,修改这段代码里的任何辅助方法,我们都可以信心十足地认为,我们仅仅改动了想要改变的部分。就像上面这样,内聚性让我们更容易进行封装。</p>\n<h4 id=\"1-2-5-单元测试\"><a href=\"#1-2-5-单元测试\" class=\"headerlink\" title=\"1.2.5 单元测试\"></a>1.2.5 单元测试</h4><p>在意图导向编程中,如果一个对象尚未完成,我们不会去扩充它的外部接口;相反,要确保在代码实现之前就把接口定义清楚。事实上,我们希望遵照模式所推荐的关于设计的基本建议:使用服务的客户端,在设计时应当遵照的是它的接口定义,而不是服务中的具体实现。 </p>\n<p>所以,至少在刚开始的时候,最好能把这些”辅助方法”都隐藏起来,因为它们都不是服务对外提供的API。我们不希望将来某一天,外部其他对象与这些方法发生什么关联(无 论是运作流程上的关联,还是直接存在引用关系)。这样可以让我们做到,在问题的方案细节发生变化的时候,无须修改系统中其他用到该对象的地方。</p>\n<p>尽管如此,如果我们把所有的辅助方法都变成私有方法,又似乎不利于对象测试(参见 图1-1)。</p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIh9BCb9LNWwUv-Xhg72ivP-8Elf-ZrF9qnylcVQynNT2i-NDpwRq_bisivdcwSgS75n9USa5XShX1GbvXKd9fTavkTLSt4gA6WxvUVdf2RcAIJdv-PcbcW4bnHbvgLhWgHq8Mo5alpirBpCgbGKkRpyejp47A1e24Ys64Mkj20biGIR1Cokp6B7dCIYz5ImOv8JGOx1ggwWA3yvjRZO1wuMud1yQeE1hih1ebQ1gvQB2qbSmQP6DoM_F4zN0SaH8Qd59LRFjdQ_M3-L2mGSKlDIW44D0000\"></p>\n<p>私有方法无法被单元测试调用,因此我们只能针对commit()方法来写测试,这意味着必须在一个单独的测试用例中测试对象的整体行为。这样的测试可能比你想象的要复杂得多,同时,在编写测试的过程中,有多种因素都有可能导致测试失败。我们可不想发生这些的情况。</p>\n<p>也许我们可以解决这个难题。但不管怎样,把系统整体行为的各个不同方面区分开来。放到独立的方法中,至少在理论上让每个方法具备了可测试性,因为它们彼此之间不再耦合。就像使用这个类的客户端只与这个类的接口发生关联一样,在类的内部,AP1方法的实现只与辅助方法的接口发生关联。 </p>\n<p>那么,我们怎样来处理私有方法不能测试的问题呢?一般来说,有三个可行的方法:</p>\n<ul>\n<li><p>不用一个个地单独测试它们,只通过commit()方法来测试。在单元测试中,被测试的是行为而不是实现,所以如果这些辅助方法只是单个行为实现步骤的一部分,就没必要测试它们。我们希望在重构这些方法(甚至删除它们)之后,原来的测试仍! 旧能正确通过。</p>\n</li>\n<li><p>在通常情况下,我们还是需要对它们进行单独的测试。尽管它们只是”单个的步骤”,但我们知道它们会有弱点,在某些状况下可能会出错。从效率和安全性上考虑,应当把它们从整体流程中区分开来,进行单独测试。这种情况下,我们需要用些小聪明,加上一点儿测试技巧。这些技巧取决于开发语言本身,比如:把测试用例标注为被测试类的”friend”(在C++中),然后把私有方法包装进一个委托(delegate) 方法中,再测试这个委托方法。有时这也称为”测试代理”(testing proxy)(在.Net中),把方法变为”protected”,在类的内部发起测试等。但要当心这些技巧过度使用;其他程序员可能无法理解你在做什么,尤其是当他们刚从一种语言平台转向另一种的时候,常常会晕头转向。同时,我们也不希望把测试与具体实现关联得大紧, 除非这么做是必要的。 </p>\n</li>\n<li><p>事实上,有时候这些辅助方法理所应当单独测试,因为它们不仅仅是”流程的单个 步骤”,而是完全不同的行为。或许它们在这个类中只是被用到,但在实现上讲,承 担完全独立的职责。测试这个类的同时也促使我们思考:”它们真的只是一个步骤 吗?”这也是设计时非常重要的一个方面。如果是这种情况,那么我们需要重新思考 当前的设计。例如,仔细想想,词汇元素标准化这一步就满足这种情况,应该单独测 试。这需要我们简单修改一下设计(参见图1-2)。</p>\n</li>\n</ul>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/VLAzJiCm49xnKzn8L0K9nW9I2ojYQSOkLcA2XNEkxAiG55u0LfYOs9ZAnC3IjscLny3ENnD8yMBBty_TT_R84ZSqpnGZIKh0-crr61v1lbpbo_VDo_VwwGCOOx7Yra9aE5eUazIuO7i0WpEjbU08iSuoIViJCXBJm4DXUGRIDmBblUXWg4t6bRkDF6exs7oMSEe3wbhIZXKtgIYQYRblffStCpeMrbuqtBBn_xWJrvNguG9xPDqXb7KZOSaDOa1kFoz6C6wh0-PrbSe7kgnpcxQokNM2NNpFhIRQ3Az9uaIjid3o42Rw5iFVdGutNy_vvwiZTxszmCZqciBs0_VIAj-_MMflr2IWC0DzrRQ38UnuzSKKmQtYerWuXUnkQtsm3LlYmV4KNToHmCJzsHy0\"></p>\n<p>你或许注意到了,对TokenNormalizer的使用也是私有的。除了Transaction外,没其他地方用到TokenNormalizere,尽管如此,对TokenNormalizer的实现仍然是通过它自己定义的API,因此进行单独测试也变得可行了。 </p>\n<p>同时,你也会发现,由于一开始我们已经把词汇元素标准化这部分代码放在了独立的方法中,所以把它们抽取出来放到一个单独的类里就变得非常简单。如果方法一开始就是内聚 的,抽取一个新的类就变成一件轻而易举的事。因此,当我们需要时,就可以很快做出决 定,而不用考虑太多限制。 </p>\n<p>这样做的另一个原因是,系统中可能有其他实体也需要进行词汇元素标准化。如果这个 标准化的算法绑定在Transaction类的私有方法中,那么在类之外的其他环境里是无法使 用的。但如果它放在一个单独的类里,那么就可以调用它。因此,期望避免代码重复也会 促使我们做出同样的决定。 </p>\n<h4 id=\"1-2-6更易修改和扩展\"><a href=\"#1-2-6更易修改和扩展\" class=\"headerlink\" title=\"1.2.6更易修改和扩展\"></a>1.2.6更易修改和扩展</h4><p>就像前面看到的那样,意图导向编程使得代码质量得到提升,代码的修改和扩展也随之变得更加容易。经验告诉我们代码总会变化,只是我们现在并不清楚要修改什么地方,改成什么样子。意图导向编程帮助我们在几乎不花成本的情况下,创建更适合改动的代码。 </p>\n<h4 id=\"1-2-7在代码中发现模式\"><a href=\"#1-2-7在代码中发现模式\" class=\"headerlink\" title=\"1.2.7在代码中发现模式\"></a>1.2.7在代码中发现模式</h4><p>在Net Objectives公司,我们提供了很多设计模式的相关培训;在各种学术会议中,模式地格是被反反复复地提到。当我们即将变成·模式先生”的时候,总会有个家伙站出来说:”模式是很酷,但我怎么知道在特定环境下到底该使用哪个好呢?” </p>\n<p>这个问题的答案会引起一段很长却有趣(至少我们这么想)的对话,不过,如果遵循意 图导向编程,你就会发现模式有时就在你的代码实现当中。 </p>\n<p>让我们稍微改动一下前面的例子。 </p>\n<p>假如有两个完全不同的交易类型,它们的流程步骤一样(分词、标准化、更新、处理), 但每一步的实现方式不同。如果使用意图导向编程的方法来编码,尽管它们实现的”辅助” 方法不同,但是commit()方法看起来都差不多。这时候,你会发现模板方法模式(Template Method Pattern) O基本上已经站起来在向你挥手了(参见图1-3)。 </p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/nPAz2i8m4CTdynGP5SaWRkeWpcxjwd2aGO9f8ic9uCSpEEaY3cxkJeBeqxJFOUeNMjlPASVz_bn-ET9r21OdiI8eKGcQR2yDramF-tHtJJUdzBZsTN9UKK88L-0S3Ire1nobqNDIeRJUCqO9q9IRE9PO3T1AFQnbY3rgYcOaj9o9BwQDZK7vRfXHzyKcumYm2Bpk6bl3XNCVBk_OyYNQ1piKzmI7fotBcxGUPzkZ4fyC5Uba_NABrbDquFVs5WhyVFL_8Uz3o4U4TXOiCbFDVZPM4ik_mu_h2XtvJtG3\"></p>\n<p>更进一步,回到可测试性的问题。我们应该开始把这些行为抽取出来,让它们可以测试。在这个过程中,我们会发现这是使用策略模式的好机会。像上次一样,我们把词汇元素标准化这部分代码抽取出来(参见图1-4)。</p>\n<p><img src=\"https://www.plantuml.com/plantuml/svg/SoWkIImgAStDuIh9BCb9LNWwUv-Xhicp5GkVpTt_RDhEPvkdFftKytpjjETJbm85d-xfL-3YuahEIImkLWWfIimhJamkoSpFg-RYL53GTihFpqbDp5D8pi_DpIpH22ufoinBrmH9wKBO2YNvsQbvcLMfA79v-KMvYJb0qH2GR36AN6b1Ic89DWcONGL5-ScfnSL8Re4hguKvr2UnA3qLh28v4UfQNNINM45eQw0K3lU0fB0v1oIEsnLMK8V60iCDxg1WeFav0-yWk7l0-lrWjXG1dQCDZJ2urRX2bIIToBudpKekBYIlADZKwARab-VfOiGi3cNeuGqo3jL-aDgSrBGINUHKZLKLiiMeidYKO_Co5vT3QbuACES10000\"></p>\n<p>图1-4模板方法和策略模式</p>\n<h4 id=\"1-2-8-可迁移的方法\"><a href=\"#1-2-8-可迁移的方法\" class=\"headerlink\" title=\"1.2.8 可迁移的方法\"></a>1.2.8 可迁移的方法</h4><p>前面我们提到,类的内聚性是这样一个概念,一个类在理想情况下,应该只有一个职责。它可以包含许多方法、成员变量以及与其他对象的关联关系来实现这一职责,但应当只有一个存在或需要修改的理由。</p>\n<p>意图导向编程通过一个简单的途径帮助我们创建内聚的方法:用自己的经验把功能进行分解。但是,这样做不会直接增强类的内聚性。实际上,很容易发现,在我们最开始编写Transaction类的代码的时候,它的内聚性并不强。</p>\n<p>要提高类的内聚性,一个办法是把这个类不应该有的方法全都迁移到其他类,或者新的类中,这样可以让这个类所关注的东西减少。因此,虽然意图导向编程没有直接实现类的内聚,但它让开发人员以后做起来更容易:内聚性问题出现的时候,就重构。</p>\n<p>为什么更容易?</p>\n<p>前面我们已经看到了其中一个原因。意图导向编程创建的方法只完成一个功能,这样避免了迁移方法时经常遇到的一个问题:方法中包含不能移走的部分。当一个方法只做一件事情的时候,如果它的一部分需要迁移,那么整个部分都应该移走。</p>\n<p>此外,还有另外一个原因。有时候,一个方法很难迁移,是由于它直接关联到了类中的状态变量(state member)。在迁移方法的过程中,我们也必须移动这些状态,或者找个办法让这些状态在方法迁移之后也能用得到。</p>\n<p>我们发现,当采用意图导向编程的方式编写代码的时候,我们更习惯于把需要用到的各种参数传递到方法中,再获取一个返回结果,而不是直接让方法使用对象的状态。如果没有与所在对象的内部状态发生关联,那么这些方法迁移起来就会更容易。<br>回到前面的例子,我们也许会这样做: </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Transaction</span></span>&#123;<span class=\"keyword\">private</span> String[] tokens; </span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">commit</span><span class=\"params\">(string command)</span></span>&#123;</span><br><span class=\"line\">\t\tBoolean result = <span class=\"keyword\">true</span>；</span><br><span class=\"line\">\t\ttokenizen();</span><br><span class=\"line\">\t\tnormalizeTokens）</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (isALargerransaction())&#123;</span><br><span class=\"line\">\t\t\tresult = processlargeTransaction(); </span><br><span class=\"line\">\t\t&#125; <span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\tresult = processsmallTransaction();</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> result;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>把tokens数组作为类的一个成员变量,原来把它用做参数的所有方法现在都可以简单 地直接引用它。意图导向编程无法强制你不这么干(它仅仅能够帮助我们避免把方法命名为ml()或go()之类),但它会让你的思路更自然地想到传递参数然后返回结果。根据我们了解到的情况,在使用意图导向编程的开发人员中,这样思考的人占绝大多数。 </p>\n<h3 id=\"1-3小结\"><a href=\"#1-3小结\" class=\"headerlink\" title=\"1.3小结\"></a>1.3小结</h3><p>要让复杂的人类活动变得成熟和完善,一个至关重要的方面是发掘出那些有助于行动成 功的重要实践。在理想情况下,这些实践应该满足:</p>\n<ul>\n<li>带来很大价值。 </li>\n<li>做起来相对简单。 </li>\n<li>推广以及指导工作比较容易。 </li>\n<li>风险低。 </li>\n<li>通用(即使在不同的环境下,也不用犹豫是否要做)。 </li>\n</ul>\n<p>意图导向编程正是这样的一种实践。试试它吧!对绝大多数人而言,仅仅需要几个小时,就可以发现它简单、有趣,不用花费额外的精力就能写出更好的代码。</p>\n"},{"title":"项目","abbrlink":51156,"date":"2016-12-09T01:24:44.000Z","_content":"\n\n### 项目\n\n刚开始学习如何编制Web应用的开发者的一个大错误是在对要创建的东西还没有一个清淅的认识时就开始进行。但这就像开车去一个新的目的地却没有地图。你可能会在正确的方向有一个小的进展,但你可能不会到达你需要去的地方。你不需要从一开始就知道一切,但你的确至少需要一个方向。\n\n记住这一点,我们要构建Leaderboard(排行榜)——Meteor开发团队设计的一个示例应用程序展示Meteor用很少的几行代码能做什么。\n这就是它看起来的样子:\n\nLeaderboard已经在官网上已经被更高级的例子取代了,但它会是我们的示例项目,主要有两个原因:\n首先,这个应用程序已经存在。我们可以玩,这意味着我们可以在我们编写单行代码前对我们试图创建的应用有一个好的认识。\n第二,应用程序很简单。这意味着我们不需要担心构建软件的概念(这通常是最困难的一部分)。相反,我们可以集中学习Meteor本身。\n\n要获得实际的时间和排行榜,请访问leaderboard2.meteor.com,点击,注意其核心特征:\n- 有玩家的列表。\n- 每个球员都有一个分数。\n- 球员得分排名。\n- 你可以选择玩家通过点击它们。\n- 你可以增加一个选择球员的得分。\n\n在后面的章节中我们将创建附加功能,但即使相对较短的列表也涉及许多Meteor的核心功能。\n\n\n### 创建一个项目\n\n创建我们的第一个Meteor应用程序,我们将需要创建我们的第一个项目,一个项目是一组自包含的文件表单应用程序的基础。您可以使用单词\n“project”和“application”互换使用,但在谈到被开发的应用时“project”会更合适。\n每个项目都是不同的,但是一般会包含:\n- HTML文件,创建接口。\n- CSS文件,指定样式的界面。\n- JavaScript文件,定义应用程序逻辑。\n- 文件夹,确保都是组织良好的。\n\n一个项目可以包含其他类型的文件,如图片和CoffeeScript文件,但在这本书中我们会尽可能保持简单,只展示我们需要的。\n\n在我们创建Leaderboard应用项目前,让我们创建一个文件夹来存储我们的Meteor项目。我们不是必须这样做,但为了保持的东西\n有条理，这是一个好主意。\n\n当然,我们可以选择“新建文件夹”选项从“文件”菜单,但这哪儿有乐趣?相反,输入以下命令行:\n\n\tmkdir Meteor\n\n然后点击“回车”键。\n\n\n使用mkdir命令创建一个文件夹。这mkdir命令代表“目录”,从这个名字你可能猜到,它允许我们做出一个目录。\n\n在这个实例中,我们创建一个名为“Meteor”的目录,但是您可以调用任何你想要的文件夹。的精确位置的文件夹就会出现将取决于你操作系统,但至少在Mac OS X上,将出现在“家”的文件夹目录\n默认情况下。(如果你找不到文件夹,创建简单的搜索你的电脑。)\n一旦准备好了目录,导航到它使用下面的命令:\n\n\tcd Meteor\n\ncd命令代表“改变目录”命令行相当于在图形界面中双击一个目录,按下“回车”键后,我们将在“Meteor”目录。\n\n导航到“Meteor”文件夹。\n\n然后在这个目录中创建一个Meteor项目,运行如下命令:\n\n\tmeteor create leaderboard\n\n这个命令有三个部分:\n- meteor部分定义这是一个meteor命令。\n- create部分澄清,我们想创建一个meteor项目。\n- leaderboard的部分是我们分配给项目的名称。\n\n运行此命令后,会出现一个“leaderboard”目录内的“meteor”文件夹,默认情况下,该文件夹将包含三个文件:\n\n- leaderboard.html\n- leaderboard.css\n- leaderboard.js\n\n它还包含一个隐藏文件夹.meteor,但如果您的操作系统从视图中隐藏了这个文件夹,这很好。我们不会碰它。\n\n在我们的项目的文件夹\n\n\n\n### 本地服务器\n\nWeb应用程序不像静态网站。我们不能只是打开leaderboard.html文件就奇迹的看到一个动态的Meteor的动态应用程序。事实上,如果我们在Chrome浏览器打开该文件,所有我们会看到的是一些静态文本:\n\n\n没有什么动态。\n\n\n要得到我们计划中的web应用程序,我们需要启动所谓的本地服务器。这是一个web服务器,在我们的本地机器上运行。它包含在Meteor中并允许\n我们:\n\n\t1.看到我们的JavaScript代码的处理结果。\n\t2.在我们的本地机器上运行一个数据库。\n\n\n如果你使用一个应用程序像MAMP部署PHP和MySQL,这将是熟悉,但如果这一切听起来可怕,不要害怕。在实践中,这很简单。\n通过命令行中,导航到“leaderboard”目录中:\n\n\tcd leaderboard\n\n然后输入以下命令:\n\n\tmeteor run\n\n这里,meteor的部分定义了这是一个meteor命令，run部分阐明了我们要采取的精确行动。在这种情况下,我们想要运行本地服务器。\n\n\n启动本地服务器。\n\n\n利用“回车”键后,将显示如下:\n\n\t=>Started proxy.\n\t=>Started MongoDB.\n\t=>Started youApp \n\t=>running at: http://localhost:3000/r app.\n\n\n\n\n这些线确认本地服务器启动和URL的最后一行- http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。\n\n\n导航到该URL在Chrome和注意,我们不再看到静态文本。相反,我们看到一个功能的web应用程序。应用程序本身是代码的结果这是包含在每个流星项目默认情况下,这并不是最有趣的创造在世界上,但是我们仍然在正确的方向上迈出了一步。\n\n\n\n这是默认的流星的应用程序。\n不断地查看代码的结果,我们需要保持本地服务器运行。这个简单的\n那就意味着要离开命令行打开从这一点开始。然而,您将需要打开\n一个单独的标签或窗口进一步写命令:\n一个单独的运行命令的选项卡。\n在本地服务器停止,要么退出命令行,或命令行焦点,\n项目22\n在你的键盘上按CTRL + C。然后再次启动本地服务器,使用相同的命令\n之前:\n流星跑\n只要确保你在一个项目的文件夹在运行命令之前。\n项目23\n默认应用程序\n默认应用程序没有什么特别的,但是如果我们点击“点击我”按钮,这个号码\n在屏幕上就会增加。这提供了一个相当普通的流星的实时演示\n特性。这个应用程序背后的代码,但是,不正是重要的因为我们将讨论\n在接下来的章节更大范围。\n目前,打开项目文件和删除所有的默认代码。甚至不看看\n代码。刚刚摆脱它。我们想要从一个完全空白。\n一旦完成,在JavaScript中输入以下文件:\n控制台。日志(“Hello world”);\n然后保存文件并打开JavaScript控制台在铬:\n1。单击视图菜单。\n2。悬停在开发人员选择。\n3所示。选择JavaScript控制台选项。\n窗格的底部将打开浏览器并显示“Hello world”我们的文本\n通过控制台。日志语句。\n“Hello World”的文本出现在JavaScript控制台。\n项目24\n如果这是熟悉的,很好。如果不是,那么知道控制台。日志语句用于看到输出结果\n不创建一个接口的代码显示输出。这意味着,在我们投资\n时间为创建一个接口,我们可以:\n1。确认我们的代码是按预期工作。\n2。尽快修复任何错误出现。\n我们还可以使用控制台操作应用程序的数据库,这是我们要做的\n下一章。\n离开控制台打开从这一点开始,但是随时删除控制台。日志语句\n在JavaScript文件。\n项目25\n总结\n在这一章,我们了解到:\n•当学习如何构建一个web应用程序,重要的是要有一个清晰的认识\n你想构建。\n•命令行可以用来迅速达到熟悉的任务,如创建文件夹和\n他们之间导航。\n•开发流星应用程序时,我们将它作为一个“项目”,我们可以创建一个\n项目与流星创建命令。\n•来查看我们的web应用程序在本地机器上,我们可以用流星运行命令\n启动一个本地web服务器。\n•当结合控制台。日志语句,JavaScript控制台是一个非常方便的工具\n流星发展。\n流星的更深层次的理解:\n•如果你还没有,玩耍与原排行榜的应用程序。它不\n有很多功能,但这只是意味着没有理由不是有很强的把握的\n它的功能。\n•关闭命令行应用程序,然后重新打开它,回到你在哪里。\n你应该能够浏览到您的项目的文件夹cd命令启动\n本地服务器与流星跑。\n•创建第二个流星项目和使用这个项目尝试当你学习\n一些新的东西。折腾了为了这是一个很好的方式钻细节\n深入你的大脑。\n在其当前状态查看代码,查看GitHub提交。\n\n\n数据库中,第1部分\n写一个技术书的一个困难的部分是决定何时引入某些想法。\n需要教的主题书之间是一致的,但你说的顺序\n他们可以大大影响读者理解某些内容的能力。\n例如,往往技术作者尽可能谈论创建一个接口\n尽快这是因为看到很有趣的视觉结果代码,和很高兴的感觉\n像你做出了很快的进步。\n但是这种方法并介绍一下几个问题:\n1。很难掌握任何有关前端(接口)当你没有\n熟悉后端(数据库,等等)。\n2。如果我们首先谈论的前端,我们将不得不回顾在下一章,所以任何\n快速进步的感觉将是短暂的。\n因此,我们将首先讨论我们的项目内创建和管理数据库。这\n不是一个“性感”的话题,但是如果我们花几分钟覆盖基础,我们将有一个强大的\n本书的其余部分的基础。\n26\n第1部分数据库,27岁\nMongoDB vs . SQL\n如果您已经构建了一些之前在网上,你可能接触到\n的数据库。也许你安装WordPress的副本,或使用phpMyAdmin,甚至建造\n一些软件语言像PHP。在这些情况下,您会接触到\n一个SQL数据库。\n默认情况下,每个流星项目有自己的数据库。没有安装或配置\n必需的。当你创建一个项目时,会自动创建一个数据库项目,和\n当本地服务器正在运行,那么数据库。然而,这个数据库并不是一个SQL\n数据库。相反,它是所谓的MongoDB数据库。\n如果你之前从未遇到MongoDB,你可能会有点担心,但不要害怕。蒙戈\n数据库和SQL数据库不同,但是作为初学者而言,差异\n很小。\n目前,你只需要知道两件事:\n首先,没有其他类型的数据库用于流星。如果你想使用一个SQL\n数据库,例如,它是不可能的。其他选项可以在未来,但是\n时间其实还不清楚。\n第二,蒙戈使用不同的词汇来描述熟知的概念。例如,我们不会\n使用“表”和“行”这样的词,但概念基本上是相同的。你可以看到\n这个表的差异:\nMongoDB vs . SQL\n会很难想起概念熟悉新单词,但是我将提供大量的提醒\n通过这本书我们进步。\n第1部分数据库,28\n创建一个集合\n排行榜的中央功能应用程序的列表的球员。没有球员的名单\n出现在界面,我们不能建立其他任何有价值的物品。因此这是一个好地方\n开始——从应用程序的“中间”,向外工作的细节。\n这里有两个问题需要考虑:\n•我们在哪里存储与每个玩家相关的数据?\n•我们如何显示这些数据从内部接口?\n我们将在下一章回答第二个问题,但第一个问题:“在哪里\n我们与每个球员关联存储数据吗?”\n滑稽的答案将是“数据库”,但更有用的答案”\n收集”,如前一节所示,相当于一个SQL表集合。\n为了说明的目的收集,想象我们正在创建自己的版本的WordPress\n流星。如果是这样的话,我们会创建一个集合的文章,为集合\n评论,和一组页面。我们会创建一个为每个类型的数据收集。自\n我们创建这个排行榜的应用程序,我们将创建一个集合的球员。\n要做到这一点,打开JavaScript文件,写如下声明:\n新的Mongo.Collection(球员);\n在这里,我们创建一个集合命名为“玩家”在我们项目的Mongo数据库。你可以\n名字收集任何你想要的,但它必须是唯一的。如果名字不是独一无二的,流星\n将返回一个错误。\n尽管这行代码,我们还没有供我们参考这个集合定义了一个方法,\n因此我们没有办法操作。\n为了解决这个问题,将集合在一个变量:\nPlayersList = new Mongo.Collection(球员);\n但请注意,我们没有使用var关键字,因为我们想要创建一个全球性的\n变量。这将允许我们引用和操作在我们所有的集合\n项目的文件。\n确认收集存在,保存文件,切换到Chrome浏览器,并输入的名称\n集合的变量为控制台:\nPlayersList\n第1部分数据库,29岁\n您应当会看到类似如下:\n集合的存在。\n这表明集合是按预期工作。\n如果返回一个错误,这可能是因为你的名字输入错误变量在控制台,\n或在代码中犯了一个语法错误。\n数据库中,第1部分30\n插入数据\n当我们想将数据插入一个集合,我们有四个选项。我们可以通过插入数据\nJavaScript控制台,通过命令行,通过JavaScript文件,并通过\n形式的界面。我们将看到如何使用所有这些选项在这本书,但第一\n选项-通过JavaScript控制台是最简单的,所以这是最好的起点。\n在控制台中,写如下:\nPlayersList.insert();\n这是我们使用的语法来操纵一个集合。\n我们开始分配给变量集合,然后——“PlayersList”变量\n附加功能。在本例中,我们使用插入函数,但是有一个范围的\n功能,如查找、更新和删除(和我们将讨论这些很快的细节)。\n但是,如果我们把“返回”键在这一点上,没有什么会发生,那是因为我们\n需要在函数的括号之间传递数据改变的内容\n集合。\n我们通过的数据需要以JSON格式,如果你不熟悉\nJSON格式,这就是它的样子:\n{\n名称:“大卫”,\n得分:0\n}\n在这里,有几个事情:\n首先,数据是用一对大括号。这就是我们如何区分我们的JSON数据\n剩下的代码。\n第二,我们已经定义了一对密钥。这些键被称为名字和分数,蒙戈\n术语,这些是我们收集的字段。因为每个球员将集合\n有一个名称和一个分数,名字和分数字段来保存这些值。\n第三,我们已经定义了与我们的键相关联的值。在这种情况下,价值的名字\n字段是“大卫”和分数字段的值是0。\n第四,键值用逗号隔开。这是因为JSON格式\n忽略空白,所以逗号是需要提供结构。\n我们可以通过这些数据通过括号,像这样:\n第1部分数据库,31日\nPlayersList.insert({\n名称:“大卫”,\n得分:0\n});\n这是一个完整的插入功能,如果我们这个语句输入到控制台和挖掘\n“返回”键,将会创建一个文档在“PlayersList”集合。文档是\n相当于SQL行和,在这一点上,我们要为每个玩家创建一个文档\n希望在我们的集合。如果我们希望我们的排行榜包含六名球员,我们需要使用\n六次插入函数,从而创建6个文档。\n插入数据。\n为了实现这一点,重复这句话几次,确保定义独特的值\n名称字段,所以我们可以区分球员:\nPlayersList.insert({\n名称:“鲍勃”,\n得分:0\n});\n由于忽略空白,语句可以写在一行:\nPlayersList。插入({ name:“鲍勃”,得分:0 });\n数据库中,第1部分32\n也请注意,创建每个文档后,会出现一个随机的数字和字母\n在控制台。这种混乱的局面是一个独特的ID MongoDB和自动创建的\n与每个文档相关联。它的主键,它会是重要的。\n目前,只注意到它的存在所以你不惊讶当我们讨论一遍。\n在我们继续之前,更多的玩家插入集合。示例应用程序\n六名球员,应该够了。\n球员们在我的名单是:\n•大卫\n•鲍勃\n•玛丽\n•比尔\n•沃伦\n•蒂姆\n他们都有得分字段设置为0。\n将剩下的球员。\n第1部分数据库,33\n找到数据\n现在,我们有一些数据收集,我们能够检索这些数据。我们将这样做\n接口在下一章,但就目前而言,我们只是通过控制台。\n在控制台,输入以下:\nPlayersList.find();\n在这里,我们使用这个找到函数,用于检索数据从指定的集合。\n因为我们没有任何穿过支架,该语句将检索所有的\n的数据集合。\n以下应该出现在控制台:\n使用find函数。\n但很明显,这不是最可读的回应。我们的应用程序可以是有意义的,但是\n我们不能。\n检索数据更可读的格式,附加一个获取函数的转换\n检索到的数据转换成一个数组:\n.fetch PlayersList.find()();\n第1部分数据库、34\n您应该看到如下:\n使用查找和获取功能。\n我们也可以单击下箭头与每个文档相关的数据,\n包括:\n•_id字段,存储文档的惟一的ID(“主键”,我们\n之前提到过)。\n•名称字段,存储的球员的名字。\n•比分字段,存储得分的球员。\n但是如果我们想要检索的数据的集合,而不是所有的\n数据?要做到这一点,我们可以通过json格式的数据之间的括号:\nPlayersList。找到({ name:“大卫”}).fetch();\n这里,我们通过字段名和值通过发现功能,因此,我们可以\n只检索文档,球员的名字字段等于“大卫”。在我们的例子中,这个\n只检索一个文档,但是如果我们集合包含多个玩家叫“大卫”,\n他们都是根据这个查询返回。\n也有用的是计算能力的数量由一个查询返回的文件\n将计数函数找到函数:\n数据库中,第1部分35\n.count PlayersList.find()();\n因为这个语句将计数集合中的所有文档,如果有六名球员\n(文件)的集合,6号返回。\n第1部分数据库、36\n总结\n在这一章,我们了解到:\n•当我们创建一个流星项目,蒙戈数据库自动创建,和\n当本地服务器正在运行,那么数据库。\n•Mongo数据库和SQL数据库不同,但差异是无关紧要的\n初学者而言。\n•为每一种类型的数据需要存储在Mongo数据库中,我们需要创建一个集合。\n集合包含文档和文档的字段和值。\n•使用插入函数,我们可以将数据插入一个集合。这个数据结构\n以JSON格式。\n•通过使用find函数,我们可以从集合中检索数据。这些数据就可以\n通过使用控制台导航。\n流星的更深层次的理解:\n•注意,我们还没有预定义的数据库的结构。相反,结构\n定义数据库的动态,我们使用插入函数。\n•在一个单独的项目中,创建一个存储不同类型的数据的集合,比如博客\n帖子,也许。什么样的字段集合有吗?\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n模板\n在这一章,我们将开始构建排行榜的用户界面的应用程序。\n这包括创建我们的第一个模板。\n首先,下面的代码在排行榜。html文件:\n<头>\n<标题>排行榜< /名称>\n< / >头\n<身体>\n<标题>排行榜< / h1 >\n< /身体>\n这段代码没有什么特别之处——它只是标准的HTML,但出现\n缺少几件事:\n•我们没有包含html标签。\n•我们还没有包括任何JavaScript文件\n•我们还没有包括任何CSS文件。\n但是我们没有包括这些事情,因为我们不需要他们。流星负责\n对我们这些细节。它将html标记添加到文件的开始和结束,自动\n包括项目的文件夹中包含的任何资源(比如JavaScript和CSS文件)。\n这不是世界上最引人注目的特性,但是流星的核心理念之一\n开发者幸福,所以有很多这样传遍了节省时间的特性\n框架。\n37\n模板38\n创建一个模板\n模板用于创建接口和JavaScript代码之间的连接。当\n我们把界面元素在一个模板,我们可以参考和操作\n元素与应用程序逻辑。\n创建一个模板,将下面的代码添加到HTML文件的底部,下\n关闭body标签:\n<模板名称=“排行榜”>\nHello World\n< /模板>\n在这里,我们使用这个模板标签,它使用一个名称属性来区分\n我们创建不同的模板。在这种情况下,模板的名称是“排行榜”,我们会\n很快这个名字从JavaScript文件的引用。\n如果你保存文件在其当前状态,模板不出现在web浏览器。\n在HTML文件,但是没有别的地方了。这是因为,在默认情况下,模板不出现\n内部接口。这听起来可能很奇怪,但是考虑到,在某些情况下:\n•您可能希望一个模板出现在某些时候。\n•您可能希望一个模板在某些时刻消失。\n•你可能想要一个模板出现在多个位置。\n考虑到这种可能性,我们需要手动包含模板内部的接口。这\n确实需要一个额外的步骤,但它会变得越来越有用,因为我们深入发展。\n使“排行榜”模板出现在浏览器内,把这个标签之间的身体\n需要在HTML文件:\n{ { >排行榜} }\n显然,这不是HTML。代替。double-curly括号的使用意味着这是空格键\n语法,空格键是语法中我们使用HTML当我们想要动态\n发生。这是语法,桥梁之间的差距接口和应用程序逻辑。\n我们将了解更多关于空格键在这本书,但现在,知道:\n1。所有空格键标签使用double-curly括号来区分。\n2。我们只使用大于符号当我们想要包括一个模板。\n基于这些变化,HTML文件现在应该类似于:\n模板39\n<头>\n<标题>排行榜< /名称>\n< / >头\n<身体>\n<标题>排行榜< / h1 >\n{ { >排行榜} }\n< /身体>\n<模板名称=“排行榜”>\nHello World\n< /模板>\n保存文件之后,内部的“Hello World”从“排行榜”模板\n出现在浏览器:\n当前界面。\n模板40\n客户端与服务器\n在我们继续之前,我想要证明的东西。你不需要完全理解我们\n封面,但都遵循允许通过编写的所有代码。\n在JavaScript文件,编写以下控制台。日志语句:\n控制台。日志(“Hello world”);\n这是我们声明语句写在“项目”一章,并在保存文件\n切换回Chrome,您应该看到“Hello world”消息出现在控制台:\n“Hello World”出现在控制台。\n上次我没有提到虽然是,由于这种说法,别的东西也\n发生,如果我们切换到命令行中,我们可以看到“Hello world”消息\n也在这里:\n模板41\n“Hello World”出现在命令行。\n这是很重要的,因为我们已经写一行代码的执行在两个地方。的\n代码是运行在客户端(在用户的web浏览器)和服务器(其中\n应用程序托管)。\n为什么这很重要?\n有几个原因,但这里有一个例子:\n自从我们创造了“PlayersList”集合,下面的语句上运行\n客户端和服务器:\nPlayersList = new Mongo.Collection(球员);\n但是代码不做同样的事情在这两个地方。\n当代码在服务器上执行,创建在Mongo集合数据库。这是\n我们的数据存储。当代码执行从用户的web浏览器中虽然-\n在客户端创建一个本地副本的收集用户的计算机。作为一个结果,\n当用户与数据库交互时,他们实际上交互的本地副本。这\n部分原因是流星应用程序默认是实时的。数据是用户的操作\n本地机器然后无形在后台与服务器端数据库同步。\n但如果这一切听起来有点概念,不要害怕。你不需要了解细节\n点流星的“魔法”。你只需要一行代码就可以掌握:\n1。在两个不同的环境中运行(在客户端和服务器)。\n模板42\n2。根据不同的环境会有不同的行为。\n也就是说,在某些情况下,我们不希望我们的代码运行在两个地方。如果,\n实例中,我们编写代码,只会影响应用程序的接口,它不会是有意义的\n在服务器上运行的代码。我们只希望它在客户机上运行。\n适应,有一双条件我们可以用来确定代码运行\n的环境。你会有一个更好的想法何时使用这些条件\n通过书的进展,但是,只要跟着目前通过编写所有的\n代码。\n首先,一颗流星。isClient条件下的控制台。日志声明:\n如果(Meteor.isClient){\n/ /这段代码只在客户机上运行\n}\n这个条件允许我们专门执行代码在客户端——从用户的内部\nweb浏览器,为了证明这一点,我们可以简单地添加一个控制台。日志声明内\n条件:\n如果(Meteor.isClient){\n控制台。日志(“你好客户”);\n}\n保存文件,切换到浏览器,注意,“你好”客户端消息出现在\n控制台,但没有出现在命令行里面。这是因为代码没有被\n在服务器上执行。\n模板43\n“你好,客户端”只出现在控制台。\n我们可以创建与流星相反的效果。isServer条件:\n如果(Meteor.isServer){\n/ /这段代码只运行在服务器上\n}\n再次,我们将放置一个控制台。日志语句内部条件:\n如果(Meteor.isServer){\n控制台。服务器日志(“你好”);\n}\n保存文件之后,请注意,“你好”服务器消息出现在命令\n线,但不出现在控制台。这是因为只有被执行的代码\n托管服务器(应用程序)。\n模板44\n“你好,服务器”只出现在命令行。\n但是如果这一切都是真的沉没,只要记住两件事:\n1。一行代码可以运行在客户端和服务器。\n2。有时我们不想让我们的代码运行在这两个地方。\n精确的时刻,我们需要考虑这些点很快就将变得明朗了。\n现在,仅仅删除控制台。日志语句,但离开他们的条件。我们会\n很快就会使用它们。\n模板45\n创建一个助手\n在这一点上,我们的“排行榜”模板只显示静态文本“Hello World”。为了解决这个问题,\n我们将创建一个helper函数,一个辅助函数是一个常规的JavaScript函数\n附加的模板,让我们从一个接口内部执行代码。\n开始,我们将一个古老的方法来创建辅助函数。这种方法已被弃用,\n这意味着它不再是官方支持,你读这句话的时候,它可能\n不工作。但这老格式更容易教和理解,并允许我们来缓解\n到non-deprecated方法,我们会讨论。\n在JavaScript文件,编写以下isClient内部条件:\nTemplate.leaderboard.player\n这是弃用语法来创建一个helper函数,它可以分解成三个\n部分:\n首先,我们流星的模板通过关键词搜索模板工程。我们只\n有一个模板,但是一个完整的项目会更多。\n第二,通栏广告关键字指的是我们创建模板的名称\n早些时候。每一个helper函数必须附加到一个模板。在这种情况下,附加功能\n“排行榜”模板。\n第三,球员关键字是我们给这个函数。我们很快就会参考\n这个名字在HTML文件。\n这个助手附加代码,将它与一个函数:\nTemplate.leaderboard。球员= function(){\n/ /代码在这里\n}\n“助手”这个词可能会让这种声音的,但是我们没有做什么特别的。\n我们已经创建了一个函数,将其命名为“球员”,并连接到“排行榜”模板。\n添加一些功能函数,创建一个返回语句返回一些静态的\n文本:\nTemplate.leaderboard。球员= function(){\n返回“其他文本”\n}\n然后删除的文本“Hello World”模板,代之以“排行榜”\n以下标记:\n模板46\n{ {球员} }\n在这里,我们使用的是另一个空格键标签,就是明证double-curly括号的使用。但\n请注意,我们不使用大于符号,这是因为我们不包括\n模板。相反,我们引用玩家函数的名称。\n保存文件后,返回语句的文本应该出现在浏览器内:\n使用弃用辅助函数方法。\n如果文本不出现,一些是错误的代码,或者这种方法创建\n从流星助手被移除。如果你不确定它,检查你的代码错误。\n如果您的代码就是我告诉你写,它仍然不工作,不要害怕。现在,\n你知道老方法创建辅助函数,我们准备讨论的新方法。\n删除所有我们刚刚创建的helper函数,代之以:\nTemplate.leaderboard.helpers\n在这里,我们有这个模板的关键字,搜索通过模板在我们的项目,\n这个排行榜的关键字,这是一个引用“排行榜”模板。\n但是这个帮手关键词呢?\n我们创建一个函数命名的“帮手”?\n不。\n模板47\n这个助手关键字是一个特殊的关键字,它允许我们定义多个辅助功能\n在一个代码块。\n因此,而不是创建一个helper函数:\nTemplate.leaderboard。球员= function(){\n/ /代码在这里\n}\n我们为所有的模板创建一个块的辅助功能:\nTemplate.leaderboard.helpers({\n/ /辅助函数到这里\n});\n这些助手以JSON格式定义,与助手的名字和一个的关键\n相关函数的值:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回“其他文本”\n}\n});\n使用逗号分隔,我们可以创建多个辅助功能:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回“其他文本”\n},\n“otherHelperFunction”:函数(){\n返回“其他功能”\n}\n});\n可以使用这两个辅助函数在“排行榜”模板:\n{ {球员} }\n{ { otherHelperFunction } }\n这段代码可能看起来有点忙比弃用的方法,但这只是因为我们\n使用少量的帮手。更大数量的助手,组织他们\n这是最清洁的方法。\n模板48\n一对辅助函数在一个模板。\n模板49\n每一块\n我们已经取得了一个helper函数,但它只是返回一些静态文本,这并不是很有趣。\n我们真正想要的是一个helper函数,从“PlayersList”中检索文档\n收集。然后我们就可以从界面中显示数据。\n为了达到这个目标,helper函数的返回语句替换为以下几点:\n返回PlayersList.find()\n在这里,我们使用find函数函数从“数据库,第1部分”一章。这个函数\n将从“PlayersList”检索所有的数据集合,因为我们已经把它内\nhelper函数,这些数据现在可以从内部“排行榜”模板。\n看到这,从HTML文件中删除以下标记:\n{ {球员} }\n之前,我们的helper函数返回之前的一段数据,字符串,\n这个目的,这个标签是很好,但现在的助手是返回一个数组的所有文档\n在集合,这意味着我们需要遍历返回的数据。\n为了实现这一点,我们可以使用空格键语法来创建一个每个块:\n{ { #每个玩家} }\n测试\n{ { /每个} }\n在这里,有几个事情:\n首先,从“PlayersList”收集所有的文档检索的基础上,参考\n玩家的功能。\n第二,我们遍历返回的数据的每个语法。\n第三,我们为每个文档输出“测试”这个词(球员)的检索。因为有\n六名球员在收集、“测试”这个词会出现界面内的6倍。\n模板50\n“测试”这个词似乎每个玩家的收集。\n从概念上讲,这就像我们有一个数组:\nvar playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);\n…就像我们使用forEach循环遍历这个数组的值:\nvar playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);\nplayersList.forEach(函数(){\nconsole.log(测试);\n});\n在每一块,我们也可以从内部文档检索字段的值。\n因为我们把“PlayersList”收集的数据,我们可以显示的值\n字段名字和分数。\n显示玩家的名字,例如,我们可以写:\n{ { #每个玩家} }\n{ {名称} }\n{ { /每个} }\n然后显示玩家的分数,我们可以写:\n模板51\n{ { #每个玩家} }\n{ {名称} }:{ {得分} }\n{ { /每个} }\n虽然我们不会让这个应用程序很浪费时间,我们将添加一些细微的结构\n的接口:\n< ul >\n{ { #每个玩家} }\n<李> { {名称} }:{ {得分} } < /李>\n{ { /每个} }\n< / ul >\n保存文件后,玩家的名字和分数将会出现在一个无序列表。通过\n默认情况下,球员们会按时间——从他们插入到集合\n玩家添加第一个球员最近增加了更多,但这是我们改变\n后一章。\n一种改进的界面。\n模板52\n总结\n在这一章,我们了解到:\n•流星为我们处理一些无聊的细节,如使用html标记和包括\nJavaScript和CSS文件。\n•通过创建模板,我们可以形成一个应用程序逻辑和我们之间的桥梁\n接口。\n•我们的项目的代码可以在客户端和服务器上运行,但我们并不总是想要的\n这样的事情发生。我们可以使用isClient isServer条件控制的\n代码运行。\n•创建一个模板后,我们需要手动把它在界面。这给了\n我们控制时间和地点。\n•通过创建辅助函数,我们可以执行代码在一个模板,从而创建\n一个动态的界面。\n•如果一个helper函数返回一个数组的数据,我们可以通过数据在一个循环\n模板使用每个语法。\n流星的更深层次的理解:\n•意识到模板可以放置在任何地方项目的文件夹。我们可以,\n实例,把我们的“排行榜”模板在另一个HTML文件和参考{ { >\n排行榜} }将继续工作。\n•故意打破应用程序通过将每个块之外的“排行榜”\n模板。熟悉的错误,你会不可避免地遇到一颗流星\n开发人员。然后你就会知道如何处理这些问题当他们意想不到的。\n•创建一个helper函数,使用查找和计数函数返回的数量\n球员“PlayersList”集合。然后在界面中显示这些数据。\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n事件\n在这一点上,我们有一个名单的球员出现在界面,但是没有办法\n用户与该列表。数据动态地从“PlayersList”收集、检索\n但用户仍将可能假定应用程序完全是静态的。\n我们将花剩下的书解决这个问题,但在接下来的几个章节\n特别的,我们将创建的影响能够选择球员名单内。\n具体来说,当用户点击其中一个球员,球员的背景颜色\n元素将会改变黄色。\n53\n事件54\n创建一个事件\n在本节中,我们将创建我们的第一个事件,事件使我们能够触发执行的代码\n当用户点击一个按钮,轻拍一个关键键盘,或完成一系列其他\n行动。\n为了说明这一点,写在isClient条件如下:\nTemplate.leaderboard.events({\n/ /事件到这里\n});\n在这里,有几个事情:\n首先,模板是用来搜索所有的项目模板。\n第二,排行榜是模板的名称我们要附加事件。\n第三,事件是特殊的关键字,是用于指定,在未来的\n代码,我们希望指定一个或多个事件。(这段代码非常类似于我们如何创建助手\n功能。)\n花括号之间的事件块,使用JSON格式创建一个事件:\nTemplate.leaderboard.events({\n“点击”:函数(){\n/ /代码在这里\n}\n});\n在这里,有两个事情:\n首先,我们定义事件类型。这是点击部分。正因为如此,里面的代码\n相关的函数将执行当用户点击的范围内的任何地方\n“排行榜”模板。\n第二,这个事件我们附加一个函数,这个函数里面,我们可以写\n代码要执行时,单击出现。\n为了说明这一点,添加一个控制台。日志语句内的事件:\nTemplate.leaderboard.events({\n“点击”:函数(){\n控制台。日志(“你点击”);\n}\n});\n事件55\n保存文件后,切换回Chrome和点击的范围内的任何地方\n“排行榜”模板。每次点击,你点击“消息将出现在里面\n控制台。\n点击。\n事件56\n事件选择器\n我们已经创建的事件是太过宽泛。它触发当用户单击任何地方范围内\n“排行榜”的模板。在某些情况下可能是有用的,但通常我们\n当用户希望触发一个事件做精确,喜欢点击某个按钮。\n为了实现这一点,我们将使用事件选择器,选择符允许我们将事件附加到特定的HTML\n元素。(如果你曾经使用jQuery,这个过程将是熟悉的,但如果不是这样,它仍然会相当\n容易掌握。)\n早些时候,我们把李HTML文件中的标签:\n<李> { {名称} }:{ {得分} } < /李>\n目前的计划是让我们的事件触发李当用户点击其中一个元素。\n要做到这一点,改变事件如下:\n“李点击”:函数(){\n控制台。日志(“你点击一个li元素”);\n}\n在这里,我们做了两处修改:\n首先,我们已经添加了李后点击关键字部分。这意味着事件将触发\n当用户点击“排行榜”内任何li元素模板。\n第二,我们已经改变了控制台的输出。日志语句。\n然而,我们还没有考虑:\n会发生什么,如果我们有其他的li元素内部的“排行榜”模板,不是吗\n玩家的列表的一部分吗?以后会这样,我们的代码的目前的形式来看,它会引发一场\n问题。事件将触发当我们不希望它来触发。\n为了解决这个问题,添加一个。球员对li元素类:\n<李类= \"玩家\" > { {名称} }:{ {得分} } < /李>\n然后使用这类事件选择器:\n的点击。球员”:函数(){\n控制台。日志(“你点击。球员元素”);\n}\n在这里,我们已经取得了如此事件只会触发,当用户单击一个元素\n的。播放器类连接到它。\n保存文件后,最后的结果不会出现任何不同,但是如果我们添加其他元素\n模板,事件不会触发的时候不应该。\n事件57\n点击一个球员。\n事件58\n总结\n在这一章,我们学到的:\n•当用户点击一个按钮,提交一个表单,或完成其他操作,我们可以\n触发器的执行代码通过使用事件。\n•最常见的事件类型是点击,但是有一个可用的其他选项范围\n以许多不同的方式使我们的应用程序交互。\n•通过使用事件选择器,我们可以精确的元素的附加事件\n类似的语法jQuery和CSS。\n流星的更深层次的理解:\n•尝试不同的事件类型,包括:双击鼠标,焦点,模糊,鼠标悬停,\n改变。找出这些不同类型的行为,试图整合他们\n排行榜的应用程序。\n在其当前状态查看代码,查看GitHub提交。\n\n\n会话\n当用户点击其中一个。球员元素,执行一个函数。当这个函数是\n触发,我们想改变背景颜色的元素,从而产生的效应\n被选中的球员。\n为了实现这一点,我们将使用会话,会话允许我们不存储小块的数据\n保存到数据库并返回访问不会记得。这类数据可能\n听起来不立即有用,但这是一个令人惊讶的是通用的方法来解决很多共同之处\n问题。\n59\n会话60\n创建一个会话\n创建一个会话,写在单击下面的语句。球员事件:\n会话。集(“selectedPlayer”、“会话值测试”);\n这里,我们使用这个会话。设置功能,通过两个参数:\n首先,我们通过会议的名称。这个名字被用作参考。在这个\n情况下,我们调用会话“selectedPlayer”,但随意使用任何你喜欢的名字。\n其次,我们通过会议的价值。这是我们内部存储的数据\n会话。在这种情况下,我们通过“会话值测试”的静态值,但我们会\n使用一个更有趣的值。\n证明我们的会话是按预期工作,检索的会议的价值\n下面的语句:\nSession.get(“selectedPlayer”);\n块应该类似的事件:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\n会话。集(“selectedPlayer”、“会话值测试”);\nSession.get(“selectedPlayer”);\n}\n});\n这里,我们使用这个会话。函数,通过“选择——的名称\n玩家“会话,我们刚才创建的。\n输出该会话的值到控制台,它在一个变量:\nvar selectedPlayer = Session.get(“selectedPlayer”);\n然后添加一个控制台。日志声明下面这条线:\nvar selectedPlayer = Session.get(“selectedPlayer”);\nconsole.log(selectedPlayer);\n现在,当用户点击其中一个球员元素,“会话值测试”字符串\n存储在一个会话,然后立即输出到控制台。它不是最有用的代码,\n但这很快就会改变的。\n61年会议\n创建和检索一个会话。\n62年会议\n玩家的ID\n当用户点击列表中的玩家之一,我们要抓住玩家的惟一ID\n并将其存储在“selectedPlayer”会议。这将允许我们改变背景\n这个玩家的li元素的颜色。\n如果你不确定我是什么意思,当我说“玩家”的惟一的ID,回想\n当我们球员插入“PlayersList”集合。每次我们使用插入\n函数,一个随机的数字和字母会出现。混乱是唯一的ID\n的球员。\n首先,创建一个“playerId”变量的顶部点击。球员的事件,并使其平等\n从之前的“会话值测试”字符串:\nvar playerId =“会话值测试”;\n然后修改会话。集函数,通过“playerId”变量作为第二个\n论点。事件应该类似于:\n的点击。球员”:函数(){\nvar playerId =“会话值测试”;\n会话。集(selectedPlayer,playerId);\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n在这一点上,关键是要使“playerId”变量等于球员的惟一ID\n这是被点击。这并不需要大量的代码,但它确实需要一些解释。\n现在,改变“playerId”变量如下:\nvar playerId = this._id;\n至于原因,有两个事情:\n首先,我们有一个参考,这取决于上下文的价值。在这种背景下,\n这个指的是文档的球员刚刚点击。\n第二,_id部分是包含惟一的ID字段的名称的球员。所以在\n我们创建了一个名字和分数一样,蒙戈为每个文档创建一个_id字段。\n(下划线本身没有任何特殊的意义。这只是部分字段的名字。)\n由于这一变化,现在下面是可能的:\n1。用户点击的一个球员。\n2。玩家的惟一ID存储在“playerId”变量。\n3所示。“playerId”变量的值存储在“selectedPlayer”会话。(可以\n只有一个值存储在一个会话,所以每当一个新值存储,前面的\n值是重写。)\n63年会议\n4所示。“selectedPlayer”会话的值输出到控制台。\n看到这在行动:保存文件,切换回Chrome,点击任何球员\n列表。他们惟一的ID将显示在控制台。\n点击大卫后,鲍勃和玛丽。\n因为我们不需要看到控制台内的点击播放器的惟一的ID,我们可以\n简化事件如下:\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n}\n在这里,我们只是设置的值“selectedPlayer”会议,点击的惟一ID\n的球员。\n64年会议\n选择效果,第1部分\n当用户点击一个球员在我们的列表中,我们想要改变背景颜色\n包含该玩家的li元素的属性。这将创建该玩家的影响\n被选中。\n为了实现这一点,打开项目的CSS文件并创建一个名为“选择”的类。这门课应该\nbackground属性,在这个例子中,我们将通过“黄色”的价值:\n.selected {\n背景颜色:黄色;\n}\n然后切换到JavaScript文件并创建一个“selectedClass”助手:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回PlayersList.find()\n},\n“selectedClass”:函数(){\n/ /代码在这里\n}\n});\n(你会发现两个助手都是在相同的代码块,和我们讨论\n以前,这是可能使用逗号)。\n至于这个函数的内容,我们会让它返回“选择”这个词:\n“selectedClass”:函数(){\n返回“选择”\n}\n注意:我们需要返回的文本等于在CSS文件类的名称,因为\n我们命名为“类”选择“在CSS文件中,我们返回“选择”从内部文本\n这个函数。\n接下来,切换到HTML文件并将引用这个“selectedClass”功能里面\nli元素的class属性:\n<李类= \"球员{ { selectedClass } } \" > { {名称} }:{ {得分} } < /李>\n“选择”类将被应用到每一个。球员的元素,从而改变了背景\n每个元素的颜色:黄色\n65年会议\n“选择”类是应用于li元素。\n这不是我们想要的但这是一个重要的一步。\n66年会议\n选择效果,第2部分\n在我们继续之前,我想要证明的东西。\n在selectedClass helper函数返回语句注释掉:\n“selectedClass”:函数(){\n/ /返回“选择”\n}\n然后编写以下:\n“selectedClass”:函数(){\n/ /返回“选择”\n返回this._id\n}\n在这里,我们使用这个。_id检索的惟一ID的球员。而是的ID\n输出到控制台,它会出现在每个li元素的class属性。这是\n不是我们想要的但重要的是要知道,因为selectedClass函数\n被执行在每一块,它可以访问所有的数据迭代\n(包括球员的惟一的ID、姓名和分数)。\n这证明:保存文件,切换到Chrome,右键单击li元素之一,并选择\n“检查元素”选项。你会注意到每个玩家现在出现在的惟一ID\nclass属性:\n67年会议\n球员们在每个类的惟一的ID属性。\n知道了这一点,我们要做几件事:\n首先,我们将删除返回。_id声明,因为它只是用于演示目的。\n第二,我们将取消返回语句,因为我们想要selectedClass函数\n返回“选择”的静态文本。\n第三,我们将创建一个“playerId”变量的函数,this._——的价值\nid:\n“selectedClass”:函数(){\nvar playerId = this._id;\n返回“选择”\n}\n第四,我们将创建一个“selectedPlayer”为“selectedPlayer”会话变量:\n68年会议\n“selectedClass”:函数(){\nvar playerId = this._id;\nvar selectedPlayer = Session.get(“selectedPlayer”);\n返回“选择”\n}\n第五,将返回语句在下列条件:\n“selectedClass”:函数(){\nvar playerId = this._id;\nvar selectedPlayer = Session.get(“selectedPlayer”);\n如果(playerId = = selectedPlayer){\n返回“选择”\n}\n}\n逻辑后如果你有麻烦,这是怎么回事:\n当用户点击一个列表中的玩家,玩家的惟一ID存储在里面\n“selectedPlayer”会议。然后该会话的ID匹配的所有ID\n球员们在列表中。因为玩家的ID将永远是独一无二的,只能有一个\n单匹配,匹配时,静态文本的“选择”将返回的\nselectedClass功能和放置在球员li元素的class属性。基于\n在这类,玩家的li元素的背景颜色会变成黄色。(和\n因为会话只能存储一个值,只有一个球员可以选择一次)。\n点击后,鲍勃。\n这是最复杂的例子在这本书中,但是你只需要掌握一种基本的会话\n其余的章节。它并不重要,如果你不“获得”的一切。\n69年会议\n总结\n在这一章,我们了解到:\n•会议是用来存储小块的数据没有保存到数据库或\n记得在返回访问。\n•创建一个会话,我们使用会话。集函数,而检索的价值\n会话我们使用会话。得到的功能。\n•辅助函数和事件在每一块获得的数据\n遍历的块。\n流星的更深层次的理解:\n•考虑我们如何使用“selectedPlayer”会议。我们还可以做些什么\n选中的球员的惟一的ID吗?\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n数据库,第2部分\n还有很多其余页的这本书,但是我们已经完成了大部分\n从最初的排行榜应用程序特性。\n剩下的我们将在本章的工作包括:\n•增加选择球员的得分能力。\n•排名球员的得分(从最高到最低)。\n•显示选中的球员的名字在名单上。\n我们也可以减量的得分选择球员,这并不是的一个特征\n原始的应用程序,但足够简单的添加。\n70年\n第2部分数据库,71\n给5分\n在“排行榜”模板,我们将创建一个“给5分”按钮,当点击时,会\n增加选择的球员的得分。\n开始,将下面的按钮在“排行榜”模板:\n< input type = \" button \" class = \"增量\" value = \"给5分”>\n按钮应该以外的每一块,类属性的设置\n“增量”。\n按钮做一些,添加以下事件的事件块内\nJavaScript文件:\n的点击。增量”:函数(){\n/ /代码在这里\n}\n整个事件块应该类似于:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n},\n的点击。增量”:函数(){\n/ /代码在这里\n}\n});\n(别忘了事件之间用逗号分隔)。\n在点击。增加事件,我们将使用选定的玩家发现的惟一ID\n玩家在“PlayersList”收集和增加球员的得分字段的值\n5。\n访问的唯一ID选择球员,使用会话。功能:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n您可以验证这个功能一个控制台。日志语句:\n第2部分数据库,72\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nconsole.log(selectedPlayer);\n}\n选择一个球员之后,单击“给5分”按钮来显示所选的惟一ID\n的球员。\n单击“给5分”按钮后,玛丽的身份出现在控制台。\n第2部分数据库,73\n先进的运营商,第1部分\n在这一点上,我们想做的是,当一个用户从列表中选择一个球员和点击\n“给5分”按钮时,该玩家的分数是修改。\n要做到这一点,删除控制台。从点击日志语句。增加事件和替换它\n用以下:\nPlayersList.update();\n这是Mongo更新函数,在括号之间,我们可以定义:\n1。什么文档(球员)我们要修改。\n2。我们想修改文档。\n要做到这一点,我们首先检索所选球员的文档。这可以通过通过\n选中的球员的惟一ID:\nPlayersList.update(selectedPlayer);\n这件事现在应该类似于:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList.update(selectedPlayer);\n}\n修改文档,我们通过第二个参数更新函数定义\n文档的一部分,我们要改变:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer {得分:5 });\n}\n该语句将:\n1。找到的文档选择的球员,根据玩家的ID。\n2。更新文档通过改变比分字段的值为5。\n第2部分数据库,74\n但是如果你测试这个功能,你会发现它坏了。如果你选择了一个播放器,点击“给\n5点”按钮,这名球员的名字将会消失。比分字段的值将会改变\n5,按计划,但名称字段将完全从文档中删除。\n玛丽去了哪里?\n这可能看起来像是一个错误,但默认情况下,更新函数通过删除原来的工作\n文档和创建一个新的文档与我们指定的数据。_id字段的值\n将保持不变,但由于我们只指定update语句内的分数,\n这是唯一的其他领域仍在修改文档。\n考虑到这一点,我们需要使用一套Mongo运营商,让我们的价值得分\n场没有删除原始文档。\n首先,用以下代码替换更新函数的第二个参数:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $:});\n}\n这里,我们使用这个设置操作员修改一个字段的值美元(或多个字段)\n删除原始文档。冒号后,我们只需要通过我们想要的字段\n修改(和他们的新值):\n第2部分数据库,75\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $设置:{得分:5 } });\n}\n由于这一变化,更新函数不会被完全打破。如果我们保存文件\n切换回Chrome,我们可以看到,选择一个球员和点击“给5分”按钮\n将修改玩家的分数而不影响文档的其余部分。\n设置分数而不破坏任何东西。\n但尽管如此成功,我们仍然没有创建功能,我们旨在创建。因为\n当我们的按钮可以设置选择玩家的分数5的价值,这就是它能做的。没有\n多少次我们单击按钮时,字段的值不会增加任何进一步的。\n修复这个问题,替换设置操作员与公司接线员:美元\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n根据这一变化,每当更新函数触发,比分字段的值\n将增加任何价值我们指定的值(在本例中,5)。\n第2部分数据库,76\n现在可以增加分数字段的值。\n第2部分数据库,77\n先进的运营商,第2部分\n没有出现在原始的排行榜的功能应用程序是衰减的能力\n分数。虽然这样的特性将会有用,因为它意味着我们可以:\n1。惩罚玩家不遵守规则。\n2。收回点错误地获得。\n也是一个很简单的特性来扔在一起。\n首先,创建一个“带5分”按钮在“排行榜”模板:\n< input type = \"按钮”class =“减量”值=“带5分”>\n与“给5分”按钮,把它在每个块和为它提供一个独特的\n类属性(如“减量”)。\n接下来,点击切换到JavaScript文件,复制。增加事件,将代码粘贴到\n同样的事件。\n块的事件应该类似于:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n},\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n},\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n});\n在这一点上,我们只需要做两个变化:\n首先,更改为新创建的事件选择器。.decrement增量。\n第二,价值5通过公司运营商,而不是值为5。附加的\n——逆转算子的功能,现在美元的公司操作符将衰减值\n的分数。\n最后一个事件的代码应该类似于:\n第2部分数据库,78\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n有点冗余的代码,我们有两个几乎相同的事件——但这是\n我们在后面的章节会修理。\n第2部分数据库,79\n对文档进行排序\n目前,球员名单中排名的时候他们插入\n收集,而不是通过他们的分数排名。\n为了解决这个问题,我们将修改里面的球员helper函数返回语句:\n“球员”:函数(){\n返回PlayersList.find()\n}\n首先,通过一对大括号的括号找到功能:\n“球员”:函数(){\n返回PlayersList.find({ })\n}\n通过使用这些花括号,我们明确说明我们想要检索的所有数据\n从“PlayersList”集合。这是默认的行为,所以这两个语句\n技术上:\n返回PlayersList.find()\n返回PlayersList.find({ })\n但经过花括号作为第一个参数,我们可以通过第二个\n参数,在这第二个参数,我们可以定义如何想对数据排序\n检索。\n作为第二个参数,通过接线员:\nPlayersList返回。找到({ },{ }):\n(不像集和美元公司经营者,我们不使用美元符号的这个操作符\n的名字。)\n然后选择排序的字段的值:\nPlayersList返回。找到({ },{:{分数:1 } })\n通过值传递,我们可以按照降序排列。这意味着我们的排序\n从得分最高的球员得分最低。如果我们通过一个值的球员\n将排序分数最高的分数最低。\n第2部分数据库,80\n基于他们的分数排名球员。\n基于这种变化,球员们将会根据他们的分数排名,但是如果两个\n玩家同样的分数吗?\n采取“鲍勃”和“比尔”,例如。如果他们有相同的分数,比尔应该排名高于鲍勃\n因为,按字母顺序,首先是他的名字。但此刻,不会发生因为鲍勃\n比尔之前添加到集合。\n为了解决这个问题,name字段通过运营商,但是这一次,通过的值\n1而不是1:\nPlayersList返回。找到({ },{:{分数:1,名字:1 } })\n球员们仍将主要由他们的分数排名,但是一旦发生了排序,\n球员们也会在他们的名字。这二次排序将发生在提升\n(字母)。\n第2部分数据库,81\n基于分数和排名的名字。\n根据这一变化,如果Bob和比尔有相同的分数,比尔会排名高于鲍勃。\n第2部分数据库,82\n个人文档\n当用户选择其中的一个球员,球员的名字将出现在列表中\n的球员。这并不是最有用的功能,但是:\n1。这是最初的排行榜的一部分应用程序。\n2。这意味着我们可以谈论一些流星的特性。\n在JavaScript文件,创建一个helper函数,连着“showSelectedPlayer”\n“排行榜”模板:\n“showSelectedPlayer”:函数(){\n/ /代码在这里\n}\n内部函数,获取当前选中的球员的惟一ID:\n“showSelectedPlayer”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n然后写一个返回语句,返回数据从一个文档内\n“PlayersList”集合。我们可以使用find函数,但findOne函数是首选\n选择:\n“showSelectedPlayer”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n返回PlayersList.findOne(selectedPlayer)\n}\n通过使用findOne函数,我们可以通过文档作为唯一的惟一ID\n参数,我们可以避免不必要的开销,因为这个函数只\n尝试检索单个文档。它不会像找到浏览整个集合\n将函数。\n有了这个功能,切换到HTML文件并将引用里面的函数\n“排行榜”模板。我把我的列表的底部,李两两之间的标签:\n<李>选中的球员:{ { showSelectedPlayer } } < /李>\n但是如果我们保存文件,输出看起来不完全正确,因为findOne函数\n是球员的整个文档检索。为了解决这个问题,我们需要指定,我们只希望\n显示名称字段的值,可以用点符号:\n第2部分数据库,83\n<李>选中的球员:{ { showSelectedPlayer.name } } < /李>\n现在的接口将类似于:\n显示选中的球员的名字。\n我们也应该让模板并不试图显示如果一个球员一个球员的名字\n不是选择,可以用一个简单的条件:\n{ { #如果showSelectedPlayer } }\n<李>选中的球员:{ { showSelectedPlayer.name } } < /李>\n{ { /如果} }\n这个列表项将只出现一个球员当前是否选中。\n第2部分数据库,84\n总结\n在这一章,我们了解到:\n•在默认情况下,蒙戈更新功能的更新和删除文档\n再现与指定的字段(同时保留相同的主键)。\n•改变文档的值没有先删除它,设置操作员需要美元\n被使用。这个操作符只会指定文档的值没有改变\n影响文档的其余部分。\n•公司美元操作符可以用来增加一个字段的值在一个特定的\n文档。\n•公司美元操作符可以用来衰减被放置的-一个字段的值\n前面的符号指定的值。\n•排序操作符可以用来排序的数据找到返回的函数。它\n可以由多个字段排序。\n•findOne函数只会从集合中检索单个文档,\n更有效的方法,如果你只需要检索单个文档。\n流星的了解:\n•让“给5分”按钮只出现在用户已经选择。这\n是最初的排行榜的功能的应用程序。\n•浏览“运营商”部分Mongo文档看看的\n可以通过纯粹的数据库操作。\n在其当前状态查看代码,查看GitHub提交。\n\n\n形式\n我们已经完成重建原始排行榜的应用程序,但有足够的空间\n扩大同新功能的应用程序。在这个章节中,我们将创建一个表单\n允许用户添加玩家排行榜,连同其他界面控件。\n85年\n86年形式\n创建一个表单\n在HTML文件,创建一个名为“addPlayerForm”的第二个模板:\n<模板名称= \" addPlayerForm \" >\n< /模板>\n包括这个地方在“排行榜”模板:\n{ { > addPlayerForm } }\n在“addPlayerForm”模板,创建以下两个元素:\n1。一个文本字段的名称属性设置为“playerName”。\n2。提交按钮的值属性设置为“添加球员”。\n模板应该类似于:\n<模板名称= \" addPlayerForm \" >\n<形式>\n< input type = \" text \" name = \" playerName \" >\n< input type = \" submit \" value = \"添加球员\" >\n> < /形式\n< /模板>\n由此产生的界面不会漂亮,但这是我们所需要的。\n87年形式\n一个表单添加球员排行榜。\n88年形式\n“提交”事件\n我们已经见过几个点击事件的例子,我们可以触发执行\n的代码,当用户单击一个特定的元素。同样,还有提交\n事件,它允许触发执行的代码,当用户提交表单。\n为此,创建另一个事件块isClient内部条件:\nTemplate.addPlayerForm.events({\n/ /事件到这里\n});\n(我们需要一个新的事件块,因为这一事件将被附加到新的“addPlayerForm”\n模板,而不是“排行榜”模板。)\n在这个事件块中,创建事件和事件类型设置为“提交”选择器集\n“形式”:\nTemplate.addPlayerForm.events({\n的提交表单:函数(){\n/ /代码在这里\n}\n});\n基于这段代码中,事件的函数时将触发“addPlayerForm”内的形式\n模板提交。\n但是我们为什么不只是使用的单击事件形式?不会大多数用户单击submit按钮\n呢?可能是这样,但重要的是要记住,可以提交表单\n多种方式。在某些情况下,用户单击submit按钮,但其他时候他们会\n点击“返回”键在键盘。通过使用submit事件类型,我们可以考虑\n为每一个可能的方式,可以提交表单。\n确认事件是按预期工作,放置一个控制台。日志声明里面:\n的提交表单:函数(){\n控制台。日志(“形式提交”);\n}\n但事实证明,实际上是一个事件的问题,因为当我们提交表单:\n1。web浏览器刷新页面。\n2。提交的“形式”的信息不会出现在控制台。\n89年形式\n这为什么会发生?\n当我们把一种形式在一个网页,浏览器假设我们想要的数据\n,并将其发送。问题是,当使用流星,我们不想\n发送数据在任何地方——我们想要保持在当前页面——但这不是\n标准行为浏览器而言,web页面刷新。\n知道了这一点,我们必须禁用默认行为,web浏览器连接到表单。\n这需要两个步骤。\n90年形式\n事件对象,第1部分\n从一颗流星应用程序内触发事件时,我们可以访问的信息\n该事件发生。这听起来可能很奇怪,但展示我的意思是,修改提交\n表单事件如下:\n提交表单:函数(事件){\n控制台。日志(“形式提交”);\nconsole.log(event.type);\n}\n在这里,我们通过这个“事件”关键字通过事件的函数的括号,然后\n输出事件的价值。输入到控制台。\n这个结果是双重的:\n首先,任何关键字通过事件的函数的括号作为第一个参数\n变成了一个参考。因为我们通过“事件”关键字,我们\n可以参考事件在事件的函数使用关键字。但是,您可以使用\n您所喜欢的任何一个字。(一种常见的惯例是使用“evt”或“e”而不是“事件”)。\n第二,事件。类型是指的“type”属性事件对象。作为一个结果,\n这段代码应该输出控制台“提交”这个词,因为这是事件的类型\n被触发。\n这并不能解决原来的问题尽管由于我们的页面刷新时表单\n提交,我们不能看到控制台。日志语句。\n为了解决这个问题,使用preventDefault函数:\n提交表单:函数(事件){\nevent.preventDefault();\n控制台。日志(“形式提交”);\nconsole.log(event.type);\n}\n当附加到事件对象,这个preventDefault函数阻止默认行为\n事件的发生。因为我们已经附加函数提交表单事件:\n1。默认情况下,提交表单不会做任何事情。\n2。我们需要手动定义表单的功能。\n3所示。控制台。日志语句现在将正常工作。\n保存文件,切换回Chrome和测试表单,它不再是刷新\n页面。\n91年形式\n控制的形式。\n注意:preventDefault函数不仅适用于形式。例如,你可以\n完全控制的链接在一个模板:\n“点击”:函数(事件){\nevent.preventDefault();\n}\n有了这个代码,模板中的任何一个元素不会像他们通常\n会。你必须手动分配功能。\n92年形式\n事件对象,第2部分\n现在我们已经完全控制的形式,我们希望提交表单的事件的\n“playerName”文本框的内容提交表单时,和使用价值\n添加一个球员到数据库。\n首先,创建一个名为“playerNameVar”的变量:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar;\n}\n然后让这个变量等于“event.target。playerName”和输出变量的值\n控制台:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName;\nconsole.log(playerNameVar);\n}\n这语句使用事件对象获取任何HTML元素的name属性\n设置为“playerName”。\n但这段代码不工作正如你所想的那样,因为控制台。日志语句输出\n的原始HTML文本字段,而不是它的价值:\n抓住整个文本字段。\n这是因为我们需要显式地检索价值属性:\n93年形式\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nconsole.log(playerNameVar);\n}\n基于这种变化,无论用户输入文本字段将“playerName”\n提交表单时输出到控制台。\n文本字段的值出现在控制台。\n提交的播放器插入“PlayersList”收藏,添加里面的插入功能\n提交表单的事件:\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n而不是通过一个硬编码值名称字段,如“大卫”或“Bob”,通过\n通过“playerNameVar”变量的引用。\n现在事件的代码应该类似于:\n94年形式\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n}\n和现在应该像预期的那样工作。\n凯尔被添加到排行榜。\n95年形式\n删除玩家\n自从我们成为可能添加球员排行榜,这是一个好主意让它成为可能\n也从排行榜中删除玩家。\n为了实现这一点,首先创建一个“删除玩家”按钮在“排行榜”模板:\n< input type = \" button \" class = \"删除\" value = \"删除玩家\" >\n与其他按钮在这个项目中,附加一个独特的类属性,我们可以参考\n按钮的事件。\n在JavaScript文件,将下列事件附加到“排行榜”模板:\n的点击。删除”:函数(){\n/ /代码在这里\n}\n检索的ID选择球员的“selectedPlayer”会话:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n然后使用从集合中删除功能,删除选中的球员:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList.remove(selectedPlayer);\n}\n我们还没有谈到了去除函数,但没什么多说的。所有\n我们要做的就是通过文档的惟一的ID作为唯一的参数。该文档\n将从集合中删除。\n用户将可以从列表中删除的球员。\n96年形式\n总结\n在这一章,我们了解到:\n•通过使用submit事件类型,我们可以触发时执行代码是一种形式\n提交。\n•使用提交事件而不是单击事件以来可以提交的一种形式\n许多不同的方式(如“返回”键。)。\n•我们可以从内部访问信息的一个事件,事件的功能,和也\n操纵事件发生。\n•浏览器的默认行为附加到形式,干扰我们的代码,但这一点\n行为与preventDefault函数可以禁用。\n•当表单字段名称属性,有一个简单的语法的价值\n表单字段。\n•通过Mongo文档的ID通过删除功能,我们可以删除\n特定的文档集合。\n流星的更深层次的理解:\n•所以,后提交“添加球员”的形式,“playerName”文本的价值\n字段是重置为空值。\n•创建一个警告,要求用户确认他们是否真的想要删除一个\n球员后从列表中点击“删除的球员”按钮。\n•“分数”字段添加到“添加球员”形式,允许用户定义一个球员的得分\n当他们被提交到列表中。\n在其当前状态查看代码,查看GitHub提交。\n\n\n账户\n我们的应用程序有许多有用的特性,但仍只支持单个球员的名单。\n这意味着只能有一个用户应用程序在任何特定的时间,也就是\n愚蠢的网络应用程序。\n为了解决这个问题,我们将创建一个用户帐户系统,这样是最简单的一个\n我们可以做的事情与框架。\n有了这个系统,我们将使它如此:\n•用户可以注册并登录到应用程序。\n•注销用户不会看到“添加球员”的形式。\n•每个用户将有自己的独特的排行榜。\n它的很多功能,但不会花很多的代码。\n97年\n账户98\n登录供应商\n扩展我们的流星的功能项目在几秒钟之内,我们可以安装一个范围\n包,包基本上是插件:\n1。重要的功能添加到一个项目。\n2。减少我们需要编写的代码量。\n默认情况下,每个流星项目本地访问官方包的数量。这些都是\n包,大多数开发人员需要使用在某种程度上,但不一定\n在每一个项目。(也有成千上万的第三方包,但是他们超出了\n这本书的范围,所以我们将只关注官方包。)\n添加一个用户帐户系统我们的项目,我们将首先安装一个“登录供应商”包。这些\n包使它非常容易为一个账户系统添加一个后端应用程序。\n例如,通常创建一个用户帐户系统将涉及创建一个收集的\n用户的数据:\nuseraccount = new Mongo.Collection(“用户”);\n然后编写应用程序逻辑注册和登录,等等。\n但在处理流星时,所有我们要做的是切换到命令行并运行\n下面的命令:\n流星添加accounts-password\n这里,我们将这个“accounts-password”包添加到项目中。这个包创建\n后端账户系统依赖于电子邮件和密码注册和日志记录\n在。\n账户99\naccounts-password包添加到项目中。\n具体地说,这个包:\n1。创建了一个集合存储注册用户的数据。\n2。为我们提供了一系列有用的功能我们很快就会讨论。\n其他登录供应商包可用,允许用户登录到我们的应用程序\n通过服务像谷歌和Facebook,但因为这增加了一个额外的步骤流程,\n我们专注于电子邮件和密码系统。\n账户100\nMeteor.users\n一旦“accounts-password”包添加到项目中,自动集合\n用来存储数据的注册用户。这个集合被称为流星。用户和它\n工作就像我们可以创建自己的任何集合。\n为了说明这一点,下面的命令输入到控制台:\nMeteor.users\n返回的信息证实,这只是一个普通的集合:\n检查出流星。用户收藏。\n知道了这一点,我们可以使用查找和获取功能集合:\n.fetch Meteor.users.find()();\n但由于没有注册用户,将返回任何数据。\n账户101\n登录界面\n我们已经设置账户的后端系统,但是前端呢?是\n我们将编写接口代码,允许人们注册和登录和改变他们\n帐户详细信息吗?\n不。\n我们可以创建一个定制的界面,它实际上是一个非常简单的事情,但有一个更容易\n办法尽快启动并运行。\n即时向项目添加账户系统的前端,我们只是必须安装\n“accounts-ui”包:\n流星添加accounts-ui\n然后,一旦安装,以下正文标签之间的HTML文件(或在一个\n的模板):\n{ { > loginButtons } }\n这里,我们包括这种“loginButtons”模板,这是包含在“accounts-ui”\n包中。因为这个包被添加到这个项目中,我们现在可以包括这个模板\n任何我们想要的接口。\n看看这个模板包含,保存文件并切换到浏览器。你会注意到一个”的迹象\n出现在“按钮,当点击,一个登录表单和一个“创建帐户”链接将出现:\n账户102\n一个即时的接口。\n虽然这不是一个纯粹的虚拟接口。已经没有任何配置,这是有可能的\n用户注册、登录和注销。没有理由做这些事情——注册\n和非注册用户将看到相同的内容,但这是我们将在未来解决\n部分。\n现在,使用查找和获取函数的流星。用户组:\n账户103\n第一个用户的数据。\n返回你会注意到一个文档,该文档包含的数据\n这是刚刚创建的。您可以单击箭头看到面临的下行数据联系在一起\n该帐户。\n账户104\n登录状态\n目前,未注册用户可以看到“添加球员”形式,不赚很多\n有意义的。这种形式注册用户只能访问。\n为了达到这个目标,改变“addPlayerForm”模板如下:\n<模板名称= \" addPlayerForm \" >\n{ { #如果currentUser } }\n<形式>\n< input type = \" text \" name = \" playerName \" >\n< input type = \" submit \" value = \"添加球员\" >\n> < /形式\n{ { /如果} }\n< /模板>\n在这里,我们指的是这个currentUser对象检查当前用户是否已登录。\n这个对象所提供的“accounts-password”包,和逻辑很简单:\n1。如果当前用户登录,currentUser将返回true。\n2。如果当前用户没有登录,currentUser将返回false。\n因此,只有几行代码,我们使它所以只有登录用户可以\n(相互作用)的形式。\n账户105\n为每个用户分配一个排行榜\n使我们的应用程序有些有用的更广泛的受众,我们需要让每一个\n注册用户可以自己独立的球员名单。它可能不明显\n我们怎么做这个,最困难的一点编程弄清楚吗\n如何处理这样的问题,但这个过程本身不涉及很多步骤。\n首先,下面的语句:\nvar currentUserId = Meteor.userId();\n提交表单事件:内…\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n}\n在这里,我们创建这个“currentUserId”变量,存储返回的值的\n流星。标识功能。我们还没有谈到这个函数,但并不多\n解释一下。它只是返回当前登录用户的惟一ID。\n然后添加一个“createdBy”字段中插入功能,并通过“currentUserId”\n变量:\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n因此,当用户添加一个球员排行榜,该用户的惟一ID\n与玩家相关的补充道。\n为了演示这个:\n1。保存文件。\n2。切换回Chrome。\n3所示。添加一个球员排行榜。\n账户106\n然后使用“PlayersList”上的发现和获取函数集合,并单击downwardfacing\n箭头为最近创建的文档。您将看到如何该文档包含了\n用户的ID此玩家添加到集合中。\n将一个球员与一个用户相关联。\n接下来,我们将修改玩家helper函数:\n“球员”:函数(){\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n首先,设置另一个“currentUserId”变量:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n然后改变返回语句,所以只返回球员当他们createdBy字段是相等的\n当前登录用户的惟一ID:\n账户107\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ createdBy:currentUserId },\n{:{分数:1,名字:1 } });\n}\n这可以确保用户只能看到球员他们添加到排行榜中,从而产生的效应\n,每个用户都有自己的独特的球员名单。\n只看到球员属于当前用户。\n账户108\n项目重置\n目前,有一些球员在数据库没有连接到任何特定的人\n用户——球员被添加到前一节中——这意味着我们之前数据库\n不需要他们在我们集合。\n给自己一个全新的开始,然后,切换到命令行,停止与CTRL本地服务器\n+ C,输入以下命令:\n流星重置\n这将勾销数据库,因为我们写的代码在前一节中,\n此时玩家添加到集合将被附加到当前登录的用户。\n你可能会发现自己使用这个命令半定期,大量无用的数据很容易\n在开发过程中填充数据库。\n账户109\n总结\n在这一章,我们了解到:\n•包让我们迅速向应用程序添加功能。有一些官员\n包,还有成千上万的第三方包。\n•“登录供应商”包来创建一个账户的后端系统。我们可以\n创建一个后端,依赖于电子邮件和密码,或者像Twitter和服务\nFacebook(或服务)的组合。\n•安装登录提供者包之后,一颗流星。用户自动收集\n用来存储数据的注册用户。\n•accounts-ui包允许我们快速添加一个账户系统的用户界面\n一个项目。你可以把一个自定义的方法,但这个样板的方法是伟大的\n对于初学者来说。\n•我们可以检查当前用户是否已登录通过引用curentUser\n对象从一个模板。\n•的惟一的ID来检索当前登录的用户,我们可以使用Meteor.userId()\n函数。\n流星的更深层次的理解:\n•安装一个不同的登录供应商包装,像accounts-twitter包(但\n确定accounts-ui包也是安装)。\n•浏览atmospherejs.com查看很多第三方包\n流星。\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n发布与订阅\n到目前为止,我们已经构建了一个功能丰富的应用程序与流星,但我们没有说什么\n安全,这是一个很大的网络软件开发的一部分。在大多数情况下,我想要的\n向你们展示如何构建尽可能快速和简单的东西,但也有几个\n安全我们应该谈论的话题前发布到web项目。\n首先,让我们来谈谈出版物和订阅。\n110年\n发布和订阅111\n数据安全\n展示我们的项目的一个安全缺陷:\n1。注册两个单独的用户帐户。\n2。每个帐户下,添加三个球员。\n3所示。注销的账户。\n正因为如此,共有6名球员应该存在在数据库和他们应该“属于”\n总共有两个用户。\n下一步,使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n你会注意到,我们以前见过,所有返回的数据收集。我们可以\n看到所有的数据属于两个用户。但这实际上是一个问题。因为除非\n我们关闭这个功能,这个应用程序的每个用户将有同样的,肆无忌惮的访问权\n每一个数据库内的数据。没有什么阻止他们深入挖掘\n“PlayersList”收集的发现和获取功能。\n访问所有的数据。\n这个项目的数据不是特别敏感,它不像我们存储信用卡号码\n——但:\n发布和订阅112\n1。如果我们存储敏感数据,这将是一个不可原谅的监督。\n2。它有害的实践数据提供给用户当它不是必需的。\n然而,这并乞求问题:\n为什么这个功能存在的流星?如果是这样一个巨大的安全风险来访问数据\n通过控制台,为什么允许这样做吗?\n很简单,方便。在本书中,我们已经使用查找和获取\n函数和他们伟大的工具来管理和操作的内容\n数据库。只是,在我们与世界分享应用程序之前,我们必须:\n1。禁用这种默认行为,限制访问的大部分数据。\n2。精确地定义数据应该提供给特定的用户。\n这就是我们将讨论接下来的章节。\n发布和订阅113\nautopublish\n功能,允许我们使用控制台导航项目的数据\n包含在一个“autopublish”包包含在默认情况下每个流星项目。\n如果我们删除这个包,用户无法通过控制台访问任何数据,但它\n也将打破应用程序,因此我们需要采取一些额外的步骤。\n删除“autopublish”包从项目,运行以下命令:\n流星删除autopublish\n如果你登录的用户帐户删除包的时候,你不会注意到\n任何不同,但尝试发现和获取功能:\n.fetch PlayersList.find()();\n你会注意到我们再也不能浏览里面的数据集合。唯一的\n返回一个空数组。它看起来像数据已被删除,但事实并非如此。\n它只是被获得。\n现在问题是,我们的数据安全,因为如果我们登录的用户帐户,\n数据也无法访问的接口:\n没有可用的数据。\n为了解决这个问题,我们需要找到一些我们面临的两个极端——之间的中间立场\n一切都被访问和没有被访问。这涉及到精确的定义\n数据应该提供给我们的用户。\n发布和订阅114\nisServer\n在本书中,我们主要是在isClient条件编写代码。这是\n因为我们大多写的代码意味着浏览器内运行(如代码\n影响界面)。然而,很多情况下我们希望代码运行\n在服务器上。\n为了演示这些情况之一,地方在isServer如下声明\n在JavaScript文件的条件:\n.fetch console.log(PlayersList.find()());\n不出所料,输出出现在命令行(而不是控制台),但要注意\n我们没有任何麻烦检索“PlayersList”收集的数据。即使在\n删除“autopublish”计划,我们有自由统治的数据直接在工作\n与服务器。\n为什么?\n嗯,在服务器上执行的代码本身是可信的。所以,当我们停止用户\n应用程序访问数据的前端——在客户端——我们可以继续\n在服务器上检索数据。\n你很快就会知道这个细节的有效性。\n发布和订阅115\n出版物,第1部分\n在本节中,我们将发布“PlayersList”内的数据收集,和\n从概念上讲,你能想到的出版数据传输数据到从服务器\n醚。我们只是指定哪些数据应该提供给用户。我们不关心的地方\n最终的数据。\n为了实现这一点,删除控制台。日志声明isServer条件和替换它\n一颗流星。发布功能:\nMeteor.publish();\n这个函数的括号之间,通过“应”作为第一个参数:\nMeteor.publish(球员);\n这个论点是一个名字,我们会参考。\n然后,作为第二个参数,通过一个函数:\n流星。发布(“球员”,函数(){\n/ /内部发布功能\n});\n在这个函数,我们指定哪些数据应该提供给应用程序的用户。\n在这种情况下,我们将返回所有的“PlayersList”收集的数据:\n流星。发布(“球员”,函数(){\n返回PlayersList.find()\n});\n这段代码复制autopublish的功能,这意味着它不是我们什么\n想要的,但这是一个正确方向的一步。\n发布和订阅116\n订阅\n因为流星。发布在服务器上执行的函数,我们现在可以订阅\n这些数据在isClient条件,再一次做项目的数据访问\n通过浏览器和控制台。\n如果你想象一下,发布功能是传输数据到醚,然后订阅\n函数是我们使用“捕捉”数据。\n在isClient条件,写如下:\nMeteor.subscribe();\n这是流星。订阅功能,唯一的参数,我们需要通过\n发布函数的名称:\nMeteor.subscribe(球员);\n保存文件,然后使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n你会注意到,再一次,我们可以访问所有的数据从项目的数据库,\n意味着我们的应用程序是回到原来的状态。这还不是我们想要的,但这是另一个\n重要的一步。\n发布的所有数据。\n发布和订阅117\n出版物,第2部分\n现在的目标是让流星。发布函数只从服务器发布数据\n属于当前登录的用户。\n这意味着:\n1。登录用户只能访问自己的数据。\n2。注销用户没有访问任何数据。\n最后,应用程序将全功能保护潜在的敏感\n数据。\n为了达到这个目标,我们需要访问当前登录用户的惟一ID从内\n流星。发布功能。在这个函数,我们不能使用Meteor.userId()\n之前的功能。相反,我们必须使用下面的语句:\nthis.userId;\n虽然语法是不同的,最终的结果是一样的。该语句返回唯一的\n当前登录用户的ID。\n声明在“currentUserId”变量:\n流星。发布(“球员”,函数(){\nvar currentUserId = this.userId;\n返回PlayersList.find()\n});\n然后改变找到函数只所以检索文档createdBy字段是相等的\n当前登录用户的ID:\n流星。发布(“球员”,函数(){\nvar currentUserId = this.userId;\nPlayersList返回。找到({ createdBy:currentUserId })\n});\n保存文件,然后使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n如果你登录,您只会看到的数据属于当前用户的帐户,如果\n你没有登录,你不会看到任何数据。这是因为内部的返回语句\n流星。发布函数只能返回文档,包含当前的惟一ID\n用户。\n发布和订阅118\n返回一个有限选择的数据。\n也知道,我们现在可以简化玩家从这个函数:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ createdBy:currentUserId },\n{:{分数:1,名字:1 } });\n}\n…:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n为什么?\n因为球员内部的返回语句函数只能检索数据\n从服务器发布。因此,指定要检索用户的数据\n两个地方是多余的。我们只需要定义Meteor.publish中返回的数据\n函数。\n发布和订阅119\n总结\n在这一章,我们了解到:\n•在默认情况下,所有的数据在一个流星项目的数据库提供给所有用户\n应用程序。这是方便的在开发期间,但它也是一个很大的安全漏洞\n需要在部署前固定。\n•这个默认功能都包含在一个“autopublish”包。如果我们删除这个\n计划,项目将更安全,但它也会打破,需要固定的。\n•流星。发布函数定义哪些数据应该在服务器端\n提供给应用程序的用户。\n•流星。订阅功能是用于客户端检索的数据\n从服务器发布。\n•在发布功能,我们不能使用Meteor.userId()函数,但我们可以\n与this.userId检索当前用户的ID。\n在其当前状态查看代码,查看GitHub提交。\n\n\n方法\n在前面的章节中,我们讨论的第一个包含两个主要的安全问题\n每颗流星项目默认情况下。这个问题是用户通过导航的能力\n所有的数据在数据库内部,直到我们把“autopublish”包。基于这些\n我们做了改变,用户现在只有访问“属于”的数据。\n为了演示第二个主要安全问题,输入以下命令控制台:\nPlayersList。插入({ name:“伪玩家”,分数:1000 });\n看有什么问题吗?\n虽然我们已经取得了它所以用户不能浏览所有的数据在数据库中,用户\n仍然能够自由使用控制台插入数据到数据库中。这意味着用户可以:\n1。利用应用程序自己的优势。\n2。数据库填充无用的、多余的数据。\n用户还能够从数据库修改和删除数据,意味着在默认情况下,\n他们主要有完全的管理权限。\n与前面的安全问题,这个特性是当我们开发一个方便\n应用程序,因为它很容易创建和管理数据,但这是一个我们需要的特性\n关闭之前部署。\n此功能包含在一个“没有安全感”包,我们可以删除它\n项目使用下面的命令:\n流星消除不安全的\n删除包后,切换回Chrome和尝试和应用程序。\n你会注意到:\n•我们再也不能给分的球员。\n•我们再也不能拿分的球员。\n•我们再也不能从列表中移除玩家。\n•我们再也不能将玩家添加到列表。\n所有的插入、更新和删除功能停止工作——都通过\n接口和控制台应用程序,所以更安全的结果,但是我们会有\n解决很多事情。\n120年\n方法对121\n创建一个方法\n直到这个时候,所有的插入、更新和删除功能已经在isClient\n有条件的。这是快速和容易的方法,但这也是为什么我们的应用程序\n天生没有安全感。我们已经把这些敏感,clientside数据库驱动的功能。\n更安全的做法是将这些函数isServer条件,也就是说:\n1。数据库代码将执行服务器的可信的环境中。\n2。用户无法使用这些函数从控制台,因为用户没有\n直接访问服务器。\n为了实现这一点,我们将创建我们的第一个方法,方法执行的代码块\n在服务器上被触发后从客户端。如果这听起来奇怪,不要害怕。这是\n其中的一次,之后在写出代码将帮助解释很多。\n在isServer条件,写如下:\nMeteor.methods({\n/ /方法去这里\n});\n这是我们将使用代码块来创建我们的方法。你会发现语法很相似\n我们如何创建两个助手和事件。\n为了演示什么方法,创建一个“sendLogMessage”的方法:\nMeteor.methods({\n“sendLogMessage”\n});\n然后将该方法与功能:\nMeteor.methods({\n“sendLogMessage”:函数(){\n控制台。日志(“Hello world”);\n}\n});\n接下来,“电话”这个方法从底部的提交表单事件附加到“addPlayer -\n形成“模板:\n方法对122\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.playerName.value;\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\nMeteor.call(“sendLogMessage”);\n}\n通过使用这颗流星。调用语句,通过我们创建的方法的名称,\n我们能够触发方法时的执行“添加球员”提交表单。\n保存文件,切换回Chrome,并提交“添加球员”形式。核心功能\n这种形式的仍然是破碎的,但是如果你切换到命令行,您将看到“Hello\n世界”的消息似乎每次提交表单。客户端表单的提交\n触发的方法,但实际代码的方法是在服务器上执行。\n代码在服务器上执行,导致当我们提交表单。\n这个基本原则是我们在本章的其余部分使用。\n方法对123\n插入数据(再一次)\n再次让应用程序工作,我们首先将插入函数里面提交\n表单事件从客户机和服务器。\n这意味着:\n1。插入函数将成功地和安全地运行在服务器上。\n2。用户仍然无法通过控制台插入数据。\n换句话说,“添加球员”提交表单时,插入函数将触发\n服务器从客户端触发后。\n首先,“sendLogMessage”方法的名称更改为“insertPlayerData”,和摆脱\n控制台。日志语句:\nMeteor.methods({\n“insertPlayerData”:函数(){\n/ /代码在这里\n}\n});\n在方法内部,抓住当前登录用户的惟一ID:\nMeteor.methods({\n“insertPlayerData”:函数(){\nvar currentUserId = Meteor.userId();\n}\n});\n然后下面添加一个熟悉的插入函数声明:\nMeteor.methods({\n“insertPlayerData”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:“大卫”,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n这里,我们通过一个硬编码值的“大卫”,这并不是我们所想要的,\n但这已经足够好了。\n返回到提交表单事件和删除currentUserId变量和插入\n函数。事件应该类似于:\n方法对124\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nMeteor.call(“sendLogMessage”);\n}\n但也一定要通过正确的方法名流星。调用语句:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nMeteor.call(“insertPlayerData”);\n}\n基于这些变化,“添加球员”形式将现在的工作。如果我们提交表单,\n一个球员将被添加到“PlayersList”集合。我们只能添加球员叫“大卫”,\n但在下一节我们将解决这个问题。\n再次插入函数的工作。\n现在,重要的是,用户可以添加玩家通过列表形式,\n他们不能够使用插入函数从控制台。这意味着我们获得\n控制用户如何与数据库的交互,这是一个保持应用程序的重要组成部分\n安全。\n方法对125\n传递参数\n“添加球员”形式的问题是文本字段的值没有被传递到\n该方法。这样,当我们提交表单时,创建的球员的名字将永远\n被设置为“大卫”。\n为了解决这个问题,通过“playerNameVar”变量通过流星。调用语句作为第二\n论点:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\n流星。调用(insertPlayerData,playerNameVar);\n}\n然后允许接受这个论点的方法通过将“playerNameVar”之间\n括号的方法的功能:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:“大卫”,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n正因为如此,我们现在可以参考“playerNameVar”参考用户的价值\n进入表单的文本字段:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n最后,这是发生了什么:\n方法对126\n首先,当提交表单时,“insertPlayerData”方法被调用时,和的值\n表单的文本字段附加到电话。\n第二,执行“insertPlayerData”方法。该方法接受的价值\n“playerNameVar”变量,然后从里面引用变量方法的功能。\n第三,插入函数内执行方法,因为这段代码运行在服务器上,\n它可以运行没有“安全感”包。与刚才不同,这个函数使用价值\n来自表单的文本字段,而不是硬编码的“大卫”的价值。\n创建的球员与原名称。\n表单将再次工作的预期,但仍然会是没有为用户操作方法\n数据通过控制台。\n方法对127\n删除玩家(再一次)\n以同样的方式,我们创建了一个“insertPlayerData”变量,我们要创建一个“removePlayerData”\n方法,我们将连接到“删除的球员”按钮,里面是我们的接口。\n就像我们如何创建助手和事件,我们的位置在一个代码块的方法,\n记住要用逗号分开的方法:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n},\n“removePlayerData”:函数(){\n/ /代码在这里\n}\n});\n然后我们会点击两个变化。删除事件:\n首先,去掉删除功能:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n在它的位置,创建另一个流星。调用语句:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nMeteor.call(“removePlayerData”);\n}\n通过“selectedPlayer”变量,第二个参数:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(removePlayerData,selectedPlayer);\n}\n允许接受这个论点的方法:\n方法对128\n“removePlayerData”:函数(selectedPlayer){\n/ /代码在这里\n}\n然后重新创建删除方法内部的函数:\n“removePlayerData”:函数(selectedPlayer){\nPlayersList.remove(selectedPlayer);\n}\n“删除玩家”按钮将按预期工作,但用户仍然没有完成\n管理访问数据库相关函数在控制台。\n清除旧数据。\n然而,一个挥之不去的问题…\n因为“removePlayerData”方法执行从客户端,用户可以执行\n同样的自称,从控制台:\n流星。调用(' removePlayerData ',' 8 sad8a90d8s9ad ');\n因此,尽管他们没有获得全方位的插入、更新和删除功能\n能做的,他们仍然可以做一些伤害。例如,他们可以运行这个命令来删除一个\n玩家从另一个用户的列表。\n这不是一个悲剧的巨大的安全漏洞,但这是我们应该解决的\n准备在未来安全漏洞。\n最好的做法是改变“removePlayerData”从这个方法:\n方法对129\n“removePlayerData”:函数(selectedPlayer){\nPlayersList.remove(selectedPlayer);\n}\n…:\n“removePlayerData”:函数(selectedPlayer){\nvar currentUserId = Meteor.userId();\nPlayersList。remove({ _id:selectedPlayer createdBy:currentUserId });\n}\n有了这段代码,该方法将只允许玩家从列表中被删除\n球员属于当前用户。\n注意:你可能会认为它不太可能用户会让这样一个混乱与另一个\n用户的排行榜,但当涉及到安全,最好不要低估人民的能力\n和渴望肆虐。\n方法对130\n修改分数\n在这一章,我们已经使用方法为了安全,但我们也可以使用\n方法来减少我们的项目代码的数量。\n为了说明这一点,我们要结合点击。增加并单击。衰减事件\n成一个单一的方法。这是有可能的,因为有很多的这些事件之间共享代码:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n},\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n事实上,唯一的区别是在点击。增加事件,我们传递一个值\n通过公司操作符“5”,而在点击。衰减事件,我们通过\n一个“5”的价值。\n改善这段代码中,我们首先关注点击。增量的事件。\n在事件中,删除更新函数,代之以一个流星。调用语句:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(modifyPlayerScore,selectedPlayer);\n}\n这里,我们称之为“modifyPlayerScore”的方法,这是一个我们将创建方法\n时刻,我们通过“selectedPlayer”变量。\n创建内部的“modifyPlayerScore”方法方法:\n“modifyPlayerScore”:函数(){\n/ /代码在这里\n}\n…,让这个方法接受的价值“selectedPlayer”:\n“modifyPlayerScore”:函数(selectedPlayer){\n/ /代码在这里\n}\n然后,在该方法的功能,重新创建更新函数,我们刚才删除:\n方法对131\n“modifyPlayerScore”:函数(selectedPlayer){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n基于此代码,“给5分”按钮将正常工作。使更多的方法\n不过,灵活返回点击。增加事件和通过“5”的第三个参数\n流星。调用语句:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(‘modifyPlayerScore selectedPlayer 5);\n}\n允许接受这个第三个参数的方法:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n取代“5”的价值,在这个新创建的引用的方法\n“scoreValue”属性:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });\n}\n由于这一变化,现在的方法是足够灵活,我们可以用它来“给\n5分”按钮和“5分”按钮。\n这里有…\n首先,从内部点击删除更新函数。衰减事件:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n第二,一颗流星。调用语句在这个事件:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nMeteor.call(“modifyPlayerScore”);\n}\n第三,通过“selectedPlayer”变量的值:\n方法对132\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(modifyPlayerScore,selectedPlayer);\n}\n第四,通过“5”的价值,而不只是“5”:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(‘modifyPlayerScore selectedPlayer 5);\n}\n看到我们所做的吗?\n我们已经取得了如此“modifyPlayerScore”方法的效用取决于我们通过\n第三个参数:\n1。如果我们通过一个“5”,更新函数增量的值\n“分数”字段。\n2。如果我们通过一个“5”,更新函数递减的价值\n“分数”字段。\n因此,该方法允许代码既灵活又安全。\n我们有相同的安全缺陷前一节中,一个用户可以输入\n下面的命令在控制台修改数据库中的任何球员的得分:\n流星。调用(‘modifyPlayerScore’,‘8 sad8a90d8s9ad’,100);\n但解决方案也是一样的。\n从这只改变方法的内容:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });\n}\n…:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nvar currentUserId = Meteor.userId();\nPlayersList。更新({ _id:selectedPlayer createdBy:currentUserId },\n{ $ . n:行情):{得分:scoreValue } });\n}\n再次,我们检索当前登录用户的惟一的ID,并在更新\n正在更新功能,确保玩家“属于”用户。如果登录用户\n并不“拥有”的球员,球员的文档不会被发现的更新功能。\n方法对133\n总结\n在这一章,我们了解到:\n•在默认情况下,有可能为用户插入、更新和删除数据的收集\n使用JavaScript控制台。这对于开发方便,但存在安全风险\n部署web应用程序。\n•修复这个安全风险,我们必须从客户端数据库相关代码,\n服务器的信任的环境。在这里,用户不会有任何直接访问(或\n控制)数据库。\n•这个安全风险是包含在一个“没有安全感”包。通过移除这个包,\n应用程序将变得更加安全,但它也会休息,因为没有一个databaserelated\n功能将工作。\n•通过使用方法,我们能够编写代码在服务器上运行后第一个被触发\n从客户端。这是我们如何修复项目的破碎功能。\n•创建方法,我们可以在方法中定义块,然后触发\n从其他地方的代码使用流星。调用语句。\n•我们可以从流星传递数据。调用语句和方法,让我们\n使用提交的数据表单内的方法。\n•用户可以执行客户端流星。通过控制台调用语句,所以我们需要\n注意这些语句允许用户做什么。\n•方法不仅适用于安全。他们也有用结合相似的块\n的功能到一个小的和可重复的代码片段。\n流星的更深层次的理解:\n•在一个新项目,首先删除“不安全”计划,从一开始,地方\n里面所有的数据库相关代码的方法。\n在其当前状态查看代码,查看GitHub提交。\n\n\n结构\n在本书中,我们把所有的项目的代码仅仅三个文件:\n•leaderboard.html\n•leaderboard.js\n•leaderboard.css\n这使得我们关注的基本面与流星没有构建软件\n担心代码是如何组织的,该项目是非常简单的,所以我们需要不\n需要其他文件,但:\n1。在构建大型应用程序,是有意义的传播项目的代码在一个\n数量的文件。\n2。流星有许多公约组织项目的文件。\n在我们继续之前,有两个问题需要考虑:\n首先,流星没有硬性规定如何构造一个项目。有\n流星鼓励某些准则,但没有严格的,你必须做的。你的喜好\n最终在控制。\n第二,人们仍然找出最佳实践在处理流星。因此,\n没有理由形式教条的观点项目“应该”是如何构造的。允许\n自己的实验。\n这一章也不同,我们不会重组项目step-bystep排行榜。\n相反,我们将讨论结构的原则,这些原则,这就是你的工作\n付诸实践。\n不过别担心。\n基于我们覆盖到目前为止,处理如何构造一颗流星\n应用程序将是小菜一碟。\n134年\n结构135\n你的项目,你的选择\n就像我说的,流星没有硬性规定如何组织一个项目。它不\n关心如何组织你的文件和文件夹,如果你想创建一个大型项目\n只是三个文件,你可以。\n不过,与这种灵活性带来选择的矛盾:\n如果你不局限于精确的规则,如何构建您的项目吗?\n如果你是一个开发人员开始,您的项目结构尽可能简单的只要你\n可以。这意味着传播您的代码在仅仅三个文件——HTML,JavaScript,和CSS\n文件,直到这些文件变得过于臃肿的轻松地管理。这是罕见的一个实际的应用\n包含在这样一个小结构,但如果你只是开始使用流星,它是\n不生产为“完美”的结构。\n仍然阅读这一章,有一些重要的约定要注意——但不要\n觉得有必要实现每一个细节。最佳实践更容易学习一次\n基本面已经吸收了,只要你是一个初学者,你可以变得很糟。\n如果你不是一个开发人员,这意味着开始,如果你有网站开发经验,\n和没有任何麻烦连同这本书,那么你会有一个简单的时间\n实现约定我们要讨论。\n结构136\n脂肪薄文件,文件\n当创建一个流星应用程序时,项目的文件可以作为“瘦”或“脂肪”,因为我们想要的\n他们是。这意味着:\n1。我们可以传播许多文件的代码。\n2。我们可以包很多每个文件(或小)代码。\n例如,让我们考虑一下”排行榜。html文件。不是脂肪,但它确实包含了\n三个组件,虽然连接,不需要包含在单一文件:\n•页面的HTML结构(头部标签,身体标签等)。\n•“排行榜”模板。\n•“addPlayerForm”模板。\n如果这个项目变得越来越大,这将使这些组件拆分为三个\n单独的文件。例如,你可能会想:\n1。离开的HTML结构”排行榜。html文件。\n2。把“排行榜”的“leaderboardList模板。html文件。\n3所示。移动模板,一个“addPlayerForm addPlayerForm。html文件。\n因此,它会更容易导航项目的文件因为每个文件的名称\n暗示这文件包含什么。\n需要澄清的是:\n1。没有额外的步骤。把代码项目,无论你想要的\n流星将知道如何把片段组合在一起。\n2。文件名称是任意的。有一些“特殊”的文件名需要注意的,但是\n一般来说,名字的文件,只要你喜欢就好。\n你也可以将文件在文件夹和子文件夹(深层结构),但在那里\n某些约定,鼓励某些命名这些文件夹的方法。\n结构137\n文件夹的约定,第1部分\n很多内部的代码”排行榜。js”isClient条件内的文件。如果我们传播\n这段代码在多个文件,它会不雅的重用这个条件\n一次。\n幸运的是,流星已经约定,任何的代码放在一个文件夹命名为“客户端”\n只会在客户端上运行。\n为了演示这个:\n1。创建一个文件夹命名为“客户”在您的项目的文件夹。\n2。在该文件夹中创建一个JavaScript文件。\n3所示。剪切和粘贴的客户端代码”排行榜。js文件到新的文件,但是\n没有isClient条件。\n在保存文件时,应用程序将继续正常工作。\n因为这个约定,最好是将模板,事件,助手,Meteor.subscribe\n函数在一个“客户端”文件夹中。\n相反,流星有约定的任何代码放置在一个文件夹命名\n“服务器”只会在服务器上运行。这是我们地方项目的方法,和\n流星。发表声明。\n洗牌代码在排行榜内部应用程序之后,唯一的,左内\n原始”排行榜。js文件将被声明,创建“PlayersList”集合。我们\n希望这段代码运行在客户端和服务器,所以一定要离开这个声明\n在“客户机”和“服务器”文件夹。一个常见的惯例是将这段代码在一个\n”集合。js文件,但是这个文件名字没有特别的意义。\n结构138\n文件夹约定,第2部分\n当开始使用流星,大多数项目的文件可能会在“客户端”\n或“服务器”文件夹。然而,一些其他的文件夹名称,可用于不同的\n用途:\n•文件存储在一个“私人”文件夹只能访问的代码的执行\n服务器。这些文件将永远不会访问用户。\n•文件存储在一个“公共”文件夹是游客服务。这些文件是图片,图标,\n和“机器人。txt文件。\n•文件存储在一个“自由”文件夹其他文件之前加载。\n但如果这一切似乎记得太多,不要害怕。这些细节是值得了解的\n未来的参考,但这将是一段时间你需要付诸实施了。目前,\n很好关注基础知识。\n结构139\n样板结构\n学习如何结构的一种有效方式流星项目向其他开发人员学习\n有可能遇到的许多问题有一天,你会遇到你。\n例如,“铁”工具从克里斯事件化思想的源泉:\n命令行脚手架流星应用程序的工具。它会自动创建\n项目的结构,文件和样板代码。\n这个工具可以用来快速创建一个项目使用以下结构:\n我的app /\n.iron /\njson\nbin /\n构建/\n配置/\n开发/\nenv.sh\nsettings.json\napp /\n客户端/\n集合/\nlib /\n样式表/\n模板/\nhead.html\nlib /\n集合/\n控制器/\nmethods.js\nroutes.js\n包/\n私人/\n公共/\n服务器/\n集合/\n控制器/\nlib /\nmethods.js\npublish.js\nbootstrap.js\n你会发现每件事都有它的位置。有文件夹集合和样式表\n模板和其他组件的一个项目。\n结构140\n这是最好的方法构造一颗流星项目吗?\n对一些人来说,它可能是。\n我认为这有点复杂的人与流星刚刚开始,但当\n你准备搬到一个更大的项目,它可能正是你需要管理\n较大的基础代码。\n在这个阶段,重点不是做出任何硬性的决定对你的偏好。但它\n帮助了解什么至少是可能的。\n其他样板值得一试,学习包括meteor-boilerplate和空白。\n结构141\n总结\n在这一章,我们了解到:\n•流星并不在项目执行精确的文件结构。有简单的约定\n我们鼓励遵守为了我们自己的利益。\n•通过命名特定文件夹,在某些方面,我们能够避免编写一些应用程序\n逻辑基于流星如何处理这些文件夹。\n流星的更深层次的理解:\n•搜索别人的流星在GitHub,看看真实的项目\n应用程序的结构。\n•想象你创建一个博客应用程序像WordPress。你会如何结构\n该应用程序?计划在一张纸上。\n在其当前状态查看代码,查看GitHub提交。\n\n部署\n在本书中,我们取得了很多的进步。我们决定在项目建设,创建\n所有的基本功能,添加了一些额外的细节,甚至谈到了几个\n常见的安全问题。\n因此,我们准备部署到web的应用程序。\n在这里我们可以分享我们的创造与世界然后等待成群的陌生人\n奇迹在我们的天才。但部署并不是简单的上传文件到web服务器。\n有更多的参与。\n这是一个广泛的部署过程的概述:\n1。创建一个服务器DigitalOcean等网站。\n2。在该服务器上安装所需的软件(节点,MongoDB,等等)。\n3所示。配置所有的安装软件。\n4所示。项目的文件上传到服务器。\n5。交叉你的手指,没有休息。\n听起来很复杂,对吗?\n不要担心,我有你覆盖。\n在这本书的前两个版本,我解释的绝对基础部署流星\n应用程序web但已经放在一起更全面的指导,分开\n从这本书。\n你可以免费在线阅读:\nmeteortips.com/deployment-tutorial\n如果你想尽快部署的东西,你只需要阅读第一\n两个章,但是当你准备发射比throwntogether更有趣的东西\n轻轻原型,这本书将指导您完成每一步的过程中,\n与其他我发布在网上,你也可以看到很多的更新\n部署实践的变化和发展。\n也就是说,如果你不希望将应用程序部署到世界,这很好。\n没有什么关于部署,你需要知道这一点。这个过程是相当\n开发过程和截然不同的东西,直到你已经开发了应用程序,你的\n时间是更好的在一个文本编辑器,编写代码,使事情。\n142年\n结论\n祝贺你。你已经达到了这本书的最后一页。在第一章,就像我说的\n这本书不是汤姆。有更多了解建筑与流星很酷的东西\n框架。\n这就是我建议:\n1。如果你还没有,实际上我们已经构建排行榜应用程序\n讨论这本书。没有更好的方法来学习如何比通过编写代码\n每一行,循序渐进。\n2。看流星的官方文档。你可能不理解每一点\n它,但它确实提供了洞察如何以及为什么某些特性工作的方式做。\n3所示。遵循“如何正确学习流星”的路线图。这是一个彻底的课程\n成为一个全面的流星开发者(那就推荐这个\n书)。\n如果你还没有,请访问meteortips.com并注册电子邮件时事通讯。这是\n最好的方法是不管我工作,帮助你做出更大、更快\n进步与流星。\n这就是现在。\n祝你好运,和说话很快。\n€”大卫·特恩布尔\n注:如果你喜欢这本书,在Amazon.com上留下评论。你的支持让我\n花更多的时间来研究新材料。","source":"_posts/Meteor-2.md","raw":"---\ntitle: 项目\ntags: 你的第一个Meteor应用\nabbrlink: 51156\ndate: 2016-12-09 09:24:44\n---\n\n\n### 项目\n\n刚开始学习如何编制Web应用的开发者的一个大错误是在对要创建的东西还没有一个清淅的认识时就开始进行。但这就像开车去一个新的目的地却没有地图。你可能会在正确的方向有一个小的进展,但你可能不会到达你需要去的地方。你不需要从一开始就知道一切,但你的确至少需要一个方向。\n\n记住这一点,我们要构建Leaderboard(排行榜)——Meteor开发团队设计的一个示例应用程序展示Meteor用很少的几行代码能做什么。\n这就是它看起来的样子:\n\nLeaderboard已经在官网上已经被更高级的例子取代了,但它会是我们的示例项目,主要有两个原因:\n首先,这个应用程序已经存在。我们可以玩,这意味着我们可以在我们编写单行代码前对我们试图创建的应用有一个好的认识。\n第二,应用程序很简单。这意味着我们不需要担心构建软件的概念(这通常是最困难的一部分)。相反,我们可以集中学习Meteor本身。\n\n要获得实际的时间和排行榜,请访问leaderboard2.meteor.com,点击,注意其核心特征:\n- 有玩家的列表。\n- 每个球员都有一个分数。\n- 球员得分排名。\n- 你可以选择玩家通过点击它们。\n- 你可以增加一个选择球员的得分。\n\n在后面的章节中我们将创建附加功能,但即使相对较短的列表也涉及许多Meteor的核心功能。\n\n\n### 创建一个项目\n\n创建我们的第一个Meteor应用程序,我们将需要创建我们的第一个项目,一个项目是一组自包含的文件表单应用程序的基础。您可以使用单词\n“project”和“application”互换使用,但在谈到被开发的应用时“project”会更合适。\n每个项目都是不同的,但是一般会包含:\n- HTML文件,创建接口。\n- CSS文件,指定样式的界面。\n- JavaScript文件,定义应用程序逻辑。\n- 文件夹,确保都是组织良好的。\n\n一个项目可以包含其他类型的文件,如图片和CoffeeScript文件,但在这本书中我们会尽可能保持简单,只展示我们需要的。\n\n在我们创建Leaderboard应用项目前,让我们创建一个文件夹来存储我们的Meteor项目。我们不是必须这样做,但为了保持的东西\n有条理，这是一个好主意。\n\n当然,我们可以选择“新建文件夹”选项从“文件”菜单,但这哪儿有乐趣?相反,输入以下命令行:\n\n\tmkdir Meteor\n\n然后点击“回车”键。\n\n\n使用mkdir命令创建一个文件夹。这mkdir命令代表“目录”,从这个名字你可能猜到,它允许我们做出一个目录。\n\n在这个实例中,我们创建一个名为“Meteor”的目录,但是您可以调用任何你想要的文件夹。的精确位置的文件夹就会出现将取决于你操作系统,但至少在Mac OS X上,将出现在“家”的文件夹目录\n默认情况下。(如果你找不到文件夹,创建简单的搜索你的电脑。)\n一旦准备好了目录,导航到它使用下面的命令:\n\n\tcd Meteor\n\ncd命令代表“改变目录”命令行相当于在图形界面中双击一个目录,按下“回车”键后,我们将在“Meteor”目录。\n\n导航到“Meteor”文件夹。\n\n然后在这个目录中创建一个Meteor项目,运行如下命令:\n\n\tmeteor create leaderboard\n\n这个命令有三个部分:\n- meteor部分定义这是一个meteor命令。\n- create部分澄清,我们想创建一个meteor项目。\n- leaderboard的部分是我们分配给项目的名称。\n\n运行此命令后,会出现一个“leaderboard”目录内的“meteor”文件夹,默认情况下,该文件夹将包含三个文件:\n\n- leaderboard.html\n- leaderboard.css\n- leaderboard.js\n\n它还包含一个隐藏文件夹.meteor,但如果您的操作系统从视图中隐藏了这个文件夹,这很好。我们不会碰它。\n\n在我们的项目的文件夹\n\n\n\n### 本地服务器\n\nWeb应用程序不像静态网站。我们不能只是打开leaderboard.html文件就奇迹的看到一个动态的Meteor的动态应用程序。事实上,如果我们在Chrome浏览器打开该文件,所有我们会看到的是一些静态文本:\n\n\n没有什么动态。\n\n\n要得到我们计划中的web应用程序,我们需要启动所谓的本地服务器。这是一个web服务器,在我们的本地机器上运行。它包含在Meteor中并允许\n我们:\n\n\t1.看到我们的JavaScript代码的处理结果。\n\t2.在我们的本地机器上运行一个数据库。\n\n\n如果你使用一个应用程序像MAMP部署PHP和MySQL,这将是熟悉,但如果这一切听起来可怕,不要害怕。在实践中,这很简单。\n通过命令行中,导航到“leaderboard”目录中:\n\n\tcd leaderboard\n\n然后输入以下命令:\n\n\tmeteor run\n\n这里,meteor的部分定义了这是一个meteor命令，run部分阐明了我们要采取的精确行动。在这种情况下,我们想要运行本地服务器。\n\n\n启动本地服务器。\n\n\n利用“回车”键后,将显示如下:\n\n\t=>Started proxy.\n\t=>Started MongoDB.\n\t=>Started youApp \n\t=>running at: http://localhost:3000/r app.\n\n\n\n\n这些线确认本地服务器启动和URL的最后一行- http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。\n\n\n导航到该URL在Chrome和注意,我们不再看到静态文本。相反,我们看到一个功能的web应用程序。应用程序本身是代码的结果这是包含在每个流星项目默认情况下,这并不是最有趣的创造在世界上,但是我们仍然在正确的方向上迈出了一步。\n\n\n\n这是默认的流星的应用程序。\n不断地查看代码的结果,我们需要保持本地服务器运行。这个简单的\n那就意味着要离开命令行打开从这一点开始。然而,您将需要打开\n一个单独的标签或窗口进一步写命令:\n一个单独的运行命令的选项卡。\n在本地服务器停止,要么退出命令行,或命令行焦点,\n项目22\n在你的键盘上按CTRL + C。然后再次启动本地服务器,使用相同的命令\n之前:\n流星跑\n只要确保你在一个项目的文件夹在运行命令之前。\n项目23\n默认应用程序\n默认应用程序没有什么特别的,但是如果我们点击“点击我”按钮,这个号码\n在屏幕上就会增加。这提供了一个相当普通的流星的实时演示\n特性。这个应用程序背后的代码,但是,不正是重要的因为我们将讨论\n在接下来的章节更大范围。\n目前,打开项目文件和删除所有的默认代码。甚至不看看\n代码。刚刚摆脱它。我们想要从一个完全空白。\n一旦完成,在JavaScript中输入以下文件:\n控制台。日志(“Hello world”);\n然后保存文件并打开JavaScript控制台在铬:\n1。单击视图菜单。\n2。悬停在开发人员选择。\n3所示。选择JavaScript控制台选项。\n窗格的底部将打开浏览器并显示“Hello world”我们的文本\n通过控制台。日志语句。\n“Hello World”的文本出现在JavaScript控制台。\n项目24\n如果这是熟悉的,很好。如果不是,那么知道控制台。日志语句用于看到输出结果\n不创建一个接口的代码显示输出。这意味着,在我们投资\n时间为创建一个接口,我们可以:\n1。确认我们的代码是按预期工作。\n2。尽快修复任何错误出现。\n我们还可以使用控制台操作应用程序的数据库,这是我们要做的\n下一章。\n离开控制台打开从这一点开始,但是随时删除控制台。日志语句\n在JavaScript文件。\n项目25\n总结\n在这一章,我们了解到:\n•当学习如何构建一个web应用程序,重要的是要有一个清晰的认识\n你想构建。\n•命令行可以用来迅速达到熟悉的任务,如创建文件夹和\n他们之间导航。\n•开发流星应用程序时,我们将它作为一个“项目”,我们可以创建一个\n项目与流星创建命令。\n•来查看我们的web应用程序在本地机器上,我们可以用流星运行命令\n启动一个本地web服务器。\n•当结合控制台。日志语句,JavaScript控制台是一个非常方便的工具\n流星发展。\n流星的更深层次的理解:\n•如果你还没有,玩耍与原排行榜的应用程序。它不\n有很多功能,但这只是意味着没有理由不是有很强的把握的\n它的功能。\n•关闭命令行应用程序,然后重新打开它,回到你在哪里。\n你应该能够浏览到您的项目的文件夹cd命令启动\n本地服务器与流星跑。\n•创建第二个流星项目和使用这个项目尝试当你学习\n一些新的东西。折腾了为了这是一个很好的方式钻细节\n深入你的大脑。\n在其当前状态查看代码,查看GitHub提交。\n\n\n数据库中,第1部分\n写一个技术书的一个困难的部分是决定何时引入某些想法。\n需要教的主题书之间是一致的,但你说的顺序\n他们可以大大影响读者理解某些内容的能力。\n例如,往往技术作者尽可能谈论创建一个接口\n尽快这是因为看到很有趣的视觉结果代码,和很高兴的感觉\n像你做出了很快的进步。\n但是这种方法并介绍一下几个问题:\n1。很难掌握任何有关前端(接口)当你没有\n熟悉后端(数据库,等等)。\n2。如果我们首先谈论的前端,我们将不得不回顾在下一章,所以任何\n快速进步的感觉将是短暂的。\n因此,我们将首先讨论我们的项目内创建和管理数据库。这\n不是一个“性感”的话题,但是如果我们花几分钟覆盖基础,我们将有一个强大的\n本书的其余部分的基础。\n26\n第1部分数据库,27岁\nMongoDB vs . SQL\n如果您已经构建了一些之前在网上,你可能接触到\n的数据库。也许你安装WordPress的副本,或使用phpMyAdmin,甚至建造\n一些软件语言像PHP。在这些情况下,您会接触到\n一个SQL数据库。\n默认情况下,每个流星项目有自己的数据库。没有安装或配置\n必需的。当你创建一个项目时,会自动创建一个数据库项目,和\n当本地服务器正在运行,那么数据库。然而,这个数据库并不是一个SQL\n数据库。相反,它是所谓的MongoDB数据库。\n如果你之前从未遇到MongoDB,你可能会有点担心,但不要害怕。蒙戈\n数据库和SQL数据库不同,但是作为初学者而言,差异\n很小。\n目前,你只需要知道两件事:\n首先,没有其他类型的数据库用于流星。如果你想使用一个SQL\n数据库,例如,它是不可能的。其他选项可以在未来,但是\n时间其实还不清楚。\n第二,蒙戈使用不同的词汇来描述熟知的概念。例如,我们不会\n使用“表”和“行”这样的词,但概念基本上是相同的。你可以看到\n这个表的差异:\nMongoDB vs . SQL\n会很难想起概念熟悉新单词,但是我将提供大量的提醒\n通过这本书我们进步。\n第1部分数据库,28\n创建一个集合\n排行榜的中央功能应用程序的列表的球员。没有球员的名单\n出现在界面,我们不能建立其他任何有价值的物品。因此这是一个好地方\n开始——从应用程序的“中间”,向外工作的细节。\n这里有两个问题需要考虑:\n•我们在哪里存储与每个玩家相关的数据?\n•我们如何显示这些数据从内部接口?\n我们将在下一章回答第二个问题,但第一个问题:“在哪里\n我们与每个球员关联存储数据吗?”\n滑稽的答案将是“数据库”,但更有用的答案”\n收集”,如前一节所示,相当于一个SQL表集合。\n为了说明的目的收集,想象我们正在创建自己的版本的WordPress\n流星。如果是这样的话,我们会创建一个集合的文章,为集合\n评论,和一组页面。我们会创建一个为每个类型的数据收集。自\n我们创建这个排行榜的应用程序,我们将创建一个集合的球员。\n要做到这一点,打开JavaScript文件,写如下声明:\n新的Mongo.Collection(球员);\n在这里,我们创建一个集合命名为“玩家”在我们项目的Mongo数据库。你可以\n名字收集任何你想要的,但它必须是唯一的。如果名字不是独一无二的,流星\n将返回一个错误。\n尽管这行代码,我们还没有供我们参考这个集合定义了一个方法,\n因此我们没有办法操作。\n为了解决这个问题,将集合在一个变量:\nPlayersList = new Mongo.Collection(球员);\n但请注意,我们没有使用var关键字,因为我们想要创建一个全球性的\n变量。这将允许我们引用和操作在我们所有的集合\n项目的文件。\n确认收集存在,保存文件,切换到Chrome浏览器,并输入的名称\n集合的变量为控制台:\nPlayersList\n第1部分数据库,29岁\n您应当会看到类似如下:\n集合的存在。\n这表明集合是按预期工作。\n如果返回一个错误,这可能是因为你的名字输入错误变量在控制台,\n或在代码中犯了一个语法错误。\n数据库中,第1部分30\n插入数据\n当我们想将数据插入一个集合,我们有四个选项。我们可以通过插入数据\nJavaScript控制台,通过命令行,通过JavaScript文件,并通过\n形式的界面。我们将看到如何使用所有这些选项在这本书,但第一\n选项-通过JavaScript控制台是最简单的,所以这是最好的起点。\n在控制台中,写如下:\nPlayersList.insert();\n这是我们使用的语法来操纵一个集合。\n我们开始分配给变量集合,然后——“PlayersList”变量\n附加功能。在本例中,我们使用插入函数,但是有一个范围的\n功能,如查找、更新和删除(和我们将讨论这些很快的细节)。\n但是,如果我们把“返回”键在这一点上,没有什么会发生,那是因为我们\n需要在函数的括号之间传递数据改变的内容\n集合。\n我们通过的数据需要以JSON格式,如果你不熟悉\nJSON格式,这就是它的样子:\n{\n名称:“大卫”,\n得分:0\n}\n在这里,有几个事情:\n首先,数据是用一对大括号。这就是我们如何区分我们的JSON数据\n剩下的代码。\n第二,我们已经定义了一对密钥。这些键被称为名字和分数,蒙戈\n术语,这些是我们收集的字段。因为每个球员将集合\n有一个名称和一个分数,名字和分数字段来保存这些值。\n第三,我们已经定义了与我们的键相关联的值。在这种情况下,价值的名字\n字段是“大卫”和分数字段的值是0。\n第四,键值用逗号隔开。这是因为JSON格式\n忽略空白,所以逗号是需要提供结构。\n我们可以通过这些数据通过括号,像这样:\n第1部分数据库,31日\nPlayersList.insert({\n名称:“大卫”,\n得分:0\n});\n这是一个完整的插入功能,如果我们这个语句输入到控制台和挖掘\n“返回”键,将会创建一个文档在“PlayersList”集合。文档是\n相当于SQL行和,在这一点上,我们要为每个玩家创建一个文档\n希望在我们的集合。如果我们希望我们的排行榜包含六名球员,我们需要使用\n六次插入函数,从而创建6个文档。\n插入数据。\n为了实现这一点,重复这句话几次,确保定义独特的值\n名称字段,所以我们可以区分球员:\nPlayersList.insert({\n名称:“鲍勃”,\n得分:0\n});\n由于忽略空白,语句可以写在一行:\nPlayersList。插入({ name:“鲍勃”,得分:0 });\n数据库中,第1部分32\n也请注意,创建每个文档后,会出现一个随机的数字和字母\n在控制台。这种混乱的局面是一个独特的ID MongoDB和自动创建的\n与每个文档相关联。它的主键,它会是重要的。\n目前,只注意到它的存在所以你不惊讶当我们讨论一遍。\n在我们继续之前,更多的玩家插入集合。示例应用程序\n六名球员,应该够了。\n球员们在我的名单是:\n•大卫\n•鲍勃\n•玛丽\n•比尔\n•沃伦\n•蒂姆\n他们都有得分字段设置为0。\n将剩下的球员。\n第1部分数据库,33\n找到数据\n现在,我们有一些数据收集,我们能够检索这些数据。我们将这样做\n接口在下一章,但就目前而言,我们只是通过控制台。\n在控制台,输入以下:\nPlayersList.find();\n在这里,我们使用这个找到函数,用于检索数据从指定的集合。\n因为我们没有任何穿过支架,该语句将检索所有的\n的数据集合。\n以下应该出现在控制台:\n使用find函数。\n但很明显,这不是最可读的回应。我们的应用程序可以是有意义的,但是\n我们不能。\n检索数据更可读的格式,附加一个获取函数的转换\n检索到的数据转换成一个数组:\n.fetch PlayersList.find()();\n第1部分数据库、34\n您应该看到如下:\n使用查找和获取功能。\n我们也可以单击下箭头与每个文档相关的数据,\n包括:\n•_id字段,存储文档的惟一的ID(“主键”,我们\n之前提到过)。\n•名称字段,存储的球员的名字。\n•比分字段,存储得分的球员。\n但是如果我们想要检索的数据的集合,而不是所有的\n数据?要做到这一点,我们可以通过json格式的数据之间的括号:\nPlayersList。找到({ name:“大卫”}).fetch();\n这里,我们通过字段名和值通过发现功能,因此,我们可以\n只检索文档,球员的名字字段等于“大卫”。在我们的例子中,这个\n只检索一个文档,但是如果我们集合包含多个玩家叫“大卫”,\n他们都是根据这个查询返回。\n也有用的是计算能力的数量由一个查询返回的文件\n将计数函数找到函数:\n数据库中,第1部分35\n.count PlayersList.find()();\n因为这个语句将计数集合中的所有文档,如果有六名球员\n(文件)的集合,6号返回。\n第1部分数据库、36\n总结\n在这一章,我们了解到:\n•当我们创建一个流星项目,蒙戈数据库自动创建,和\n当本地服务器正在运行,那么数据库。\n•Mongo数据库和SQL数据库不同,但差异是无关紧要的\n初学者而言。\n•为每一种类型的数据需要存储在Mongo数据库中,我们需要创建一个集合。\n集合包含文档和文档的字段和值。\n•使用插入函数,我们可以将数据插入一个集合。这个数据结构\n以JSON格式。\n•通过使用find函数,我们可以从集合中检索数据。这些数据就可以\n通过使用控制台导航。\n流星的更深层次的理解:\n•注意,我们还没有预定义的数据库的结构。相反,结构\n定义数据库的动态,我们使用插入函数。\n•在一个单独的项目中,创建一个存储不同类型的数据的集合,比如博客\n帖子,也许。什么样的字段集合有吗?\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n模板\n在这一章,我们将开始构建排行榜的用户界面的应用程序。\n这包括创建我们的第一个模板。\n首先,下面的代码在排行榜。html文件:\n<头>\n<标题>排行榜< /名称>\n< / >头\n<身体>\n<标题>排行榜< / h1 >\n< /身体>\n这段代码没有什么特别之处——它只是标准的HTML,但出现\n缺少几件事:\n•我们没有包含html标签。\n•我们还没有包括任何JavaScript文件\n•我们还没有包括任何CSS文件。\n但是我们没有包括这些事情,因为我们不需要他们。流星负责\n对我们这些细节。它将html标记添加到文件的开始和结束,自动\n包括项目的文件夹中包含的任何资源(比如JavaScript和CSS文件)。\n这不是世界上最引人注目的特性,但是流星的核心理念之一\n开发者幸福,所以有很多这样传遍了节省时间的特性\n框架。\n37\n模板38\n创建一个模板\n模板用于创建接口和JavaScript代码之间的连接。当\n我们把界面元素在一个模板,我们可以参考和操作\n元素与应用程序逻辑。\n创建一个模板,将下面的代码添加到HTML文件的底部,下\n关闭body标签:\n<模板名称=“排行榜”>\nHello World\n< /模板>\n在这里,我们使用这个模板标签,它使用一个名称属性来区分\n我们创建不同的模板。在这种情况下,模板的名称是“排行榜”,我们会\n很快这个名字从JavaScript文件的引用。\n如果你保存文件在其当前状态,模板不出现在web浏览器。\n在HTML文件,但是没有别的地方了。这是因为,在默认情况下,模板不出现\n内部接口。这听起来可能很奇怪,但是考虑到,在某些情况下:\n•您可能希望一个模板出现在某些时候。\n•您可能希望一个模板在某些时刻消失。\n•你可能想要一个模板出现在多个位置。\n考虑到这种可能性,我们需要手动包含模板内部的接口。这\n确实需要一个额外的步骤,但它会变得越来越有用,因为我们深入发展。\n使“排行榜”模板出现在浏览器内,把这个标签之间的身体\n需要在HTML文件:\n{ { >排行榜} }\n显然,这不是HTML。代替。double-curly括号的使用意味着这是空格键\n语法,空格键是语法中我们使用HTML当我们想要动态\n发生。这是语法,桥梁之间的差距接口和应用程序逻辑。\n我们将了解更多关于空格键在这本书,但现在,知道:\n1。所有空格键标签使用double-curly括号来区分。\n2。我们只使用大于符号当我们想要包括一个模板。\n基于这些变化,HTML文件现在应该类似于:\n模板39\n<头>\n<标题>排行榜< /名称>\n< / >头\n<身体>\n<标题>排行榜< / h1 >\n{ { >排行榜} }\n< /身体>\n<模板名称=“排行榜”>\nHello World\n< /模板>\n保存文件之后,内部的“Hello World”从“排行榜”模板\n出现在浏览器:\n当前界面。\n模板40\n客户端与服务器\n在我们继续之前,我想要证明的东西。你不需要完全理解我们\n封面,但都遵循允许通过编写的所有代码。\n在JavaScript文件,编写以下控制台。日志语句:\n控制台。日志(“Hello world”);\n这是我们声明语句写在“项目”一章,并在保存文件\n切换回Chrome,您应该看到“Hello world”消息出现在控制台:\n“Hello World”出现在控制台。\n上次我没有提到虽然是,由于这种说法,别的东西也\n发生,如果我们切换到命令行中,我们可以看到“Hello world”消息\n也在这里:\n模板41\n“Hello World”出现在命令行。\n这是很重要的,因为我们已经写一行代码的执行在两个地方。的\n代码是运行在客户端(在用户的web浏览器)和服务器(其中\n应用程序托管)。\n为什么这很重要?\n有几个原因,但这里有一个例子:\n自从我们创造了“PlayersList”集合,下面的语句上运行\n客户端和服务器:\nPlayersList = new Mongo.Collection(球员);\n但是代码不做同样的事情在这两个地方。\n当代码在服务器上执行,创建在Mongo集合数据库。这是\n我们的数据存储。当代码执行从用户的web浏览器中虽然-\n在客户端创建一个本地副本的收集用户的计算机。作为一个结果,\n当用户与数据库交互时,他们实际上交互的本地副本。这\n部分原因是流星应用程序默认是实时的。数据是用户的操作\n本地机器然后无形在后台与服务器端数据库同步。\n但如果这一切听起来有点概念,不要害怕。你不需要了解细节\n点流星的“魔法”。你只需要一行代码就可以掌握:\n1。在两个不同的环境中运行(在客户端和服务器)。\n模板42\n2。根据不同的环境会有不同的行为。\n也就是说,在某些情况下,我们不希望我们的代码运行在两个地方。如果,\n实例中,我们编写代码,只会影响应用程序的接口,它不会是有意义的\n在服务器上运行的代码。我们只希望它在客户机上运行。\n适应,有一双条件我们可以用来确定代码运行\n的环境。你会有一个更好的想法何时使用这些条件\n通过书的进展,但是,只要跟着目前通过编写所有的\n代码。\n首先,一颗流星。isClient条件下的控制台。日志声明:\n如果(Meteor.isClient){\n/ /这段代码只在客户机上运行\n}\n这个条件允许我们专门执行代码在客户端——从用户的内部\nweb浏览器,为了证明这一点,我们可以简单地添加一个控制台。日志声明内\n条件:\n如果(Meteor.isClient){\n控制台。日志(“你好客户”);\n}\n保存文件,切换到浏览器,注意,“你好”客户端消息出现在\n控制台,但没有出现在命令行里面。这是因为代码没有被\n在服务器上执行。\n模板43\n“你好,客户端”只出现在控制台。\n我们可以创建与流星相反的效果。isServer条件:\n如果(Meteor.isServer){\n/ /这段代码只运行在服务器上\n}\n再次,我们将放置一个控制台。日志语句内部条件:\n如果(Meteor.isServer){\n控制台。服务器日志(“你好”);\n}\n保存文件之后,请注意,“你好”服务器消息出现在命令\n线,但不出现在控制台。这是因为只有被执行的代码\n托管服务器(应用程序)。\n模板44\n“你好,服务器”只出现在命令行。\n但是如果这一切都是真的沉没,只要记住两件事:\n1。一行代码可以运行在客户端和服务器。\n2。有时我们不想让我们的代码运行在这两个地方。\n精确的时刻,我们需要考虑这些点很快就将变得明朗了。\n现在,仅仅删除控制台。日志语句,但离开他们的条件。我们会\n很快就会使用它们。\n模板45\n创建一个助手\n在这一点上,我们的“排行榜”模板只显示静态文本“Hello World”。为了解决这个问题,\n我们将创建一个helper函数,一个辅助函数是一个常规的JavaScript函数\n附加的模板,让我们从一个接口内部执行代码。\n开始,我们将一个古老的方法来创建辅助函数。这种方法已被弃用,\n这意味着它不再是官方支持,你读这句话的时候,它可能\n不工作。但这老格式更容易教和理解,并允许我们来缓解\n到non-deprecated方法,我们会讨论。\n在JavaScript文件,编写以下isClient内部条件:\nTemplate.leaderboard.player\n这是弃用语法来创建一个helper函数,它可以分解成三个\n部分:\n首先,我们流星的模板通过关键词搜索模板工程。我们只\n有一个模板,但是一个完整的项目会更多。\n第二,通栏广告关键字指的是我们创建模板的名称\n早些时候。每一个helper函数必须附加到一个模板。在这种情况下,附加功能\n“排行榜”模板。\n第三,球员关键字是我们给这个函数。我们很快就会参考\n这个名字在HTML文件。\n这个助手附加代码,将它与一个函数:\nTemplate.leaderboard。球员= function(){\n/ /代码在这里\n}\n“助手”这个词可能会让这种声音的,但是我们没有做什么特别的。\n我们已经创建了一个函数,将其命名为“球员”,并连接到“排行榜”模板。\n添加一些功能函数,创建一个返回语句返回一些静态的\n文本:\nTemplate.leaderboard。球员= function(){\n返回“其他文本”\n}\n然后删除的文本“Hello World”模板,代之以“排行榜”\n以下标记:\n模板46\n{ {球员} }\n在这里,我们使用的是另一个空格键标签,就是明证double-curly括号的使用。但\n请注意,我们不使用大于符号,这是因为我们不包括\n模板。相反,我们引用玩家函数的名称。\n保存文件后,返回语句的文本应该出现在浏览器内:\n使用弃用辅助函数方法。\n如果文本不出现,一些是错误的代码,或者这种方法创建\n从流星助手被移除。如果你不确定它,检查你的代码错误。\n如果您的代码就是我告诉你写,它仍然不工作,不要害怕。现在,\n你知道老方法创建辅助函数,我们准备讨论的新方法。\n删除所有我们刚刚创建的helper函数,代之以:\nTemplate.leaderboard.helpers\n在这里,我们有这个模板的关键字,搜索通过模板在我们的项目,\n这个排行榜的关键字,这是一个引用“排行榜”模板。\n但是这个帮手关键词呢?\n我们创建一个函数命名的“帮手”?\n不。\n模板47\n这个助手关键字是一个特殊的关键字,它允许我们定义多个辅助功能\n在一个代码块。\n因此,而不是创建一个helper函数:\nTemplate.leaderboard。球员= function(){\n/ /代码在这里\n}\n我们为所有的模板创建一个块的辅助功能:\nTemplate.leaderboard.helpers({\n/ /辅助函数到这里\n});\n这些助手以JSON格式定义,与助手的名字和一个的关键\n相关函数的值:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回“其他文本”\n}\n});\n使用逗号分隔,我们可以创建多个辅助功能:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回“其他文本”\n},\n“otherHelperFunction”:函数(){\n返回“其他功能”\n}\n});\n可以使用这两个辅助函数在“排行榜”模板:\n{ {球员} }\n{ { otherHelperFunction } }\n这段代码可能看起来有点忙比弃用的方法,但这只是因为我们\n使用少量的帮手。更大数量的助手,组织他们\n这是最清洁的方法。\n模板48\n一对辅助函数在一个模板。\n模板49\n每一块\n我们已经取得了一个helper函数,但它只是返回一些静态文本,这并不是很有趣。\n我们真正想要的是一个helper函数,从“PlayersList”中检索文档\n收集。然后我们就可以从界面中显示数据。\n为了达到这个目标,helper函数的返回语句替换为以下几点:\n返回PlayersList.find()\n在这里,我们使用find函数函数从“数据库,第1部分”一章。这个函数\n将从“PlayersList”检索所有的数据集合,因为我们已经把它内\nhelper函数,这些数据现在可以从内部“排行榜”模板。\n看到这,从HTML文件中删除以下标记:\n{ {球员} }\n之前,我们的helper函数返回之前的一段数据,字符串,\n这个目的,这个标签是很好,但现在的助手是返回一个数组的所有文档\n在集合,这意味着我们需要遍历返回的数据。\n为了实现这一点,我们可以使用空格键语法来创建一个每个块:\n{ { #每个玩家} }\n测试\n{ { /每个} }\n在这里,有几个事情:\n首先,从“PlayersList”收集所有的文档检索的基础上,参考\n玩家的功能。\n第二,我们遍历返回的数据的每个语法。\n第三,我们为每个文档输出“测试”这个词(球员)的检索。因为有\n六名球员在收集、“测试”这个词会出现界面内的6倍。\n模板50\n“测试”这个词似乎每个玩家的收集。\n从概念上讲,这就像我们有一个数组:\nvar playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);\n…就像我们使用forEach循环遍历这个数组的值:\nvar playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);\nplayersList.forEach(函数(){\nconsole.log(测试);\n});\n在每一块,我们也可以从内部文档检索字段的值。\n因为我们把“PlayersList”收集的数据,我们可以显示的值\n字段名字和分数。\n显示玩家的名字,例如,我们可以写:\n{ { #每个玩家} }\n{ {名称} }\n{ { /每个} }\n然后显示玩家的分数,我们可以写:\n模板51\n{ { #每个玩家} }\n{ {名称} }:{ {得分} }\n{ { /每个} }\n虽然我们不会让这个应用程序很浪费时间,我们将添加一些细微的结构\n的接口:\n< ul >\n{ { #每个玩家} }\n<李> { {名称} }:{ {得分} } < /李>\n{ { /每个} }\n< / ul >\n保存文件后,玩家的名字和分数将会出现在一个无序列表。通过\n默认情况下,球员们会按时间——从他们插入到集合\n玩家添加第一个球员最近增加了更多,但这是我们改变\n后一章。\n一种改进的界面。\n模板52\n总结\n在这一章,我们了解到:\n•流星为我们处理一些无聊的细节,如使用html标记和包括\nJavaScript和CSS文件。\n•通过创建模板,我们可以形成一个应用程序逻辑和我们之间的桥梁\n接口。\n•我们的项目的代码可以在客户端和服务器上运行,但我们并不总是想要的\n这样的事情发生。我们可以使用isClient isServer条件控制的\n代码运行。\n•创建一个模板后,我们需要手动把它在界面。这给了\n我们控制时间和地点。\n•通过创建辅助函数,我们可以执行代码在一个模板,从而创建\n一个动态的界面。\n•如果一个helper函数返回一个数组的数据,我们可以通过数据在一个循环\n模板使用每个语法。\n流星的更深层次的理解:\n•意识到模板可以放置在任何地方项目的文件夹。我们可以,\n实例,把我们的“排行榜”模板在另一个HTML文件和参考{ { >\n排行榜} }将继续工作。\n•故意打破应用程序通过将每个块之外的“排行榜”\n模板。熟悉的错误,你会不可避免地遇到一颗流星\n开发人员。然后你就会知道如何处理这些问题当他们意想不到的。\n•创建一个helper函数,使用查找和计数函数返回的数量\n球员“PlayersList”集合。然后在界面中显示这些数据。\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n事件\n在这一点上,我们有一个名单的球员出现在界面,但是没有办法\n用户与该列表。数据动态地从“PlayersList”收集、检索\n但用户仍将可能假定应用程序完全是静态的。\n我们将花剩下的书解决这个问题,但在接下来的几个章节\n特别的,我们将创建的影响能够选择球员名单内。\n具体来说,当用户点击其中一个球员,球员的背景颜色\n元素将会改变黄色。\n53\n事件54\n创建一个事件\n在本节中,我们将创建我们的第一个事件,事件使我们能够触发执行的代码\n当用户点击一个按钮,轻拍一个关键键盘,或完成一系列其他\n行动。\n为了说明这一点,写在isClient条件如下:\nTemplate.leaderboard.events({\n/ /事件到这里\n});\n在这里,有几个事情:\n首先,模板是用来搜索所有的项目模板。\n第二,排行榜是模板的名称我们要附加事件。\n第三,事件是特殊的关键字,是用于指定,在未来的\n代码,我们希望指定一个或多个事件。(这段代码非常类似于我们如何创建助手\n功能。)\n花括号之间的事件块,使用JSON格式创建一个事件:\nTemplate.leaderboard.events({\n“点击”:函数(){\n/ /代码在这里\n}\n});\n在这里,有两个事情:\n首先,我们定义事件类型。这是点击部分。正因为如此,里面的代码\n相关的函数将执行当用户点击的范围内的任何地方\n“排行榜”模板。\n第二,这个事件我们附加一个函数,这个函数里面,我们可以写\n代码要执行时,单击出现。\n为了说明这一点,添加一个控制台。日志语句内的事件:\nTemplate.leaderboard.events({\n“点击”:函数(){\n控制台。日志(“你点击”);\n}\n});\n事件55\n保存文件后,切换回Chrome和点击的范围内的任何地方\n“排行榜”模板。每次点击,你点击“消息将出现在里面\n控制台。\n点击。\n事件56\n事件选择器\n我们已经创建的事件是太过宽泛。它触发当用户单击任何地方范围内\n“排行榜”的模板。在某些情况下可能是有用的,但通常我们\n当用户希望触发一个事件做精确,喜欢点击某个按钮。\n为了实现这一点,我们将使用事件选择器,选择符允许我们将事件附加到特定的HTML\n元素。(如果你曾经使用jQuery,这个过程将是熟悉的,但如果不是这样,它仍然会相当\n容易掌握。)\n早些时候,我们把李HTML文件中的标签:\n<李> { {名称} }:{ {得分} } < /李>\n目前的计划是让我们的事件触发李当用户点击其中一个元素。\n要做到这一点,改变事件如下:\n“李点击”:函数(){\n控制台。日志(“你点击一个li元素”);\n}\n在这里,我们做了两处修改:\n首先,我们已经添加了李后点击关键字部分。这意味着事件将触发\n当用户点击“排行榜”内任何li元素模板。\n第二,我们已经改变了控制台的输出。日志语句。\n然而,我们还没有考虑:\n会发生什么,如果我们有其他的li元素内部的“排行榜”模板,不是吗\n玩家的列表的一部分吗?以后会这样,我们的代码的目前的形式来看,它会引发一场\n问题。事件将触发当我们不希望它来触发。\n为了解决这个问题,添加一个。球员对li元素类:\n<李类= \"玩家\" > { {名称} }:{ {得分} } < /李>\n然后使用这类事件选择器:\n的点击。球员”:函数(){\n控制台。日志(“你点击。球员元素”);\n}\n在这里,我们已经取得了如此事件只会触发,当用户单击一个元素\n的。播放器类连接到它。\n保存文件后,最后的结果不会出现任何不同,但是如果我们添加其他元素\n模板,事件不会触发的时候不应该。\n事件57\n点击一个球员。\n事件58\n总结\n在这一章,我们学到的:\n•当用户点击一个按钮,提交一个表单,或完成其他操作,我们可以\n触发器的执行代码通过使用事件。\n•最常见的事件类型是点击,但是有一个可用的其他选项范围\n以许多不同的方式使我们的应用程序交互。\n•通过使用事件选择器,我们可以精确的元素的附加事件\n类似的语法jQuery和CSS。\n流星的更深层次的理解:\n•尝试不同的事件类型,包括:双击鼠标,焦点,模糊,鼠标悬停,\n改变。找出这些不同类型的行为,试图整合他们\n排行榜的应用程序。\n在其当前状态查看代码,查看GitHub提交。\n\n\n会话\n当用户点击其中一个。球员元素,执行一个函数。当这个函数是\n触发,我们想改变背景颜色的元素,从而产生的效应\n被选中的球员。\n为了实现这一点,我们将使用会话,会话允许我们不存储小块的数据\n保存到数据库并返回访问不会记得。这类数据可能\n听起来不立即有用,但这是一个令人惊讶的是通用的方法来解决很多共同之处\n问题。\n59\n会话60\n创建一个会话\n创建一个会话,写在单击下面的语句。球员事件:\n会话。集(“selectedPlayer”、“会话值测试”);\n这里,我们使用这个会话。设置功能,通过两个参数:\n首先,我们通过会议的名称。这个名字被用作参考。在这个\n情况下,我们调用会话“selectedPlayer”,但随意使用任何你喜欢的名字。\n其次,我们通过会议的价值。这是我们内部存储的数据\n会话。在这种情况下,我们通过“会话值测试”的静态值,但我们会\n使用一个更有趣的值。\n证明我们的会话是按预期工作,检索的会议的价值\n下面的语句:\nSession.get(“selectedPlayer”);\n块应该类似的事件:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\n会话。集(“selectedPlayer”、“会话值测试”);\nSession.get(“selectedPlayer”);\n}\n});\n这里,我们使用这个会话。函数,通过“选择——的名称\n玩家“会话,我们刚才创建的。\n输出该会话的值到控制台,它在一个变量:\nvar selectedPlayer = Session.get(“selectedPlayer”);\n然后添加一个控制台。日志声明下面这条线:\nvar selectedPlayer = Session.get(“selectedPlayer”);\nconsole.log(selectedPlayer);\n现在,当用户点击其中一个球员元素,“会话值测试”字符串\n存储在一个会话,然后立即输出到控制台。它不是最有用的代码,\n但这很快就会改变的。\n61年会议\n创建和检索一个会话。\n62年会议\n玩家的ID\n当用户点击列表中的玩家之一,我们要抓住玩家的惟一ID\n并将其存储在“selectedPlayer”会议。这将允许我们改变背景\n这个玩家的li元素的颜色。\n如果你不确定我是什么意思,当我说“玩家”的惟一的ID,回想\n当我们球员插入“PlayersList”集合。每次我们使用插入\n函数,一个随机的数字和字母会出现。混乱是唯一的ID\n的球员。\n首先,创建一个“playerId”变量的顶部点击。球员的事件,并使其平等\n从之前的“会话值测试”字符串:\nvar playerId =“会话值测试”;\n然后修改会话。集函数,通过“playerId”变量作为第二个\n论点。事件应该类似于:\n的点击。球员”:函数(){\nvar playerId =“会话值测试”;\n会话。集(selectedPlayer,playerId);\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n在这一点上,关键是要使“playerId”变量等于球员的惟一ID\n这是被点击。这并不需要大量的代码,但它确实需要一些解释。\n现在,改变“playerId”变量如下:\nvar playerId = this._id;\n至于原因,有两个事情:\n首先,我们有一个参考,这取决于上下文的价值。在这种背景下,\n这个指的是文档的球员刚刚点击。\n第二,_id部分是包含惟一的ID字段的名称的球员。所以在\n我们创建了一个名字和分数一样,蒙戈为每个文档创建一个_id字段。\n(下划线本身没有任何特殊的意义。这只是部分字段的名字。)\n由于这一变化,现在下面是可能的:\n1。用户点击的一个球员。\n2。玩家的惟一ID存储在“playerId”变量。\n3所示。“playerId”变量的值存储在“selectedPlayer”会话。(可以\n只有一个值存储在一个会话,所以每当一个新值存储,前面的\n值是重写。)\n63年会议\n4所示。“selectedPlayer”会话的值输出到控制台。\n看到这在行动:保存文件,切换回Chrome,点击任何球员\n列表。他们惟一的ID将显示在控制台。\n点击大卫后,鲍勃和玛丽。\n因为我们不需要看到控制台内的点击播放器的惟一的ID,我们可以\n简化事件如下:\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n}\n在这里,我们只是设置的值“selectedPlayer”会议,点击的惟一ID\n的球员。\n64年会议\n选择效果,第1部分\n当用户点击一个球员在我们的列表中,我们想要改变背景颜色\n包含该玩家的li元素的属性。这将创建该玩家的影响\n被选中。\n为了实现这一点,打开项目的CSS文件并创建一个名为“选择”的类。这门课应该\nbackground属性,在这个例子中,我们将通过“黄色”的价值:\n.selected {\n背景颜色:黄色;\n}\n然后切换到JavaScript文件并创建一个“selectedClass”助手:\nTemplate.leaderboard.helpers({\n“球员”:函数(){\n返回PlayersList.find()\n},\n“selectedClass”:函数(){\n/ /代码在这里\n}\n});\n(你会发现两个助手都是在相同的代码块,和我们讨论\n以前,这是可能使用逗号)。\n至于这个函数的内容,我们会让它返回“选择”这个词:\n“selectedClass”:函数(){\n返回“选择”\n}\n注意:我们需要返回的文本等于在CSS文件类的名称,因为\n我们命名为“类”选择“在CSS文件中,我们返回“选择”从内部文本\n这个函数。\n接下来,切换到HTML文件并将引用这个“selectedClass”功能里面\nli元素的class属性:\n<李类= \"球员{ { selectedClass } } \" > { {名称} }:{ {得分} } < /李>\n“选择”类将被应用到每一个。球员的元素,从而改变了背景\n每个元素的颜色:黄色\n65年会议\n“选择”类是应用于li元素。\n这不是我们想要的但这是一个重要的一步。\n66年会议\n选择效果,第2部分\n在我们继续之前,我想要证明的东西。\n在selectedClass helper函数返回语句注释掉:\n“selectedClass”:函数(){\n/ /返回“选择”\n}\n然后编写以下:\n“selectedClass”:函数(){\n/ /返回“选择”\n返回this._id\n}\n在这里,我们使用这个。_id检索的惟一ID的球员。而是的ID\n输出到控制台,它会出现在每个li元素的class属性。这是\n不是我们想要的但重要的是要知道,因为selectedClass函数\n被执行在每一块,它可以访问所有的数据迭代\n(包括球员的惟一的ID、姓名和分数)。\n这证明:保存文件,切换到Chrome,右键单击li元素之一,并选择\n“检查元素”选项。你会注意到每个玩家现在出现在的惟一ID\nclass属性:\n67年会议\n球员们在每个类的惟一的ID属性。\n知道了这一点,我们要做几件事:\n首先,我们将删除返回。_id声明,因为它只是用于演示目的。\n第二,我们将取消返回语句,因为我们想要selectedClass函数\n返回“选择”的静态文本。\n第三,我们将创建一个“playerId”变量的函数,this._——的价值\nid:\n“selectedClass”:函数(){\nvar playerId = this._id;\n返回“选择”\n}\n第四,我们将创建一个“selectedPlayer”为“selectedPlayer”会话变量:\n68年会议\n“selectedClass”:函数(){\nvar playerId = this._id;\nvar selectedPlayer = Session.get(“selectedPlayer”);\n返回“选择”\n}\n第五,将返回语句在下列条件:\n“selectedClass”:函数(){\nvar playerId = this._id;\nvar selectedPlayer = Session.get(“selectedPlayer”);\n如果(playerId = = selectedPlayer){\n返回“选择”\n}\n}\n逻辑后如果你有麻烦,这是怎么回事:\n当用户点击一个列表中的玩家,玩家的惟一ID存储在里面\n“selectedPlayer”会议。然后该会话的ID匹配的所有ID\n球员们在列表中。因为玩家的ID将永远是独一无二的,只能有一个\n单匹配,匹配时,静态文本的“选择”将返回的\nselectedClass功能和放置在球员li元素的class属性。基于\n在这类,玩家的li元素的背景颜色会变成黄色。(和\n因为会话只能存储一个值,只有一个球员可以选择一次)。\n点击后,鲍勃。\n这是最复杂的例子在这本书中,但是你只需要掌握一种基本的会话\n其余的章节。它并不重要,如果你不“获得”的一切。\n69年会议\n总结\n在这一章,我们了解到:\n•会议是用来存储小块的数据没有保存到数据库或\n记得在返回访问。\n•创建一个会话,我们使用会话。集函数,而检索的价值\n会话我们使用会话。得到的功能。\n•辅助函数和事件在每一块获得的数据\n遍历的块。\n流星的更深层次的理解:\n•考虑我们如何使用“selectedPlayer”会议。我们还可以做些什么\n选中的球员的惟一的ID吗?\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n数据库,第2部分\n还有很多其余页的这本书,但是我们已经完成了大部分\n从最初的排行榜应用程序特性。\n剩下的我们将在本章的工作包括:\n•增加选择球员的得分能力。\n•排名球员的得分(从最高到最低)。\n•显示选中的球员的名字在名单上。\n我们也可以减量的得分选择球员,这并不是的一个特征\n原始的应用程序,但足够简单的添加。\n70年\n第2部分数据库,71\n给5分\n在“排行榜”模板,我们将创建一个“给5分”按钮,当点击时,会\n增加选择的球员的得分。\n开始,将下面的按钮在“排行榜”模板:\n< input type = \" button \" class = \"增量\" value = \"给5分”>\n按钮应该以外的每一块,类属性的设置\n“增量”。\n按钮做一些,添加以下事件的事件块内\nJavaScript文件:\n的点击。增量”:函数(){\n/ /代码在这里\n}\n整个事件块应该类似于:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n},\n的点击。增量”:函数(){\n/ /代码在这里\n}\n});\n(别忘了事件之间用逗号分隔)。\n在点击。增加事件,我们将使用选定的玩家发现的惟一ID\n玩家在“PlayersList”收集和增加球员的得分字段的值\n5。\n访问的唯一ID选择球员,使用会话。功能:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n您可以验证这个功能一个控制台。日志语句:\n第2部分数据库,72\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nconsole.log(selectedPlayer);\n}\n选择一个球员之后,单击“给5分”按钮来显示所选的惟一ID\n的球员。\n单击“给5分”按钮后,玛丽的身份出现在控制台。\n第2部分数据库,73\n先进的运营商,第1部分\n在这一点上,我们想做的是,当一个用户从列表中选择一个球员和点击\n“给5分”按钮时,该玩家的分数是修改。\n要做到这一点,删除控制台。从点击日志语句。增加事件和替换它\n用以下:\nPlayersList.update();\n这是Mongo更新函数,在括号之间,我们可以定义:\n1。什么文档(球员)我们要修改。\n2。我们想修改文档。\n要做到这一点,我们首先检索所选球员的文档。这可以通过通过\n选中的球员的惟一ID:\nPlayersList.update(selectedPlayer);\n这件事现在应该类似于:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList.update(selectedPlayer);\n}\n修改文档,我们通过第二个参数更新函数定义\n文档的一部分,我们要改变:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer {得分:5 });\n}\n该语句将:\n1。找到的文档选择的球员,根据玩家的ID。\n2。更新文档通过改变比分字段的值为5。\n第2部分数据库,74\n但是如果你测试这个功能,你会发现它坏了。如果你选择了一个播放器,点击“给\n5点”按钮,这名球员的名字将会消失。比分字段的值将会改变\n5,按计划,但名称字段将完全从文档中删除。\n玛丽去了哪里?\n这可能看起来像是一个错误,但默认情况下,更新函数通过删除原来的工作\n文档和创建一个新的文档与我们指定的数据。_id字段的值\n将保持不变,但由于我们只指定update语句内的分数,\n这是唯一的其他领域仍在修改文档。\n考虑到这一点,我们需要使用一套Mongo运营商,让我们的价值得分\n场没有删除原始文档。\n首先,用以下代码替换更新函数的第二个参数:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $:});\n}\n这里,我们使用这个设置操作员修改一个字段的值美元(或多个字段)\n删除原始文档。冒号后,我们只需要通过我们想要的字段\n修改(和他们的新值):\n第2部分数据库,75\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $设置:{得分:5 } });\n}\n由于这一变化,更新函数不会被完全打破。如果我们保存文件\n切换回Chrome,我们可以看到,选择一个球员和点击“给5分”按钮\n将修改玩家的分数而不影响文档的其余部分。\n设置分数而不破坏任何东西。\n但尽管如此成功,我们仍然没有创建功能,我们旨在创建。因为\n当我们的按钮可以设置选择玩家的分数5的价值,这就是它能做的。没有\n多少次我们单击按钮时,字段的值不会增加任何进一步的。\n修复这个问题,替换设置操作员与公司接线员:美元\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n根据这一变化,每当更新函数触发,比分字段的值\n将增加任何价值我们指定的值(在本例中,5)。\n第2部分数据库,76\n现在可以增加分数字段的值。\n第2部分数据库,77\n先进的运营商,第2部分\n没有出现在原始的排行榜的功能应用程序是衰减的能力\n分数。虽然这样的特性将会有用,因为它意味着我们可以:\n1。惩罚玩家不遵守规则。\n2。收回点错误地获得。\n也是一个很简单的特性来扔在一起。\n首先,创建一个“带5分”按钮在“排行榜”模板:\n< input type = \"按钮”class =“减量”值=“带5分”>\n与“给5分”按钮,把它在每个块和为它提供一个独特的\n类属性(如“减量”)。\n接下来,点击切换到JavaScript文件,复制。增加事件,将代码粘贴到\n同样的事件。\n块的事件应该类似于:\nTemplate.leaderboard.events({\n的点击。球员”:函数(){\nvar playerId = this._id;\n会话。集(selectedPlayer,playerId);\n},\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n},\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n});\n在这一点上,我们只需要做两个变化:\n首先,更改为新创建的事件选择器。.decrement增量。\n第二,价值5通过公司运营商,而不是值为5。附加的\n——逆转算子的功能,现在美元的公司操作符将衰减值\n的分数。\n最后一个事件的代码应该类似于:\n第2部分数据库,78\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n有点冗余的代码,我们有两个几乎相同的事件——但这是\n我们在后面的章节会修理。\n第2部分数据库,79\n对文档进行排序\n目前,球员名单中排名的时候他们插入\n收集,而不是通过他们的分数排名。\n为了解决这个问题,我们将修改里面的球员helper函数返回语句:\n“球员”:函数(){\n返回PlayersList.find()\n}\n首先,通过一对大括号的括号找到功能:\n“球员”:函数(){\n返回PlayersList.find({ })\n}\n通过使用这些花括号,我们明确说明我们想要检索的所有数据\n从“PlayersList”集合。这是默认的行为,所以这两个语句\n技术上:\n返回PlayersList.find()\n返回PlayersList.find({ })\n但经过花括号作为第一个参数,我们可以通过第二个\n参数,在这第二个参数,我们可以定义如何想对数据排序\n检索。\n作为第二个参数,通过接线员:\nPlayersList返回。找到({ },{ }):\n(不像集和美元公司经营者,我们不使用美元符号的这个操作符\n的名字。)\n然后选择排序的字段的值:\nPlayersList返回。找到({ },{:{分数:1 } })\n通过值传递,我们可以按照降序排列。这意味着我们的排序\n从得分最高的球员得分最低。如果我们通过一个值的球员\n将排序分数最高的分数最低。\n第2部分数据库,80\n基于他们的分数排名球员。\n基于这种变化,球员们将会根据他们的分数排名,但是如果两个\n玩家同样的分数吗?\n采取“鲍勃”和“比尔”,例如。如果他们有相同的分数,比尔应该排名高于鲍勃\n因为,按字母顺序,首先是他的名字。但此刻,不会发生因为鲍勃\n比尔之前添加到集合。\n为了解决这个问题,name字段通过运营商,但是这一次,通过的值\n1而不是1:\nPlayersList返回。找到({ },{:{分数:1,名字:1 } })\n球员们仍将主要由他们的分数排名,但是一旦发生了排序,\n球员们也会在他们的名字。这二次排序将发生在提升\n(字母)。\n第2部分数据库,81\n基于分数和排名的名字。\n根据这一变化,如果Bob和比尔有相同的分数,比尔会排名高于鲍勃。\n第2部分数据库,82\n个人文档\n当用户选择其中的一个球员,球员的名字将出现在列表中\n的球员。这并不是最有用的功能,但是:\n1。这是最初的排行榜的一部分应用程序。\n2。这意味着我们可以谈论一些流星的特性。\n在JavaScript文件,创建一个helper函数,连着“showSelectedPlayer”\n“排行榜”模板:\n“showSelectedPlayer”:函数(){\n/ /代码在这里\n}\n内部函数,获取当前选中的球员的惟一ID:\n“showSelectedPlayer”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n然后写一个返回语句,返回数据从一个文档内\n“PlayersList”集合。我们可以使用find函数,但findOne函数是首选\n选择:\n“showSelectedPlayer”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n返回PlayersList.findOne(selectedPlayer)\n}\n通过使用findOne函数,我们可以通过文档作为唯一的惟一ID\n参数,我们可以避免不必要的开销,因为这个函数只\n尝试检索单个文档。它不会像找到浏览整个集合\n将函数。\n有了这个功能,切换到HTML文件并将引用里面的函数\n“排行榜”模板。我把我的列表的底部,李两两之间的标签:\n<李>选中的球员:{ { showSelectedPlayer } } < /李>\n但是如果我们保存文件,输出看起来不完全正确,因为findOne函数\n是球员的整个文档检索。为了解决这个问题,我们需要指定,我们只希望\n显示名称字段的值,可以用点符号:\n第2部分数据库,83\n<李>选中的球员:{ { showSelectedPlayer.name } } < /李>\n现在的接口将类似于:\n显示选中的球员的名字。\n我们也应该让模板并不试图显示如果一个球员一个球员的名字\n不是选择,可以用一个简单的条件:\n{ { #如果showSelectedPlayer } }\n<李>选中的球员:{ { showSelectedPlayer.name } } < /李>\n{ { /如果} }\n这个列表项将只出现一个球员当前是否选中。\n第2部分数据库,84\n总结\n在这一章,我们了解到:\n•在默认情况下,蒙戈更新功能的更新和删除文档\n再现与指定的字段(同时保留相同的主键)。\n•改变文档的值没有先删除它,设置操作员需要美元\n被使用。这个操作符只会指定文档的值没有改变\n影响文档的其余部分。\n•公司美元操作符可以用来增加一个字段的值在一个特定的\n文档。\n•公司美元操作符可以用来衰减被放置的-一个字段的值\n前面的符号指定的值。\n•排序操作符可以用来排序的数据找到返回的函数。它\n可以由多个字段排序。\n•findOne函数只会从集合中检索单个文档,\n更有效的方法,如果你只需要检索单个文档。\n流星的了解:\n•让“给5分”按钮只出现在用户已经选择。这\n是最初的排行榜的功能的应用程序。\n•浏览“运营商”部分Mongo文档看看的\n可以通过纯粹的数据库操作。\n在其当前状态查看代码,查看GitHub提交。\n\n\n形式\n我们已经完成重建原始排行榜的应用程序,但有足够的空间\n扩大同新功能的应用程序。在这个章节中,我们将创建一个表单\n允许用户添加玩家排行榜,连同其他界面控件。\n85年\n86年形式\n创建一个表单\n在HTML文件,创建一个名为“addPlayerForm”的第二个模板:\n<模板名称= \" addPlayerForm \" >\n< /模板>\n包括这个地方在“排行榜”模板:\n{ { > addPlayerForm } }\n在“addPlayerForm”模板,创建以下两个元素:\n1。一个文本字段的名称属性设置为“playerName”。\n2。提交按钮的值属性设置为“添加球员”。\n模板应该类似于:\n<模板名称= \" addPlayerForm \" >\n<形式>\n< input type = \" text \" name = \" playerName \" >\n< input type = \" submit \" value = \"添加球员\" >\n> < /形式\n< /模板>\n由此产生的界面不会漂亮,但这是我们所需要的。\n87年形式\n一个表单添加球员排行榜。\n88年形式\n“提交”事件\n我们已经见过几个点击事件的例子,我们可以触发执行\n的代码,当用户单击一个特定的元素。同样,还有提交\n事件,它允许触发执行的代码,当用户提交表单。\n为此,创建另一个事件块isClient内部条件:\nTemplate.addPlayerForm.events({\n/ /事件到这里\n});\n(我们需要一个新的事件块,因为这一事件将被附加到新的“addPlayerForm”\n模板,而不是“排行榜”模板。)\n在这个事件块中,创建事件和事件类型设置为“提交”选择器集\n“形式”:\nTemplate.addPlayerForm.events({\n的提交表单:函数(){\n/ /代码在这里\n}\n});\n基于这段代码中,事件的函数时将触发“addPlayerForm”内的形式\n模板提交。\n但是我们为什么不只是使用的单击事件形式?不会大多数用户单击submit按钮\n呢?可能是这样,但重要的是要记住,可以提交表单\n多种方式。在某些情况下,用户单击submit按钮,但其他时候他们会\n点击“返回”键在键盘。通过使用submit事件类型,我们可以考虑\n为每一个可能的方式,可以提交表单。\n确认事件是按预期工作,放置一个控制台。日志声明里面:\n的提交表单:函数(){\n控制台。日志(“形式提交”);\n}\n但事实证明,实际上是一个事件的问题,因为当我们提交表单:\n1。web浏览器刷新页面。\n2。提交的“形式”的信息不会出现在控制台。\n89年形式\n这为什么会发生?\n当我们把一种形式在一个网页,浏览器假设我们想要的数据\n,并将其发送。问题是,当使用流星,我们不想\n发送数据在任何地方——我们想要保持在当前页面——但这不是\n标准行为浏览器而言,web页面刷新。\n知道了这一点,我们必须禁用默认行为,web浏览器连接到表单。\n这需要两个步骤。\n90年形式\n事件对象,第1部分\n从一颗流星应用程序内触发事件时,我们可以访问的信息\n该事件发生。这听起来可能很奇怪,但展示我的意思是,修改提交\n表单事件如下:\n提交表单:函数(事件){\n控制台。日志(“形式提交”);\nconsole.log(event.type);\n}\n在这里,我们通过这个“事件”关键字通过事件的函数的括号,然后\n输出事件的价值。输入到控制台。\n这个结果是双重的:\n首先,任何关键字通过事件的函数的括号作为第一个参数\n变成了一个参考。因为我们通过“事件”关键字,我们\n可以参考事件在事件的函数使用关键字。但是,您可以使用\n您所喜欢的任何一个字。(一种常见的惯例是使用“evt”或“e”而不是“事件”)。\n第二,事件。类型是指的“type”属性事件对象。作为一个结果,\n这段代码应该输出控制台“提交”这个词,因为这是事件的类型\n被触发。\n这并不能解决原来的问题尽管由于我们的页面刷新时表单\n提交,我们不能看到控制台。日志语句。\n为了解决这个问题,使用preventDefault函数:\n提交表单:函数(事件){\nevent.preventDefault();\n控制台。日志(“形式提交”);\nconsole.log(event.type);\n}\n当附加到事件对象,这个preventDefault函数阻止默认行为\n事件的发生。因为我们已经附加函数提交表单事件:\n1。默认情况下,提交表单不会做任何事情。\n2。我们需要手动定义表单的功能。\n3所示。控制台。日志语句现在将正常工作。\n保存文件,切换回Chrome和测试表单,它不再是刷新\n页面。\n91年形式\n控制的形式。\n注意:preventDefault函数不仅适用于形式。例如,你可以\n完全控制的链接在一个模板:\n“点击”:函数(事件){\nevent.preventDefault();\n}\n有了这个代码,模板中的任何一个元素不会像他们通常\n会。你必须手动分配功能。\n92年形式\n事件对象,第2部分\n现在我们已经完全控制的形式,我们希望提交表单的事件的\n“playerName”文本框的内容提交表单时,和使用价值\n添加一个球员到数据库。\n首先,创建一个名为“playerNameVar”的变量:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar;\n}\n然后让这个变量等于“event.target。playerName”和输出变量的值\n控制台:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName;\nconsole.log(playerNameVar);\n}\n这语句使用事件对象获取任何HTML元素的name属性\n设置为“playerName”。\n但这段代码不工作正如你所想的那样,因为控制台。日志语句输出\n的原始HTML文本字段,而不是它的价值:\n抓住整个文本字段。\n这是因为我们需要显式地检索价值属性:\n93年形式\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nconsole.log(playerNameVar);\n}\n基于这种变化,无论用户输入文本字段将“playerName”\n提交表单时输出到控制台。\n文本字段的值出现在控制台。\n提交的播放器插入“PlayersList”收藏,添加里面的插入功能\n提交表单的事件:\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n而不是通过一个硬编码值名称字段,如“大卫”或“Bob”,通过\n通过“playerNameVar”变量的引用。\n现在事件的代码应该类似于:\n94年形式\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n}\n和现在应该像预期的那样工作。\n凯尔被添加到排行榜。\n95年形式\n删除玩家\n自从我们成为可能添加球员排行榜,这是一个好主意让它成为可能\n也从排行榜中删除玩家。\n为了实现这一点,首先创建一个“删除玩家”按钮在“排行榜”模板:\n< input type = \" button \" class = \"删除\" value = \"删除玩家\" >\n与其他按钮在这个项目中,附加一个独特的类属性,我们可以参考\n按钮的事件。\n在JavaScript文件,将下列事件附加到“排行榜”模板:\n的点击。删除”:函数(){\n/ /代码在这里\n}\n检索的ID选择球员的“selectedPlayer”会话:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n然后使用从集合中删除功能,删除选中的球员:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList.remove(selectedPlayer);\n}\n我们还没有谈到了去除函数,但没什么多说的。所有\n我们要做的就是通过文档的惟一的ID作为唯一的参数。该文档\n将从集合中删除。\n用户将可以从列表中删除的球员。\n96年形式\n总结\n在这一章,我们了解到:\n•通过使用submit事件类型,我们可以触发时执行代码是一种形式\n提交。\n•使用提交事件而不是单击事件以来可以提交的一种形式\n许多不同的方式(如“返回”键。)。\n•我们可以从内部访问信息的一个事件,事件的功能,和也\n操纵事件发生。\n•浏览器的默认行为附加到形式,干扰我们的代码,但这一点\n行为与preventDefault函数可以禁用。\n•当表单字段名称属性,有一个简单的语法的价值\n表单字段。\n•通过Mongo文档的ID通过删除功能,我们可以删除\n特定的文档集合。\n流星的更深层次的理解:\n•所以,后提交“添加球员”的形式,“playerName”文本的价值\n字段是重置为空值。\n•创建一个警告,要求用户确认他们是否真的想要删除一个\n球员后从列表中点击“删除的球员”按钮。\n•“分数”字段添加到“添加球员”形式,允许用户定义一个球员的得分\n当他们被提交到列表中。\n在其当前状态查看代码,查看GitHub提交。\n\n\n账户\n我们的应用程序有许多有用的特性,但仍只支持单个球员的名单。\n这意味着只能有一个用户应用程序在任何特定的时间,也就是\n愚蠢的网络应用程序。\n为了解决这个问题,我们将创建一个用户帐户系统,这样是最简单的一个\n我们可以做的事情与框架。\n有了这个系统,我们将使它如此:\n•用户可以注册并登录到应用程序。\n•注销用户不会看到“添加球员”的形式。\n•每个用户将有自己的独特的排行榜。\n它的很多功能,但不会花很多的代码。\n97年\n账户98\n登录供应商\n扩展我们的流星的功能项目在几秒钟之内,我们可以安装一个范围\n包,包基本上是插件:\n1。重要的功能添加到一个项目。\n2。减少我们需要编写的代码量。\n默认情况下,每个流星项目本地访问官方包的数量。这些都是\n包,大多数开发人员需要使用在某种程度上,但不一定\n在每一个项目。(也有成千上万的第三方包,但是他们超出了\n这本书的范围,所以我们将只关注官方包。)\n添加一个用户帐户系统我们的项目,我们将首先安装一个“登录供应商”包。这些\n包使它非常容易为一个账户系统添加一个后端应用程序。\n例如,通常创建一个用户帐户系统将涉及创建一个收集的\n用户的数据:\nuseraccount = new Mongo.Collection(“用户”);\n然后编写应用程序逻辑注册和登录,等等。\n但在处理流星时,所有我们要做的是切换到命令行并运行\n下面的命令:\n流星添加accounts-password\n这里,我们将这个“accounts-password”包添加到项目中。这个包创建\n后端账户系统依赖于电子邮件和密码注册和日志记录\n在。\n账户99\naccounts-password包添加到项目中。\n具体地说,这个包:\n1。创建了一个集合存储注册用户的数据。\n2。为我们提供了一系列有用的功能我们很快就会讨论。\n其他登录供应商包可用,允许用户登录到我们的应用程序\n通过服务像谷歌和Facebook,但因为这增加了一个额外的步骤流程,\n我们专注于电子邮件和密码系统。\n账户100\nMeteor.users\n一旦“accounts-password”包添加到项目中,自动集合\n用来存储数据的注册用户。这个集合被称为流星。用户和它\n工作就像我们可以创建自己的任何集合。\n为了说明这一点,下面的命令输入到控制台:\nMeteor.users\n返回的信息证实,这只是一个普通的集合:\n检查出流星。用户收藏。\n知道了这一点,我们可以使用查找和获取功能集合:\n.fetch Meteor.users.find()();\n但由于没有注册用户,将返回任何数据。\n账户101\n登录界面\n我们已经设置账户的后端系统,但是前端呢?是\n我们将编写接口代码,允许人们注册和登录和改变他们\n帐户详细信息吗?\n不。\n我们可以创建一个定制的界面,它实际上是一个非常简单的事情,但有一个更容易\n办法尽快启动并运行。\n即时向项目添加账户系统的前端,我们只是必须安装\n“accounts-ui”包:\n流星添加accounts-ui\n然后,一旦安装,以下正文标签之间的HTML文件(或在一个\n的模板):\n{ { > loginButtons } }\n这里,我们包括这种“loginButtons”模板,这是包含在“accounts-ui”\n包中。因为这个包被添加到这个项目中,我们现在可以包括这个模板\n任何我们想要的接口。\n看看这个模板包含,保存文件并切换到浏览器。你会注意到一个”的迹象\n出现在“按钮,当点击,一个登录表单和一个“创建帐户”链接将出现:\n账户102\n一个即时的接口。\n虽然这不是一个纯粹的虚拟接口。已经没有任何配置,这是有可能的\n用户注册、登录和注销。没有理由做这些事情——注册\n和非注册用户将看到相同的内容,但这是我们将在未来解决\n部分。\n现在,使用查找和获取函数的流星。用户组:\n账户103\n第一个用户的数据。\n返回你会注意到一个文档,该文档包含的数据\n这是刚刚创建的。您可以单击箭头看到面临的下行数据联系在一起\n该帐户。\n账户104\n登录状态\n目前,未注册用户可以看到“添加球员”形式,不赚很多\n有意义的。这种形式注册用户只能访问。\n为了达到这个目标,改变“addPlayerForm”模板如下:\n<模板名称= \" addPlayerForm \" >\n{ { #如果currentUser } }\n<形式>\n< input type = \" text \" name = \" playerName \" >\n< input type = \" submit \" value = \"添加球员\" >\n> < /形式\n{ { /如果} }\n< /模板>\n在这里,我们指的是这个currentUser对象检查当前用户是否已登录。\n这个对象所提供的“accounts-password”包,和逻辑很简单:\n1。如果当前用户登录,currentUser将返回true。\n2。如果当前用户没有登录,currentUser将返回false。\n因此,只有几行代码,我们使它所以只有登录用户可以\n(相互作用)的形式。\n账户105\n为每个用户分配一个排行榜\n使我们的应用程序有些有用的更广泛的受众,我们需要让每一个\n注册用户可以自己独立的球员名单。它可能不明显\n我们怎么做这个,最困难的一点编程弄清楚吗\n如何处理这样的问题,但这个过程本身不涉及很多步骤。\n首先,下面的语句:\nvar currentUserId = Meteor.userId();\n提交表单事件:内…\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0\n});\n}\n在这里,我们创建这个“currentUserId”变量,存储返回的值的\n流星。标识功能。我们还没有谈到这个函数,但并不多\n解释一下。它只是返回当前登录用户的惟一ID。\n然后添加一个“createdBy”字段中插入功能,并通过“currentUserId”\n变量:\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n因此,当用户添加一个球员排行榜,该用户的惟一ID\n与玩家相关的补充道。\n为了演示这个:\n1。保存文件。\n2。切换回Chrome。\n3所示。添加一个球员排行榜。\n账户106\n然后使用“PlayersList”上的发现和获取函数集合,并单击downwardfacing\n箭头为最近创建的文档。您将看到如何该文档包含了\n用户的ID此玩家添加到集合中。\n将一个球员与一个用户相关联。\n接下来,我们将修改玩家helper函数:\n“球员”:函数(){\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n首先,设置另一个“currentUserId”变量:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n然后改变返回语句,所以只返回球员当他们createdBy字段是相等的\n当前登录用户的惟一ID:\n账户107\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ createdBy:currentUserId },\n{:{分数:1,名字:1 } });\n}\n这可以确保用户只能看到球员他们添加到排行榜中,从而产生的效应\n,每个用户都有自己的独特的球员名单。\n只看到球员属于当前用户。\n账户108\n项目重置\n目前,有一些球员在数据库没有连接到任何特定的人\n用户——球员被添加到前一节中——这意味着我们之前数据库\n不需要他们在我们集合。\n给自己一个全新的开始,然后,切换到命令行,停止与CTRL本地服务器\n+ C,输入以下命令:\n流星重置\n这将勾销数据库,因为我们写的代码在前一节中,\n此时玩家添加到集合将被附加到当前登录的用户。\n你可能会发现自己使用这个命令半定期,大量无用的数据很容易\n在开发过程中填充数据库。\n账户109\n总结\n在这一章,我们了解到:\n•包让我们迅速向应用程序添加功能。有一些官员\n包,还有成千上万的第三方包。\n•“登录供应商”包来创建一个账户的后端系统。我们可以\n创建一个后端,依赖于电子邮件和密码,或者像Twitter和服务\nFacebook(或服务)的组合。\n•安装登录提供者包之后,一颗流星。用户自动收集\n用来存储数据的注册用户。\n•accounts-ui包允许我们快速添加一个账户系统的用户界面\n一个项目。你可以把一个自定义的方法,但这个样板的方法是伟大的\n对于初学者来说。\n•我们可以检查当前用户是否已登录通过引用curentUser\n对象从一个模板。\n•的惟一的ID来检索当前登录的用户,我们可以使用Meteor.userId()\n函数。\n流星的更深层次的理解:\n•安装一个不同的登录供应商包装,像accounts-twitter包(但\n确定accounts-ui包也是安装)。\n•浏览atmospherejs.com查看很多第三方包\n流星。\n在其当前状态查看代码,查看GitHub提交。\n\n\n\n发布与订阅\n到目前为止,我们已经构建了一个功能丰富的应用程序与流星,但我们没有说什么\n安全,这是一个很大的网络软件开发的一部分。在大多数情况下,我想要的\n向你们展示如何构建尽可能快速和简单的东西,但也有几个\n安全我们应该谈论的话题前发布到web项目。\n首先,让我们来谈谈出版物和订阅。\n110年\n发布和订阅111\n数据安全\n展示我们的项目的一个安全缺陷:\n1。注册两个单独的用户帐户。\n2。每个帐户下,添加三个球员。\n3所示。注销的账户。\n正因为如此,共有6名球员应该存在在数据库和他们应该“属于”\n总共有两个用户。\n下一步,使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n你会注意到,我们以前见过,所有返回的数据收集。我们可以\n看到所有的数据属于两个用户。但这实际上是一个问题。因为除非\n我们关闭这个功能,这个应用程序的每个用户将有同样的,肆无忌惮的访问权\n每一个数据库内的数据。没有什么阻止他们深入挖掘\n“PlayersList”收集的发现和获取功能。\n访问所有的数据。\n这个项目的数据不是特别敏感,它不像我们存储信用卡号码\n——但:\n发布和订阅112\n1。如果我们存储敏感数据,这将是一个不可原谅的监督。\n2。它有害的实践数据提供给用户当它不是必需的。\n然而,这并乞求问题:\n为什么这个功能存在的流星?如果是这样一个巨大的安全风险来访问数据\n通过控制台,为什么允许这样做吗?\n很简单,方便。在本书中,我们已经使用查找和获取\n函数和他们伟大的工具来管理和操作的内容\n数据库。只是,在我们与世界分享应用程序之前,我们必须:\n1。禁用这种默认行为,限制访问的大部分数据。\n2。精确地定义数据应该提供给特定的用户。\n这就是我们将讨论接下来的章节。\n发布和订阅113\nautopublish\n功能,允许我们使用控制台导航项目的数据\n包含在一个“autopublish”包包含在默认情况下每个流星项目。\n如果我们删除这个包,用户无法通过控制台访问任何数据,但它\n也将打破应用程序,因此我们需要采取一些额外的步骤。\n删除“autopublish”包从项目,运行以下命令:\n流星删除autopublish\n如果你登录的用户帐户删除包的时候,你不会注意到\n任何不同,但尝试发现和获取功能:\n.fetch PlayersList.find()();\n你会注意到我们再也不能浏览里面的数据集合。唯一的\n返回一个空数组。它看起来像数据已被删除,但事实并非如此。\n它只是被获得。\n现在问题是,我们的数据安全,因为如果我们登录的用户帐户,\n数据也无法访问的接口:\n没有可用的数据。\n为了解决这个问题,我们需要找到一些我们面临的两个极端——之间的中间立场\n一切都被访问和没有被访问。这涉及到精确的定义\n数据应该提供给我们的用户。\n发布和订阅114\nisServer\n在本书中,我们主要是在isClient条件编写代码。这是\n因为我们大多写的代码意味着浏览器内运行(如代码\n影响界面)。然而,很多情况下我们希望代码运行\n在服务器上。\n为了演示这些情况之一,地方在isServer如下声明\n在JavaScript文件的条件:\n.fetch console.log(PlayersList.find()());\n不出所料,输出出现在命令行(而不是控制台),但要注意\n我们没有任何麻烦检索“PlayersList”收集的数据。即使在\n删除“autopublish”计划,我们有自由统治的数据直接在工作\n与服务器。\n为什么?\n嗯,在服务器上执行的代码本身是可信的。所以,当我们停止用户\n应用程序访问数据的前端——在客户端——我们可以继续\n在服务器上检索数据。\n你很快就会知道这个细节的有效性。\n发布和订阅115\n出版物,第1部分\n在本节中,我们将发布“PlayersList”内的数据收集,和\n从概念上讲,你能想到的出版数据传输数据到从服务器\n醚。我们只是指定哪些数据应该提供给用户。我们不关心的地方\n最终的数据。\n为了实现这一点,删除控制台。日志声明isServer条件和替换它\n一颗流星。发布功能:\nMeteor.publish();\n这个函数的括号之间,通过“应”作为第一个参数:\nMeteor.publish(球员);\n这个论点是一个名字,我们会参考。\n然后,作为第二个参数,通过一个函数:\n流星。发布(“球员”,函数(){\n/ /内部发布功能\n});\n在这个函数,我们指定哪些数据应该提供给应用程序的用户。\n在这种情况下,我们将返回所有的“PlayersList”收集的数据:\n流星。发布(“球员”,函数(){\n返回PlayersList.find()\n});\n这段代码复制autopublish的功能,这意味着它不是我们什么\n想要的,但这是一个正确方向的一步。\n发布和订阅116\n订阅\n因为流星。发布在服务器上执行的函数,我们现在可以订阅\n这些数据在isClient条件,再一次做项目的数据访问\n通过浏览器和控制台。\n如果你想象一下,发布功能是传输数据到醚,然后订阅\n函数是我们使用“捕捉”数据。\n在isClient条件,写如下:\nMeteor.subscribe();\n这是流星。订阅功能,唯一的参数,我们需要通过\n发布函数的名称:\nMeteor.subscribe(球员);\n保存文件,然后使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n你会注意到,再一次,我们可以访问所有的数据从项目的数据库,\n意味着我们的应用程序是回到原来的状态。这还不是我们想要的,但这是另一个\n重要的一步。\n发布的所有数据。\n发布和订阅117\n出版物,第2部分\n现在的目标是让流星。发布函数只从服务器发布数据\n属于当前登录的用户。\n这意味着:\n1。登录用户只能访问自己的数据。\n2。注销用户没有访问任何数据。\n最后,应用程序将全功能保护潜在的敏感\n数据。\n为了达到这个目标,我们需要访问当前登录用户的惟一ID从内\n流星。发布功能。在这个函数,我们不能使用Meteor.userId()\n之前的功能。相反,我们必须使用下面的语句:\nthis.userId;\n虽然语法是不同的,最终的结果是一样的。该语句返回唯一的\n当前登录用户的ID。\n声明在“currentUserId”变量:\n流星。发布(“球员”,函数(){\nvar currentUserId = this.userId;\n返回PlayersList.find()\n});\n然后改变找到函数只所以检索文档createdBy字段是相等的\n当前登录用户的ID:\n流星。发布(“球员”,函数(){\nvar currentUserId = this.userId;\nPlayersList返回。找到({ createdBy:currentUserId })\n});\n保存文件,然后使用“PlayersList”上的发现和获取功能集合:\n.fetch PlayersList.find()();\n如果你登录,您只会看到的数据属于当前用户的帐户,如果\n你没有登录,你不会看到任何数据。这是因为内部的返回语句\n流星。发布函数只能返回文档,包含当前的惟一ID\n用户。\n发布和订阅118\n返回一个有限选择的数据。\n也知道,我们现在可以简化玩家从这个函数:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ createdBy:currentUserId },\n{:{分数:1,名字:1 } });\n}\n…:\n“球员”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList返回。找到({ },{:{分数:1,名字:1 } });\n}\n为什么?\n因为球员内部的返回语句函数只能检索数据\n从服务器发布。因此,指定要检索用户的数据\n两个地方是多余的。我们只需要定义Meteor.publish中返回的数据\n函数。\n发布和订阅119\n总结\n在这一章,我们了解到:\n•在默认情况下,所有的数据在一个流星项目的数据库提供给所有用户\n应用程序。这是方便的在开发期间,但它也是一个很大的安全漏洞\n需要在部署前固定。\n•这个默认功能都包含在一个“autopublish”包。如果我们删除这个\n计划,项目将更安全,但它也会打破,需要固定的。\n•流星。发布函数定义哪些数据应该在服务器端\n提供给应用程序的用户。\n•流星。订阅功能是用于客户端检索的数据\n从服务器发布。\n•在发布功能,我们不能使用Meteor.userId()函数,但我们可以\n与this.userId检索当前用户的ID。\n在其当前状态查看代码,查看GitHub提交。\n\n\n方法\n在前面的章节中,我们讨论的第一个包含两个主要的安全问题\n每颗流星项目默认情况下。这个问题是用户通过导航的能力\n所有的数据在数据库内部,直到我们把“autopublish”包。基于这些\n我们做了改变,用户现在只有访问“属于”的数据。\n为了演示第二个主要安全问题,输入以下命令控制台:\nPlayersList。插入({ name:“伪玩家”,分数:1000 });\n看有什么问题吗?\n虽然我们已经取得了它所以用户不能浏览所有的数据在数据库中,用户\n仍然能够自由使用控制台插入数据到数据库中。这意味着用户可以:\n1。利用应用程序自己的优势。\n2。数据库填充无用的、多余的数据。\n用户还能够从数据库修改和删除数据,意味着在默认情况下,\n他们主要有完全的管理权限。\n与前面的安全问题,这个特性是当我们开发一个方便\n应用程序,因为它很容易创建和管理数据,但这是一个我们需要的特性\n关闭之前部署。\n此功能包含在一个“没有安全感”包,我们可以删除它\n项目使用下面的命令:\n流星消除不安全的\n删除包后,切换回Chrome和尝试和应用程序。\n你会注意到:\n•我们再也不能给分的球员。\n•我们再也不能拿分的球员。\n•我们再也不能从列表中移除玩家。\n•我们再也不能将玩家添加到列表。\n所有的插入、更新和删除功能停止工作——都通过\n接口和控制台应用程序,所以更安全的结果,但是我们会有\n解决很多事情。\n120年\n方法对121\n创建一个方法\n直到这个时候,所有的插入、更新和删除功能已经在isClient\n有条件的。这是快速和容易的方法,但这也是为什么我们的应用程序\n天生没有安全感。我们已经把这些敏感,clientside数据库驱动的功能。\n更安全的做法是将这些函数isServer条件,也就是说:\n1。数据库代码将执行服务器的可信的环境中。\n2。用户无法使用这些函数从控制台,因为用户没有\n直接访问服务器。\n为了实现这一点,我们将创建我们的第一个方法,方法执行的代码块\n在服务器上被触发后从客户端。如果这听起来奇怪,不要害怕。这是\n其中的一次,之后在写出代码将帮助解释很多。\n在isServer条件,写如下:\nMeteor.methods({\n/ /方法去这里\n});\n这是我们将使用代码块来创建我们的方法。你会发现语法很相似\n我们如何创建两个助手和事件。\n为了演示什么方法,创建一个“sendLogMessage”的方法:\nMeteor.methods({\n“sendLogMessage”\n});\n然后将该方法与功能:\nMeteor.methods({\n“sendLogMessage”:函数(){\n控制台。日志(“Hello world”);\n}\n});\n接下来,“电话”这个方法从底部的提交表单事件附加到“addPlayer -\n形成“模板:\n方法对122\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.playerName.value;\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\nMeteor.call(“sendLogMessage”);\n}\n通过使用这颗流星。调用语句,通过我们创建的方法的名称,\n我们能够触发方法时的执行“添加球员”提交表单。\n保存文件,切换回Chrome,并提交“添加球员”形式。核心功能\n这种形式的仍然是破碎的,但是如果你切换到命令行,您将看到“Hello\n世界”的消息似乎每次提交表单。客户端表单的提交\n触发的方法,但实际代码的方法是在服务器上执行。\n代码在服务器上执行,导致当我们提交表单。\n这个基本原则是我们在本章的其余部分使用。\n方法对123\n插入数据(再一次)\n再次让应用程序工作,我们首先将插入函数里面提交\n表单事件从客户机和服务器。\n这意味着:\n1。插入函数将成功地和安全地运行在服务器上。\n2。用户仍然无法通过控制台插入数据。\n换句话说,“添加球员”提交表单时,插入函数将触发\n服务器从客户端触发后。\n首先,“sendLogMessage”方法的名称更改为“insertPlayerData”,和摆脱\n控制台。日志语句:\nMeteor.methods({\n“insertPlayerData”:函数(){\n/ /代码在这里\n}\n});\n在方法内部,抓住当前登录用户的惟一ID:\nMeteor.methods({\n“insertPlayerData”:函数(){\nvar currentUserId = Meteor.userId();\n}\n});\n然后下面添加一个熟悉的插入函数声明:\nMeteor.methods({\n“insertPlayerData”:函数(){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:“大卫”,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n这里,我们通过一个硬编码值的“大卫”,这并不是我们所想要的,\n但这已经足够好了。\n返回到提交表单事件和删除currentUserId变量和插入\n函数。事件应该类似于:\n方法对124\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nMeteor.call(“sendLogMessage”);\n}\n但也一定要通过正确的方法名流星。调用语句:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\nMeteor.call(“insertPlayerData”);\n}\n基于这些变化,“添加球员”形式将现在的工作。如果我们提交表单,\n一个球员将被添加到“PlayersList”集合。我们只能添加球员叫“大卫”,\n但在下一节我们将解决这个问题。\n再次插入函数的工作。\n现在,重要的是,用户可以添加玩家通过列表形式,\n他们不能够使用插入函数从控制台。这意味着我们获得\n控制用户如何与数据库的交互,这是一个保持应用程序的重要组成部分\n安全。\n方法对125\n传递参数\n“添加球员”形式的问题是文本字段的值没有被传递到\n该方法。这样,当我们提交表单时,创建的球员的名字将永远\n被设置为“大卫”。\n为了解决这个问题,通过“playerNameVar”变量通过流星。调用语句作为第二\n论点:\n提交表单:函数(事件){\nevent.preventDefault();\nvar playerNameVar = event.target.playerName.value;\n流星。调用(insertPlayerData,playerNameVar);\n}\n然后允许接受这个论点的方法通过将“playerNameVar”之间\n括号的方法的功能:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:“大卫”,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n正因为如此,我们现在可以参考“playerNameVar”参考用户的价值\n进入表单的文本字段:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n}\n});\n最后,这是发生了什么:\n方法对126\n首先,当提交表单时,“insertPlayerData”方法被调用时,和的值\n表单的文本字段附加到电话。\n第二,执行“insertPlayerData”方法。该方法接受的价值\n“playerNameVar”变量,然后从里面引用变量方法的功能。\n第三,插入函数内执行方法,因为这段代码运行在服务器上,\n它可以运行没有“安全感”包。与刚才不同,这个函数使用价值\n来自表单的文本字段,而不是硬编码的“大卫”的价值。\n创建的球员与原名称。\n表单将再次工作的预期,但仍然会是没有为用户操作方法\n数据通过控制台。\n方法对127\n删除玩家(再一次)\n以同样的方式,我们创建了一个“insertPlayerData”变量,我们要创建一个“removePlayerData”\n方法,我们将连接到“删除的球员”按钮,里面是我们的接口。\n就像我们如何创建助手和事件,我们的位置在一个代码块的方法,\n记住要用逗号分开的方法:\nMeteor.methods({\n“insertPlayerData”:函数(playerNameVar){\nvar currentUserId = Meteor.userId();\nPlayersList.insert({\n名称:playerNameVar,\n得分:0,\ncreatedBy:currentUserId\n});\n},\n“removePlayerData”:函数(){\n/ /代码在这里\n}\n});\n然后我们会点击两个变化。删除事件:\n首先,去掉删除功能:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n在它的位置,创建另一个流星。调用语句:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nMeteor.call(“removePlayerData”);\n}\n通过“selectedPlayer”变量,第二个参数:\n的点击。删除”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(removePlayerData,selectedPlayer);\n}\n允许接受这个论点的方法:\n方法对128\n“removePlayerData”:函数(selectedPlayer){\n/ /代码在这里\n}\n然后重新创建删除方法内部的函数:\n“removePlayerData”:函数(selectedPlayer){\nPlayersList.remove(selectedPlayer);\n}\n“删除玩家”按钮将按预期工作,但用户仍然没有完成\n管理访问数据库相关函数在控制台。\n清除旧数据。\n然而,一个挥之不去的问题…\n因为“removePlayerData”方法执行从客户端,用户可以执行\n同样的自称,从控制台:\n流星。调用(' removePlayerData ',' 8 sad8a90d8s9ad ');\n因此,尽管他们没有获得全方位的插入、更新和删除功能\n能做的,他们仍然可以做一些伤害。例如,他们可以运行这个命令来删除一个\n玩家从另一个用户的列表。\n这不是一个悲剧的巨大的安全漏洞,但这是我们应该解决的\n准备在未来安全漏洞。\n最好的做法是改变“removePlayerData”从这个方法:\n方法对129\n“removePlayerData”:函数(selectedPlayer){\nPlayersList.remove(selectedPlayer);\n}\n…:\n“removePlayerData”:函数(selectedPlayer){\nvar currentUserId = Meteor.userId();\nPlayersList。remove({ _id:selectedPlayer createdBy:currentUserId });\n}\n有了这段代码,该方法将只允许玩家从列表中被删除\n球员属于当前用户。\n注意:你可能会认为它不太可能用户会让这样一个混乱与另一个\n用户的排行榜,但当涉及到安全,最好不要低估人民的能力\n和渴望肆虐。\n方法对130\n修改分数\n在这一章,我们已经使用方法为了安全,但我们也可以使用\n方法来减少我们的项目代码的数量。\n为了说明这一点,我们要结合点击。增加并单击。衰减事件\n成一个单一的方法。这是有可能的,因为有很多的这些事件之间共享代码:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n},\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n事实上,唯一的区别是在点击。增加事件,我们传递一个值\n通过公司操作符“5”,而在点击。衰减事件,我们通过\n一个“5”的价值。\n改善这段代码中,我们首先关注点击。增量的事件。\n在事件中,删除更新函数,代之以一个流星。调用语句:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(modifyPlayerScore,selectedPlayer);\n}\n这里,我们称之为“modifyPlayerScore”的方法,这是一个我们将创建方法\n时刻,我们通过“selectedPlayer”变量。\n创建内部的“modifyPlayerScore”方法方法:\n“modifyPlayerScore”:函数(){\n/ /代码在这里\n}\n…,让这个方法接受的价值“selectedPlayer”:\n“modifyPlayerScore”:函数(selectedPlayer){\n/ /代码在这里\n}\n然后,在该方法的功能,重新创建更新函数,我们刚才删除:\n方法对131\n“modifyPlayerScore”:函数(selectedPlayer){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n基于此代码,“给5分”按钮将正常工作。使更多的方法\n不过,灵活返回点击。增加事件和通过“5”的第三个参数\n流星。调用语句:\n的点击。增量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(‘modifyPlayerScore selectedPlayer 5);\n}\n允许接受这个第三个参数的方法:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });\n}\n取代“5”的价值,在这个新创建的引用的方法\n“scoreValue”属性:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });\n}\n由于这一变化,现在的方法是足够灵活,我们可以用它来“给\n5分”按钮和“5分”按钮。\n这里有…\n首先,从内部点击删除更新函数。衰减事件:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n}\n第二,一颗流星。调用语句在这个事件:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\nMeteor.call(“modifyPlayerScore”);\n}\n第三,通过“selectedPlayer”变量的值:\n方法对132\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(modifyPlayerScore,selectedPlayer);\n}\n第四,通过“5”的价值,而不只是“5”:\n的点击。减量”:函数(){\nvar selectedPlayer = Session.get(“selectedPlayer”);\n流星。调用(‘modifyPlayerScore selectedPlayer 5);\n}\n看到我们所做的吗?\n我们已经取得了如此“modifyPlayerScore”方法的效用取决于我们通过\n第三个参数:\n1。如果我们通过一个“5”,更新函数增量的值\n“分数”字段。\n2。如果我们通过一个“5”,更新函数递减的价值\n“分数”字段。\n因此,该方法允许代码既灵活又安全。\n我们有相同的安全缺陷前一节中,一个用户可以输入\n下面的命令在控制台修改数据库中的任何球员的得分:\n流星。调用(‘modifyPlayerScore’,‘8 sad8a90d8s9ad’,100);\n但解决方案也是一样的。\n从这只改变方法的内容:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nPlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });\n}\n…:\n“modifyPlayerScore”:函数(selectedPlayer scoreValue){\nvar currentUserId = Meteor.userId();\nPlayersList。更新({ _id:selectedPlayer createdBy:currentUserId },\n{ $ . n:行情):{得分:scoreValue } });\n}\n再次,我们检索当前登录用户的惟一的ID,并在更新\n正在更新功能,确保玩家“属于”用户。如果登录用户\n并不“拥有”的球员,球员的文档不会被发现的更新功能。\n方法对133\n总结\n在这一章,我们了解到:\n•在默认情况下,有可能为用户插入、更新和删除数据的收集\n使用JavaScript控制台。这对于开发方便,但存在安全风险\n部署web应用程序。\n•修复这个安全风险,我们必须从客户端数据库相关代码,\n服务器的信任的环境。在这里,用户不会有任何直接访问(或\n控制)数据库。\n•这个安全风险是包含在一个“没有安全感”包。通过移除这个包,\n应用程序将变得更加安全,但它也会休息,因为没有一个databaserelated\n功能将工作。\n•通过使用方法,我们能够编写代码在服务器上运行后第一个被触发\n从客户端。这是我们如何修复项目的破碎功能。\n•创建方法,我们可以在方法中定义块,然后触发\n从其他地方的代码使用流星。调用语句。\n•我们可以从流星传递数据。调用语句和方法,让我们\n使用提交的数据表单内的方法。\n•用户可以执行客户端流星。通过控制台调用语句,所以我们需要\n注意这些语句允许用户做什么。\n•方法不仅适用于安全。他们也有用结合相似的块\n的功能到一个小的和可重复的代码片段。\n流星的更深层次的理解:\n•在一个新项目,首先删除“不安全”计划,从一开始,地方\n里面所有的数据库相关代码的方法。\n在其当前状态查看代码,查看GitHub提交。\n\n\n结构\n在本书中,我们把所有的项目的代码仅仅三个文件:\n•leaderboard.html\n•leaderboard.js\n•leaderboard.css\n这使得我们关注的基本面与流星没有构建软件\n担心代码是如何组织的,该项目是非常简单的,所以我们需要不\n需要其他文件,但:\n1。在构建大型应用程序,是有意义的传播项目的代码在一个\n数量的文件。\n2。流星有许多公约组织项目的文件。\n在我们继续之前,有两个问题需要考虑:\n首先,流星没有硬性规定如何构造一个项目。有\n流星鼓励某些准则,但没有严格的,你必须做的。你的喜好\n最终在控制。\n第二,人们仍然找出最佳实践在处理流星。因此,\n没有理由形式教条的观点项目“应该”是如何构造的。允许\n自己的实验。\n这一章也不同,我们不会重组项目step-bystep排行榜。\n相反,我们将讨论结构的原则,这些原则,这就是你的工作\n付诸实践。\n不过别担心。\n基于我们覆盖到目前为止,处理如何构造一颗流星\n应用程序将是小菜一碟。\n134年\n结构135\n你的项目,你的选择\n就像我说的,流星没有硬性规定如何组织一个项目。它不\n关心如何组织你的文件和文件夹,如果你想创建一个大型项目\n只是三个文件,你可以。\n不过,与这种灵活性带来选择的矛盾:\n如果你不局限于精确的规则,如何构建您的项目吗?\n如果你是一个开发人员开始,您的项目结构尽可能简单的只要你\n可以。这意味着传播您的代码在仅仅三个文件——HTML,JavaScript,和CSS\n文件,直到这些文件变得过于臃肿的轻松地管理。这是罕见的一个实际的应用\n包含在这样一个小结构,但如果你只是开始使用流星,它是\n不生产为“完美”的结构。\n仍然阅读这一章,有一些重要的约定要注意——但不要\n觉得有必要实现每一个细节。最佳实践更容易学习一次\n基本面已经吸收了,只要你是一个初学者,你可以变得很糟。\n如果你不是一个开发人员,这意味着开始,如果你有网站开发经验,\n和没有任何麻烦连同这本书,那么你会有一个简单的时间\n实现约定我们要讨论。\n结构136\n脂肪薄文件,文件\n当创建一个流星应用程序时,项目的文件可以作为“瘦”或“脂肪”,因为我们想要的\n他们是。这意味着:\n1。我们可以传播许多文件的代码。\n2。我们可以包很多每个文件(或小)代码。\n例如,让我们考虑一下”排行榜。html文件。不是脂肪,但它确实包含了\n三个组件,虽然连接,不需要包含在单一文件:\n•页面的HTML结构(头部标签,身体标签等)。\n•“排行榜”模板。\n•“addPlayerForm”模板。\n如果这个项目变得越来越大,这将使这些组件拆分为三个\n单独的文件。例如,你可能会想:\n1。离开的HTML结构”排行榜。html文件。\n2。把“排行榜”的“leaderboardList模板。html文件。\n3所示。移动模板,一个“addPlayerForm addPlayerForm。html文件。\n因此,它会更容易导航项目的文件因为每个文件的名称\n暗示这文件包含什么。\n需要澄清的是:\n1。没有额外的步骤。把代码项目,无论你想要的\n流星将知道如何把片段组合在一起。\n2。文件名称是任意的。有一些“特殊”的文件名需要注意的,但是\n一般来说,名字的文件,只要你喜欢就好。\n你也可以将文件在文件夹和子文件夹(深层结构),但在那里\n某些约定,鼓励某些命名这些文件夹的方法。\n结构137\n文件夹的约定,第1部分\n很多内部的代码”排行榜。js”isClient条件内的文件。如果我们传播\n这段代码在多个文件,它会不雅的重用这个条件\n一次。\n幸运的是,流星已经约定,任何的代码放在一个文件夹命名为“客户端”\n只会在客户端上运行。\n为了演示这个:\n1。创建一个文件夹命名为“客户”在您的项目的文件夹。\n2。在该文件夹中创建一个JavaScript文件。\n3所示。剪切和粘贴的客户端代码”排行榜。js文件到新的文件,但是\n没有isClient条件。\n在保存文件时,应用程序将继续正常工作。\n因为这个约定,最好是将模板,事件,助手,Meteor.subscribe\n函数在一个“客户端”文件夹中。\n相反,流星有约定的任何代码放置在一个文件夹命名\n“服务器”只会在服务器上运行。这是我们地方项目的方法,和\n流星。发表声明。\n洗牌代码在排行榜内部应用程序之后,唯一的,左内\n原始”排行榜。js文件将被声明,创建“PlayersList”集合。我们\n希望这段代码运行在客户端和服务器,所以一定要离开这个声明\n在“客户机”和“服务器”文件夹。一个常见的惯例是将这段代码在一个\n”集合。js文件,但是这个文件名字没有特别的意义。\n结构138\n文件夹约定,第2部分\n当开始使用流星,大多数项目的文件可能会在“客户端”\n或“服务器”文件夹。然而,一些其他的文件夹名称,可用于不同的\n用途:\n•文件存储在一个“私人”文件夹只能访问的代码的执行\n服务器。这些文件将永远不会访问用户。\n•文件存储在一个“公共”文件夹是游客服务。这些文件是图片,图标,\n和“机器人。txt文件。\n•文件存储在一个“自由”文件夹其他文件之前加载。\n但如果这一切似乎记得太多,不要害怕。这些细节是值得了解的\n未来的参考,但这将是一段时间你需要付诸实施了。目前,\n很好关注基础知识。\n结构139\n样板结构\n学习如何结构的一种有效方式流星项目向其他开发人员学习\n有可能遇到的许多问题有一天,你会遇到你。\n例如,“铁”工具从克里斯事件化思想的源泉:\n命令行脚手架流星应用程序的工具。它会自动创建\n项目的结构,文件和样板代码。\n这个工具可以用来快速创建一个项目使用以下结构:\n我的app /\n.iron /\njson\nbin /\n构建/\n配置/\n开发/\nenv.sh\nsettings.json\napp /\n客户端/\n集合/\nlib /\n样式表/\n模板/\nhead.html\nlib /\n集合/\n控制器/\nmethods.js\nroutes.js\n包/\n私人/\n公共/\n服务器/\n集合/\n控制器/\nlib /\nmethods.js\npublish.js\nbootstrap.js\n你会发现每件事都有它的位置。有文件夹集合和样式表\n模板和其他组件的一个项目。\n结构140\n这是最好的方法构造一颗流星项目吗?\n对一些人来说,它可能是。\n我认为这有点复杂的人与流星刚刚开始,但当\n你准备搬到一个更大的项目,它可能正是你需要管理\n较大的基础代码。\n在这个阶段,重点不是做出任何硬性的决定对你的偏好。但它\n帮助了解什么至少是可能的。\n其他样板值得一试,学习包括meteor-boilerplate和空白。\n结构141\n总结\n在这一章,我们了解到:\n•流星并不在项目执行精确的文件结构。有简单的约定\n我们鼓励遵守为了我们自己的利益。\n•通过命名特定文件夹,在某些方面,我们能够避免编写一些应用程序\n逻辑基于流星如何处理这些文件夹。\n流星的更深层次的理解:\n•搜索别人的流星在GitHub,看看真实的项目\n应用程序的结构。\n•想象你创建一个博客应用程序像WordPress。你会如何结构\n该应用程序?计划在一张纸上。\n在其当前状态查看代码,查看GitHub提交。\n\n部署\n在本书中,我们取得了很多的进步。我们决定在项目建设,创建\n所有的基本功能,添加了一些额外的细节,甚至谈到了几个\n常见的安全问题。\n因此,我们准备部署到web的应用程序。\n在这里我们可以分享我们的创造与世界然后等待成群的陌生人\n奇迹在我们的天才。但部署并不是简单的上传文件到web服务器。\n有更多的参与。\n这是一个广泛的部署过程的概述:\n1。创建一个服务器DigitalOcean等网站。\n2。在该服务器上安装所需的软件(节点,MongoDB,等等)。\n3所示。配置所有的安装软件。\n4所示。项目的文件上传到服务器。\n5。交叉你的手指,没有休息。\n听起来很复杂,对吗?\n不要担心,我有你覆盖。\n在这本书的前两个版本,我解释的绝对基础部署流星\n应用程序web但已经放在一起更全面的指导,分开\n从这本书。\n你可以免费在线阅读:\nmeteortips.com/deployment-tutorial\n如果你想尽快部署的东西,你只需要阅读第一\n两个章,但是当你准备发射比throwntogether更有趣的东西\n轻轻原型,这本书将指导您完成每一步的过程中,\n与其他我发布在网上,你也可以看到很多的更新\n部署实践的变化和发展。\n也就是说,如果你不希望将应用程序部署到世界,这很好。\n没有什么关于部署,你需要知道这一点。这个过程是相当\n开发过程和截然不同的东西,直到你已经开发了应用程序,你的\n时间是更好的在一个文本编辑器,编写代码,使事情。\n142年\n结论\n祝贺你。你已经达到了这本书的最后一页。在第一章,就像我说的\n这本书不是汤姆。有更多了解建筑与流星很酷的东西\n框架。\n这就是我建议:\n1。如果你还没有,实际上我们已经构建排行榜应用程序\n讨论这本书。没有更好的方法来学习如何比通过编写代码\n每一行,循序渐进。\n2。看流星的官方文档。你可能不理解每一点\n它,但它确实提供了洞察如何以及为什么某些特性工作的方式做。\n3所示。遵循“如何正确学习流星”的路线图。这是一个彻底的课程\n成为一个全面的流星开发者(那就推荐这个\n书)。\n如果你还没有,请访问meteortips.com并注册电子邮件时事通讯。这是\n最好的方法是不管我工作,帮助你做出更大、更快\n进步与流星。\n这就是现在。\n祝你好运,和说话很快。\n€”大卫·特恩布尔\n注:如果你喜欢这本书,在Amazon.com上留下评论。你的支持让我\n花更多的时间来研究新材料。","slug":"Meteor-2","published":1,"updated":"2019-02-12T03:17:45.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4w74u5y000tacele6r9rzj0","content":"<h3 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a>项目</h3><p>刚开始学习如何编制Web应用的开发者的一个大错误是在对要创建的东西还没有一个清淅的认识时就开始进行。但这就像开车去一个新的目的地却没有地图。你可能会在正确的方向有一个小的进展,但你可能不会到达你需要去的地方。你不需要从一开始就知道一切,但你的确至少需要一个方向。</p>\n<p>记住这一点,我们要构建Leaderboard(排行榜)——Meteor开发团队设计的一个示例应用程序展示Meteor用很少的几行代码能做什么。<br>这就是它看起来的样子:</p>\n<p>Leaderboard已经在官网上已经被更高级的例子取代了,但它会是我们的示例项目,主要有两个原因:<br>首先,这个应用程序已经存在。我们可以玩,这意味着我们可以在我们编写单行代码前对我们试图创建的应用有一个好的认识。<br>第二,应用程序很简单。这意味着我们不需要担心构建软件的概念(这通常是最困难的一部分)。相反,我们可以集中学习Meteor本身。</p>\n<p>要获得实际的时间和排行榜,请访问leaderboard2.meteor.com,点击,注意其核心特征:</p>\n<ul>\n<li>有玩家的列表。</li>\n<li>每个球员都有一个分数。</li>\n<li>球员得分排名。</li>\n<li>你可以选择玩家通过点击它们。</li>\n<li>你可以增加一个选择球员的得分。</li>\n</ul>\n<p>在后面的章节中我们将创建附加功能,但即使相对较短的列表也涉及许多Meteor的核心功能。</p>\n<h3 id=\"创建一个项目\"><a href=\"#创建一个项目\" class=\"headerlink\" title=\"创建一个项目\"></a>创建一个项目</h3><p>创建我们的第一个Meteor应用程序,我们将需要创建我们的第一个项目,一个项目是一组自包含的文件表单应用程序的基础。您可以使用单词<br>“project”和“application”互换使用,但在谈到被开发的应用时“project”会更合适。<br>每个项目都是不同的,但是一般会包含:</p>\n<ul>\n<li>HTML文件,创建接口。</li>\n<li>CSS文件,指定样式的界面。</li>\n<li>JavaScript文件,定义应用程序逻辑。</li>\n<li>文件夹,确保都是组织良好的。</li>\n</ul>\n<p>一个项目可以包含其他类型的文件,如图片和CoffeeScript文件,但在这本书中我们会尽可能保持简单,只展示我们需要的。</p>\n<p>在我们创建Leaderboard应用项目前,让我们创建一个文件夹来存储我们的Meteor项目。我们不是必须这样做,但为了保持的东西<br>有条理，这是一个好主意。</p>\n<p>当然,我们可以选择“新建文件夹”选项从“文件”菜单,但这哪儿有乐趣?相反,输入以下命令行:</p>\n<pre><code>mkdir Meteor\n</code></pre><p>然后点击“回车”键。</p>\n<p>使用mkdir命令创建一个文件夹。这mkdir命令代表“目录”,从这个名字你可能猜到,它允许我们做出一个目录。</p>\n<p>在这个实例中,我们创建一个名为“Meteor”的目录,但是您可以调用任何你想要的文件夹。的精确位置的文件夹就会出现将取决于你操作系统,但至少在Mac OS X上,将出现在“家”的文件夹目录<br>默认情况下。(如果你找不到文件夹,创建简单的搜索你的电脑。)<br>一旦准备好了目录,导航到它使用下面的命令:</p>\n<pre><code>cd Meteor\n</code></pre><p>cd命令代表“改变目录”命令行相当于在图形界面中双击一个目录,按下“回车”键后,我们将在“Meteor”目录。</p>\n<p>导航到“Meteor”文件夹。</p>\n<p>然后在这个目录中创建一个Meteor项目,运行如下命令:</p>\n<pre><code>meteor create leaderboard\n</code></pre><p>这个命令有三个部分:</p>\n<ul>\n<li>meteor部分定义这是一个meteor命令。</li>\n<li>create部分澄清,我们想创建一个meteor项目。</li>\n<li>leaderboard的部分是我们分配给项目的名称。</li>\n</ul>\n<p>运行此命令后,会出现一个“leaderboard”目录内的“meteor”文件夹,默认情况下,该文件夹将包含三个文件:</p>\n<ul>\n<li>leaderboard.html</li>\n<li>leaderboard.css</li>\n<li>leaderboard.js</li>\n</ul>\n<p>它还包含一个隐藏文件夹.meteor,但如果您的操作系统从视图中隐藏了这个文件夹,这很好。我们不会碰它。</p>\n<p>在我们的项目的文件夹</p>\n<h3 id=\"本地服务器\"><a href=\"#本地服务器\" class=\"headerlink\" title=\"本地服务器\"></a>本地服务器</h3><p>Web应用程序不像静态网站。我们不能只是打开leaderboard.html文件就奇迹的看到一个动态的Meteor的动态应用程序。事实上,如果我们在Chrome浏览器打开该文件,所有我们会看到的是一些静态文本:</p>\n<p>没有什么动态。</p>\n<p>要得到我们计划中的web应用程序,我们需要启动所谓的本地服务器。这是一个web服务器,在我们的本地机器上运行。它包含在Meteor中并允许<br>我们:</p>\n<pre><code>1.看到我们的JavaScript代码的处理结果。\n2.在我们的本地机器上运行一个数据库。\n</code></pre><p>如果你使用一个应用程序像MAMP部署PHP和MySQL,这将是熟悉,但如果这一切听起来可怕,不要害怕。在实践中,这很简单。<br>通过命令行中,导航到“leaderboard”目录中:</p>\n<pre><code>cd leaderboard\n</code></pre><p>然后输入以下命令:</p>\n<pre><code>meteor run\n</code></pre><p>这里,meteor的部分定义了这是一个meteor命令，run部分阐明了我们要采取的精确行动。在这种情况下,我们想要运行本地服务器。</p>\n<p>启动本地服务器。</p>\n<p>利用“回车”键后,将显示如下:</p>\n<pre><code>=&gt;Started proxy.\n=&gt;Started MongoDB.\n=&gt;Started youApp \n=&gt;running at: http://localhost:3000/r app.\n</code></pre><p>这些线确认本地服务器启动和URL的最后一行- <a href=\"http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。\" target=\"_blank\" rel=\"noopener\">http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。</a></p>\n<p>导航到该URL在Chrome和注意,我们不再看到静态文本。相反,我们看到一个功能的web应用程序。应用程序本身是代码的结果这是包含在每个流星项目默认情况下,这并不是最有趣的创造在世界上,但是我们仍然在正确的方向上迈出了一步。</p>\n<p>这是默认的流星的应用程序。<br>不断地查看代码的结果,我们需要保持本地服务器运行。这个简单的<br>那就意味着要离开命令行打开从这一点开始。然而,您将需要打开<br>一个单独的标签或窗口进一步写命令:<br>一个单独的运行命令的选项卡。<br>在本地服务器停止,要么退出命令行,或命令行焦点,<br>项目22<br>在你的键盘上按CTRL + C。然后再次启动本地服务器,使用相同的命令<br>之前:<br>流星跑<br>只要确保你在一个项目的文件夹在运行命令之前。<br>项目23<br>默认应用程序<br>默认应用程序没有什么特别的,但是如果我们点击“点击我”按钮,这个号码<br>在屏幕上就会增加。这提供了一个相当普通的流星的实时演示<br>特性。这个应用程序背后的代码,但是,不正是重要的因为我们将讨论<br>在接下来的章节更大范围。<br>目前,打开项目文件和删除所有的默认代码。甚至不看看<br>代码。刚刚摆脱它。我们想要从一个完全空白。<br>一旦完成,在JavaScript中输入以下文件:<br>控制台。日志(“Hello world”);<br>然后保存文件并打开JavaScript控制台在铬:<br>1。单击视图菜单。<br>2。悬停在开发人员选择。<br>3所示。选择JavaScript控制台选项。<br>窗格的底部将打开浏览器并显示“Hello world”我们的文本<br>通过控制台。日志语句。<br>“Hello World”的文本出现在JavaScript控制台。<br>项目24<br>如果这是熟悉的,很好。如果不是,那么知道控制台。日志语句用于看到输出结果<br>不创建一个接口的代码显示输出。这意味着,在我们投资<br>时间为创建一个接口,我们可以:<br>1。确认我们的代码是按预期工作。<br>2。尽快修复任何错误出现。<br>我们还可以使用控制台操作应用程序的数据库,这是我们要做的<br>下一章。<br>离开控制台打开从这一点开始,但是随时删除控制台。日志语句<br>在JavaScript文件。<br>项目25<br>总结<br>在这一章,我们了解到:<br>•当学习如何构建一个web应用程序,重要的是要有一个清晰的认识<br>你想构建。<br>•命令行可以用来迅速达到熟悉的任务,如创建文件夹和<br>他们之间导航。<br>•开发流星应用程序时,我们将它作为一个“项目”,我们可以创建一个<br>项目与流星创建命令。<br>•来查看我们的web应用程序在本地机器上,我们可以用流星运行命令<br>启动一个本地web服务器。<br>•当结合控制台。日志语句,JavaScript控制台是一个非常方便的工具<br>流星发展。<br>流星的更深层次的理解:<br>•如果你还没有,玩耍与原排行榜的应用程序。它不<br>有很多功能,但这只是意味着没有理由不是有很强的把握的<br>它的功能。<br>•关闭命令行应用程序,然后重新打开它,回到你在哪里。<br>你应该能够浏览到您的项目的文件夹cd命令启动<br>本地服务器与流星跑。<br>•创建第二个流星项目和使用这个项目尝试当你学习<br>一些新的东西。折腾了为了这是一个很好的方式钻细节<br>深入你的大脑。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>数据库中,第1部分<br>写一个技术书的一个困难的部分是决定何时引入某些想法。<br>需要教的主题书之间是一致的,但你说的顺序<br>他们可以大大影响读者理解某些内容的能力。<br>例如,往往技术作者尽可能谈论创建一个接口<br>尽快这是因为看到很有趣的视觉结果代码,和很高兴的感觉<br>像你做出了很快的进步。<br>但是这种方法并介绍一下几个问题:<br>1。很难掌握任何有关前端(接口)当你没有<br>熟悉后端(数据库,等等)。<br>2。如果我们首先谈论的前端,我们将不得不回顾在下一章,所以任何<br>快速进步的感觉将是短暂的。<br>因此,我们将首先讨论我们的项目内创建和管理数据库。这<br>不是一个“性感”的话题,但是如果我们花几分钟覆盖基础,我们将有一个强大的<br>本书的其余部分的基础。<br>26<br>第1部分数据库,27岁<br>MongoDB vs . SQL<br>如果您已经构建了一些之前在网上,你可能接触到<br>的数据库。也许你安装WordPress的副本,或使用phpMyAdmin,甚至建造<br>一些软件语言像PHP。在这些情况下,您会接触到<br>一个SQL数据库。<br>默认情况下,每个流星项目有自己的数据库。没有安装或配置<br>必需的。当你创建一个项目时,会自动创建一个数据库项目,和<br>当本地服务器正在运行,那么数据库。然而,这个数据库并不是一个SQL<br>数据库。相反,它是所谓的MongoDB数据库。<br>如果你之前从未遇到MongoDB,你可能会有点担心,但不要害怕。蒙戈<br>数据库和SQL数据库不同,但是作为初学者而言,差异<br>很小。<br>目前,你只需要知道两件事:<br>首先,没有其他类型的数据库用于流星。如果你想使用一个SQL<br>数据库,例如,它是不可能的。其他选项可以在未来,但是<br>时间其实还不清楚。<br>第二,蒙戈使用不同的词汇来描述熟知的概念。例如,我们不会<br>使用“表”和“行”这样的词,但概念基本上是相同的。你可以看到<br>这个表的差异:<br>MongoDB vs . SQL<br>会很难想起概念熟悉新单词,但是我将提供大量的提醒<br>通过这本书我们进步。<br>第1部分数据库,28<br>创建一个集合<br>排行榜的中央功能应用程序的列表的球员。没有球员的名单<br>出现在界面,我们不能建立其他任何有价值的物品。因此这是一个好地方<br>开始——从应用程序的“中间”,向外工作的细节。<br>这里有两个问题需要考虑:<br>•我们在哪里存储与每个玩家相关的数据?<br>•我们如何显示这些数据从内部接口?<br>我们将在下一章回答第二个问题,但第一个问题:“在哪里<br>我们与每个球员关联存储数据吗?”<br>滑稽的答案将是“数据库”,但更有用的答案”<br>收集”,如前一节所示,相当于一个SQL表集合。<br>为了说明的目的收集,想象我们正在创建自己的版本的WordPress<br>流星。如果是这样的话,我们会创建一个集合的文章,为集合<br>评论,和一组页面。我们会创建一个为每个类型的数据收集。自<br>我们创建这个排行榜的应用程序,我们将创建一个集合的球员。<br>要做到这一点,打开JavaScript文件,写如下声明:<br>新的Mongo.Collection(球员);<br>在这里,我们创建一个集合命名为“玩家”在我们项目的Mongo数据库。你可以<br>名字收集任何你想要的,但它必须是唯一的。如果名字不是独一无二的,流星<br>将返回一个错误。<br>尽管这行代码,我们还没有供我们参考这个集合定义了一个方法,<br>因此我们没有办法操作。<br>为了解决这个问题,将集合在一个变量:<br>PlayersList = new Mongo.Collection(球员);<br>但请注意,我们没有使用var关键字,因为我们想要创建一个全球性的<br>变量。这将允许我们引用和操作在我们所有的集合<br>项目的文件。<br>确认收集存在,保存文件,切换到Chrome浏览器,并输入的名称<br>集合的变量为控制台:<br>PlayersList<br>第1部分数据库,29岁<br>您应当会看到类似如下:<br>集合的存在。<br>这表明集合是按预期工作。<br>如果返回一个错误,这可能是因为你的名字输入错误变量在控制台,<br>或在代码中犯了一个语法错误。<br>数据库中,第1部分30<br>插入数据<br>当我们想将数据插入一个集合,我们有四个选项。我们可以通过插入数据<br>JavaScript控制台,通过命令行,通过JavaScript文件,并通过<br>形式的界面。我们将看到如何使用所有这些选项在这本书,但第一<br>选项-通过JavaScript控制台是最简单的,所以这是最好的起点。<br>在控制台中,写如下:<br>PlayersList.insert();<br>这是我们使用的语法来操纵一个集合。<br>我们开始分配给变量集合,然后——“PlayersList”变量<br>附加功能。在本例中,我们使用插入函数,但是有一个范围的<br>功能,如查找、更新和删除(和我们将讨论这些很快的细节)。<br>但是,如果我们把“返回”键在这一点上,没有什么会发生,那是因为我们<br>需要在函数的括号之间传递数据改变的内容<br>集合。<br>我们通过的数据需要以JSON格式,如果你不熟悉<br>JSON格式,这就是它的样子:<br>{<br>名称:“大卫”,<br>得分:0<br>}<br>在这里,有几个事情:<br>首先,数据是用一对大括号。这就是我们如何区分我们的JSON数据<br>剩下的代码。<br>第二,我们已经定义了一对密钥。这些键被称为名字和分数,蒙戈<br>术语,这些是我们收集的字段。因为每个球员将集合<br>有一个名称和一个分数,名字和分数字段来保存这些值。<br>第三,我们已经定义了与我们的键相关联的值。在这种情况下,价值的名字<br>字段是“大卫”和分数字段的值是0。<br>第四,键值用逗号隔开。这是因为JSON格式<br>忽略空白,所以逗号是需要提供结构。<br>我们可以通过这些数据通过括号,像这样:<br>第1部分数据库,31日<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0<br>});<br>这是一个完整的插入功能,如果我们这个语句输入到控制台和挖掘<br>“返回”键,将会创建一个文档在“PlayersList”集合。文档是<br>相当于SQL行和,在这一点上,我们要为每个玩家创建一个文档<br>希望在我们的集合。如果我们希望我们的排行榜包含六名球员,我们需要使用<br>六次插入函数,从而创建6个文档。<br>插入数据。<br>为了实现这一点,重复这句话几次,确保定义独特的值<br>名称字段,所以我们可以区分球员:<br>PlayersList.insert({<br>名称:“鲍勃”,<br>得分:0<br>});<br>由于忽略空白,语句可以写在一行:<br>PlayersList。插入({ name:“鲍勃”,得分:0 });<br>数据库中,第1部分32<br>也请注意,创建每个文档后,会出现一个随机的数字和字母<br>在控制台。这种混乱的局面是一个独特的ID MongoDB和自动创建的<br>与每个文档相关联。它的主键,它会是重要的。<br>目前,只注意到它的存在所以你不惊讶当我们讨论一遍。<br>在我们继续之前,更多的玩家插入集合。示例应用程序<br>六名球员,应该够了。<br>球员们在我的名单是:<br>•大卫<br>•鲍勃<br>•玛丽<br>•比尔<br>•沃伦<br>•蒂姆<br>他们都有得分字段设置为0。<br>将剩下的球员。<br>第1部分数据库,33<br>找到数据<br>现在,我们有一些数据收集,我们能够检索这些数据。我们将这样做<br>接口在下一章,但就目前而言,我们只是通过控制台。<br>在控制台,输入以下:<br>PlayersList.find();<br>在这里,我们使用这个找到函数,用于检索数据从指定的集合。<br>因为我们没有任何穿过支架,该语句将检索所有的<br>的数据集合。<br>以下应该出现在控制台:<br>使用find函数。<br>但很明显,这不是最可读的回应。我们的应用程序可以是有意义的,但是<br>我们不能。<br>检索数据更可读的格式,附加一个获取函数的转换<br>检索到的数据转换成一个数组:<br>.fetch PlayersList.find()();<br>第1部分数据库、34<br>您应该看到如下:<br>使用查找和获取功能。<br>我们也可以单击下箭头与每个文档相关的数据,<br>包括:<br>•_id字段,存储文档的惟一的ID(“主键”,我们<br>之前提到过)。<br>•名称字段,存储的球员的名字。<br>•比分字段,存储得分的球员。<br>但是如果我们想要检索的数据的集合,而不是所有的<br>数据?要做到这一点,我们可以通过json格式的数据之间的括号:<br>PlayersList。找到({ name:“大卫”}).fetch();<br>这里,我们通过字段名和值通过发现功能,因此,我们可以<br>只检索文档,球员的名字字段等于“大卫”。在我们的例子中,这个<br>只检索一个文档,但是如果我们集合包含多个玩家叫“大卫”,<br>他们都是根据这个查询返回。<br>也有用的是计算能力的数量由一个查询返回的文件<br>将计数函数找到函数:<br>数据库中,第1部分35<br>.count PlayersList.find()();<br>因为这个语句将计数集合中的所有文档,如果有六名球员<br>(文件)的集合,6号返回。<br>第1部分数据库、36<br>总结<br>在这一章,我们了解到:<br>•当我们创建一个流星项目,蒙戈数据库自动创建,和<br>当本地服务器正在运行,那么数据库。<br>•Mongo数据库和SQL数据库不同,但差异是无关紧要的<br>初学者而言。<br>•为每一种类型的数据需要存储在Mongo数据库中,我们需要创建一个集合。<br>集合包含文档和文档的字段和值。<br>•使用插入函数,我们可以将数据插入一个集合。这个数据结构<br>以JSON格式。<br>•通过使用find函数,我们可以从集合中检索数据。这些数据就可以<br>通过使用控制台导航。<br>流星的更深层次的理解:<br>•注意,我们还没有预定义的数据库的结构。相反,结构<br>定义数据库的动态,我们使用插入函数。<br>•在一个单独的项目中,创建一个存储不同类型的数据的集合,比如博客<br>帖子,也许。什么样的字段集合有吗?<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>模板<br>在这一章,我们将开始构建排行榜的用户界面的应用程序。<br>这包括创建我们的第一个模板。<br>首先,下面的代码在排行榜。html文件:<br>&lt;头&gt;<br>&lt;标题&gt;排行榜&lt; /名称&gt;<br>&lt; / &gt;头<br>&lt;身体&gt;<br>&lt;标题&gt;排行榜&lt; / h1 &gt;<br>&lt; /身体&gt;<br>这段代码没有什么特别之处——它只是标准的HTML,但出现<br>缺少几件事:<br>•我们没有包含html标签。<br>•我们还没有包括任何JavaScript文件<br>•我们还没有包括任何CSS文件。<br>但是我们没有包括这些事情,因为我们不需要他们。流星负责<br>对我们这些细节。它将html标记添加到文件的开始和结束,自动<br>包括项目的文件夹中包含的任何资源(比如JavaScript和CSS文件)。<br>这不是世界上最引人注目的特性,但是流星的核心理念之一<br>开发者幸福,所以有很多这样传遍了节省时间的特性<br>框架。<br>37<br>模板38<br>创建一个模板<br>模板用于创建接口和JavaScript代码之间的连接。当<br>我们把界面元素在一个模板,我们可以参考和操作<br>元素与应用程序逻辑。<br>创建一个模板,将下面的代码添加到HTML文件的底部,下<br>关闭body标签:<br>&lt;模板名称=“排行榜”&gt;<br>Hello World<br>&lt; /模板&gt;<br>在这里,我们使用这个模板标签,它使用一个名称属性来区分<br>我们创建不同的模板。在这种情况下,模板的名称是“排行榜”,我们会<br>很快这个名字从JavaScript文件的引用。<br>如果你保存文件在其当前状态,模板不出现在web浏览器。<br>在HTML文件,但是没有别的地方了。这是因为,在默认情况下,模板不出现<br>内部接口。这听起来可能很奇怪,但是考虑到,在某些情况下:<br>•您可能希望一个模板出现在某些时候。<br>•您可能希望一个模板在某些时刻消失。<br>•你可能想要一个模板出现在多个位置。<br>考虑到这种可能性,我们需要手动包含模板内部的接口。这<br>确实需要一个额外的步骤,但它会变得越来越有用,因为我们深入发展。<br>使“排行榜”模板出现在浏览器内,把这个标签之间的身体<br>需要在HTML文件:<br>{ { &gt;排行榜} }<br>显然,这不是HTML。代替。double-curly括号的使用意味着这是空格键<br>语法,空格键是语法中我们使用HTML当我们想要动态<br>发生。这是语法,桥梁之间的差距接口和应用程序逻辑。<br>我们将了解更多关于空格键在这本书,但现在,知道:<br>1。所有空格键标签使用double-curly括号来区分。<br>2。我们只使用大于符号当我们想要包括一个模板。<br>基于这些变化,HTML文件现在应该类似于:<br>模板39<br>&lt;头&gt;<br>&lt;标题&gt;排行榜&lt; /名称&gt;<br>&lt; / &gt;头<br>&lt;身体&gt;<br>&lt;标题&gt;排行榜&lt; / h1 &gt;<br>{ { &gt;排行榜} }<br>&lt; /身体&gt;<br>&lt;模板名称=“排行榜”&gt;<br>Hello World<br>&lt; /模板&gt;<br>保存文件之后,内部的“Hello World”从“排行榜”模板<br>出现在浏览器:<br>当前界面。<br>模板40<br>客户端与服务器<br>在我们继续之前,我想要证明的东西。你不需要完全理解我们<br>封面,但都遵循允许通过编写的所有代码。<br>在JavaScript文件,编写以下控制台。日志语句:<br>控制台。日志(“Hello world”);<br>这是我们声明语句写在“项目”一章,并在保存文件<br>切换回Chrome,您应该看到“Hello world”消息出现在控制台:<br>“Hello World”出现在控制台。<br>上次我没有提到虽然是,由于这种说法,别的东西也<br>发生,如果我们切换到命令行中,我们可以看到“Hello world”消息<br>也在这里:<br>模板41<br>“Hello World”出现在命令行。<br>这是很重要的,因为我们已经写一行代码的执行在两个地方。的<br>代码是运行在客户端(在用户的web浏览器)和服务器(其中<br>应用程序托管)。<br>为什么这很重要?<br>有几个原因,但这里有一个例子:<br>自从我们创造了“PlayersList”集合,下面的语句上运行<br>客户端和服务器:<br>PlayersList = new Mongo.Collection(球员);<br>但是代码不做同样的事情在这两个地方。<br>当代码在服务器上执行,创建在Mongo集合数据库。这是<br>我们的数据存储。当代码执行从用户的web浏览器中虽然-<br>在客户端创建一个本地副本的收集用户的计算机。作为一个结果,<br>当用户与数据库交互时,他们实际上交互的本地副本。这<br>部分原因是流星应用程序默认是实时的。数据是用户的操作<br>本地机器然后无形在后台与服务器端数据库同步。<br>但如果这一切听起来有点概念,不要害怕。你不需要了解细节<br>点流星的“魔法”。你只需要一行代码就可以掌握:<br>1。在两个不同的环境中运行(在客户端和服务器)。<br>模板42<br>2。根据不同的环境会有不同的行为。<br>也就是说,在某些情况下,我们不希望我们的代码运行在两个地方。如果,<br>实例中,我们编写代码,只会影响应用程序的接口,它不会是有意义的<br>在服务器上运行的代码。我们只希望它在客户机上运行。<br>适应,有一双条件我们可以用来确定代码运行<br>的环境。你会有一个更好的想法何时使用这些条件<br>通过书的进展,但是,只要跟着目前通过编写所有的<br>代码。<br>首先,一颗流星。isClient条件下的控制台。日志声明:<br>如果(Meteor.isClient){<br>/ /这段代码只在客户机上运行<br>}<br>这个条件允许我们专门执行代码在客户端——从用户的内部<br>web浏览器,为了证明这一点,我们可以简单地添加一个控制台。日志声明内<br>条件:<br>如果(Meteor.isClient){<br>控制台。日志(“你好客户”);<br>}<br>保存文件,切换到浏览器,注意,“你好”客户端消息出现在<br>控制台,但没有出现在命令行里面。这是因为代码没有被<br>在服务器上执行。<br>模板43<br>“你好,客户端”只出现在控制台。<br>我们可以创建与流星相反的效果。isServer条件:<br>如果(Meteor.isServer){<br>/ /这段代码只运行在服务器上<br>}<br>再次,我们将放置一个控制台。日志语句内部条件:<br>如果(Meteor.isServer){<br>控制台。服务器日志(“你好”);<br>}<br>保存文件之后,请注意,“你好”服务器消息出现在命令<br>线,但不出现在控制台。这是因为只有被执行的代码<br>托管服务器(应用程序)。<br>模板44<br>“你好,服务器”只出现在命令行。<br>但是如果这一切都是真的沉没,只要记住两件事:<br>1。一行代码可以运行在客户端和服务器。<br>2。有时我们不想让我们的代码运行在这两个地方。<br>精确的时刻,我们需要考虑这些点很快就将变得明朗了。<br>现在,仅仅删除控制台。日志语句,但离开他们的条件。我们会<br>很快就会使用它们。<br>模板45<br>创建一个助手<br>在这一点上,我们的“排行榜”模板只显示静态文本“Hello World”。为了解决这个问题,<br>我们将创建一个helper函数,一个辅助函数是一个常规的JavaScript函数<br>附加的模板,让我们从一个接口内部执行代码。<br>开始,我们将一个古老的方法来创建辅助函数。这种方法已被弃用,<br>这意味着它不再是官方支持,你读这句话的时候,它可能<br>不工作。但这老格式更容易教和理解,并允许我们来缓解<br>到non-deprecated方法,我们会讨论。<br>在JavaScript文件,编写以下isClient内部条件:<br>Template.leaderboard.player<br>这是弃用语法来创建一个helper函数,它可以分解成三个<br>部分:<br>首先,我们流星的模板通过关键词搜索模板工程。我们只<br>有一个模板,但是一个完整的项目会更多。<br>第二,通栏广告关键字指的是我们创建模板的名称<br>早些时候。每一个helper函数必须附加到一个模板。在这种情况下,附加功能<br>“排行榜”模板。<br>第三,球员关键字是我们给这个函数。我们很快就会参考<br>这个名字在HTML文件。<br>这个助手附加代码,将它与一个函数:<br>Template.leaderboard。球员= function(){<br>/ /代码在这里<br>}<br>“助手”这个词可能会让这种声音的,但是我们没有做什么特别的。<br>我们已经创建了一个函数,将其命名为“球员”,并连接到“排行榜”模板。<br>添加一些功能函数,创建一个返回语句返回一些静态的<br>文本:<br>Template.leaderboard。球员= function(){<br>返回“其他文本”<br>}<br>然后删除的文本“Hello World”模板,代之以“排行榜”<br>以下标记:<br>模板46<br>{ {球员} }<br>在这里,我们使用的是另一个空格键标签,就是明证double-curly括号的使用。但<br>请注意,我们不使用大于符号,这是因为我们不包括<br>模板。相反,我们引用玩家函数的名称。<br>保存文件后,返回语句的文本应该出现在浏览器内:<br>使用弃用辅助函数方法。<br>如果文本不出现,一些是错误的代码,或者这种方法创建<br>从流星助手被移除。如果你不确定它,检查你的代码错误。<br>如果您的代码就是我告诉你写,它仍然不工作,不要害怕。现在,<br>你知道老方法创建辅助函数,我们准备讨论的新方法。<br>删除所有我们刚刚创建的helper函数,代之以:<br>Template.leaderboard.helpers<br>在这里,我们有这个模板的关键字,搜索通过模板在我们的项目,<br>这个排行榜的关键字,这是一个引用“排行榜”模板。<br>但是这个帮手关键词呢?<br>我们创建一个函数命名的“帮手”?<br>不。<br>模板47<br>这个助手关键字是一个特殊的关键字,它允许我们定义多个辅助功能<br>在一个代码块。<br>因此,而不是创建一个helper函数:<br>Template.leaderboard。球员= function(){<br>/ /代码在这里<br>}<br>我们为所有的模板创建一个块的辅助功能:<br>Template.leaderboard.helpers({<br>/ /辅助函数到这里<br>});<br>这些助手以JSON格式定义,与助手的名字和一个的关键<br>相关函数的值:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回“其他文本”<br>}<br>});<br>使用逗号分隔,我们可以创建多个辅助功能:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回“其他文本”<br>},<br>“otherHelperFunction”:函数(){<br>返回“其他功能”<br>}<br>});<br>可以使用这两个辅助函数在“排行榜”模板:<br>{ {球员} }<br>{ { otherHelperFunction } }<br>这段代码可能看起来有点忙比弃用的方法,但这只是因为我们<br>使用少量的帮手。更大数量的助手,组织他们<br>这是最清洁的方法。<br>模板48<br>一对辅助函数在一个模板。<br>模板49<br>每一块<br>我们已经取得了一个helper函数,但它只是返回一些静态文本,这并不是很有趣。<br>我们真正想要的是一个helper函数,从“PlayersList”中检索文档<br>收集。然后我们就可以从界面中显示数据。<br>为了达到这个目标,helper函数的返回语句替换为以下几点:<br>返回PlayersList.find()<br>在这里,我们使用find函数函数从“数据库,第1部分”一章。这个函数<br>将从“PlayersList”检索所有的数据集合,因为我们已经把它内<br>helper函数,这些数据现在可以从内部“排行榜”模板。<br>看到这,从HTML文件中删除以下标记:<br>{ {球员} }<br>之前,我们的helper函数返回之前的一段数据,字符串,<br>这个目的,这个标签是很好,但现在的助手是返回一个数组的所有文档<br>在集合,这意味着我们需要遍历返回的数据。<br>为了实现这一点,我们可以使用空格键语法来创建一个每个块:<br>{ { #每个玩家} }<br>测试<br>{ { /每个} }<br>在这里,有几个事情:<br>首先,从“PlayersList”收集所有的文档检索的基础上,参考<br>玩家的功能。<br>第二,我们遍历返回的数据的每个语法。<br>第三,我们为每个文档输出“测试”这个词(球员)的检索。因为有<br>六名球员在收集、“测试”这个词会出现界面内的6倍。<br>模板50<br>“测试”这个词似乎每个玩家的收集。<br>从概念上讲,这就像我们有一个数组:<br>var playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);<br>…就像我们使用forEach循环遍历这个数组的值:<br>var playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);<br>playersList.forEach(函数(){<br>console.log(测试);<br>});<br>在每一块,我们也可以从内部文档检索字段的值。<br>因为我们把“PlayersList”收集的数据,我们可以显示的值<br>字段名字和分数。<br>显示玩家的名字,例如,我们可以写:<br>{ { #每个玩家} }<br>{ {名称} }<br>{ { /每个} }<br>然后显示玩家的分数,我们可以写:<br>模板51<br>{ { #每个玩家} }<br>{ {名称} }:{ {得分} }<br>{ { /每个} }<br>虽然我们不会让这个应用程序很浪费时间,我们将添加一些细微的结构<br>的接口:<br>&lt; ul &gt;<br>{ { #每个玩家} }<br>&lt;李&gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>{ { /每个} }<br>&lt; / ul &gt;<br>保存文件后,玩家的名字和分数将会出现在一个无序列表。通过<br>默认情况下,球员们会按时间——从他们插入到集合<br>玩家添加第一个球员最近增加了更多,但这是我们改变<br>后一章。<br>一种改进的界面。<br>模板52<br>总结<br>在这一章,我们了解到:<br>•流星为我们处理一些无聊的细节,如使用html标记和包括<br>JavaScript和CSS文件。<br>•通过创建模板,我们可以形成一个应用程序逻辑和我们之间的桥梁<br>接口。<br>•我们的项目的代码可以在客户端和服务器上运行,但我们并不总是想要的<br>这样的事情发生。我们可以使用isClient isServer条件控制的<br>代码运行。<br>•创建一个模板后,我们需要手动把它在界面。这给了<br>我们控制时间和地点。<br>•通过创建辅助函数,我们可以执行代码在一个模板,从而创建<br>一个动态的界面。<br>•如果一个helper函数返回一个数组的数据,我们可以通过数据在一个循环<br>模板使用每个语法。<br>流星的更深层次的理解:<br>•意识到模板可以放置在任何地方项目的文件夹。我们可以,<br>实例,把我们的“排行榜”模板在另一个HTML文件和参考{ { &gt;<br>排行榜} }将继续工作。<br>•故意打破应用程序通过将每个块之外的“排行榜”<br>模板。熟悉的错误,你会不可避免地遇到一颗流星<br>开发人员。然后你就会知道如何处理这些问题当他们意想不到的。<br>•创建一个helper函数,使用查找和计数函数返回的数量<br>球员“PlayersList”集合。然后在界面中显示这些数据。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>事件<br>在这一点上,我们有一个名单的球员出现在界面,但是没有办法<br>用户与该列表。数据动态地从“PlayersList”收集、检索<br>但用户仍将可能假定应用程序完全是静态的。<br>我们将花剩下的书解决这个问题,但在接下来的几个章节<br>特别的,我们将创建的影响能够选择球员名单内。<br>具体来说,当用户点击其中一个球员,球员的背景颜色<br>元素将会改变黄色。<br>53<br>事件54<br>创建一个事件<br>在本节中,我们将创建我们的第一个事件,事件使我们能够触发执行的代码<br>当用户点击一个按钮,轻拍一个关键键盘,或完成一系列其他<br>行动。<br>为了说明这一点,写在isClient条件如下:<br>Template.leaderboard.events({<br>/ /事件到这里<br>});<br>在这里,有几个事情:<br>首先,模板是用来搜索所有的项目模板。<br>第二,排行榜是模板的名称我们要附加事件。<br>第三,事件是特殊的关键字,是用于指定,在未来的<br>代码,我们希望指定一个或多个事件。(这段代码非常类似于我们如何创建助手<br>功能。)<br>花括号之间的事件块,使用JSON格式创建一个事件:<br>Template.leaderboard.events({<br>“点击”:函数(){<br>/ /代码在这里<br>}<br>});<br>在这里,有两个事情:<br>首先,我们定义事件类型。这是点击部分。正因为如此,里面的代码<br>相关的函数将执行当用户点击的范围内的任何地方<br>“排行榜”模板。<br>第二,这个事件我们附加一个函数,这个函数里面,我们可以写<br>代码要执行时,单击出现。<br>为了说明这一点,添加一个控制台。日志语句内的事件:<br>Template.leaderboard.events({<br>“点击”:函数(){<br>控制台。日志(“你点击”);<br>}<br>});<br>事件55<br>保存文件后,切换回Chrome和点击的范围内的任何地方<br>“排行榜”模板。每次点击,你点击“消息将出现在里面<br>控制台。<br>点击。<br>事件56<br>事件选择器<br>我们已经创建的事件是太过宽泛。它触发当用户单击任何地方范围内<br>“排行榜”的模板。在某些情况下可能是有用的,但通常我们<br>当用户希望触发一个事件做精确,喜欢点击某个按钮。<br>为了实现这一点,我们将使用事件选择器,选择符允许我们将事件附加到特定的HTML<br>元素。(如果你曾经使用jQuery,这个过程将是熟悉的,但如果不是这样,它仍然会相当<br>容易掌握。)<br>早些时候,我们把李HTML文件中的标签:<br>&lt;李&gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>目前的计划是让我们的事件触发李当用户点击其中一个元素。<br>要做到这一点,改变事件如下:<br>“李点击”:函数(){<br>控制台。日志(“你点击一个li元素”);<br>}<br>在这里,我们做了两处修改:<br>首先,我们已经添加了李后点击关键字部分。这意味着事件将触发<br>当用户点击“排行榜”内任何li元素模板。<br>第二,我们已经改变了控制台的输出。日志语句。<br>然而,我们还没有考虑:<br>会发生什么,如果我们有其他的li元素内部的“排行榜”模板,不是吗<br>玩家的列表的一部分吗?以后会这样,我们的代码的目前的形式来看,它会引发一场<br>问题。事件将触发当我们不希望它来触发。<br>为了解决这个问题,添加一个。球员对li元素类:<br>&lt;李类= “玩家” &gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>然后使用这类事件选择器:<br>的点击。球员”:函数(){<br>控制台。日志(“你点击。球员元素”);<br>}<br>在这里,我们已经取得了如此事件只会触发,当用户单击一个元素<br>的。播放器类连接到它。<br>保存文件后,最后的结果不会出现任何不同,但是如果我们添加其他元素<br>模板,事件不会触发的时候不应该。<br>事件57<br>点击一个球员。<br>事件58<br>总结<br>在这一章,我们学到的:<br>•当用户点击一个按钮,提交一个表单,或完成其他操作,我们可以<br>触发器的执行代码通过使用事件。<br>•最常见的事件类型是点击,但是有一个可用的其他选项范围<br>以许多不同的方式使我们的应用程序交互。<br>•通过使用事件选择器,我们可以精确的元素的附加事件<br>类似的语法jQuery和CSS。<br>流星的更深层次的理解:<br>•尝试不同的事件类型,包括:双击鼠标,焦点,模糊,鼠标悬停,<br>改变。找出这些不同类型的行为,试图整合他们<br>排行榜的应用程序。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>会话<br>当用户点击其中一个。球员元素,执行一个函数。当这个函数是<br>触发,我们想改变背景颜色的元素,从而产生的效应<br>被选中的球员。<br>为了实现这一点,我们将使用会话,会话允许我们不存储小块的数据<br>保存到数据库并返回访问不会记得。这类数据可能<br>听起来不立即有用,但这是一个令人惊讶的是通用的方法来解决很多共同之处<br>问题。<br>59<br>会话60<br>创建一个会话<br>创建一个会话,写在单击下面的语句。球员事件:<br>会话。集(“selectedPlayer”、“会话值测试”);<br>这里,我们使用这个会话。设置功能,通过两个参数:<br>首先,我们通过会议的名称。这个名字被用作参考。在这个<br>情况下,我们调用会话“selectedPlayer”,但随意使用任何你喜欢的名字。<br>其次,我们通过会议的价值。这是我们内部存储的数据<br>会话。在这种情况下,我们通过“会话值测试”的静态值,但我们会<br>使用一个更有趣的值。<br>证明我们的会话是按预期工作,检索的会议的价值<br>下面的语句:<br>Session.get(“selectedPlayer”);<br>块应该类似的事件:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>会话。集(“selectedPlayer”、“会话值测试”);<br>Session.get(“selectedPlayer”);<br>}<br>});<br>这里,我们使用这个会话。函数,通过“选择——的名称<br>玩家“会话,我们刚才创建的。<br>输出该会话的值到控制台,它在一个变量:<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>然后添加一个控制台。日志声明下面这条线:<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>console.log(selectedPlayer);<br>现在,当用户点击其中一个球员元素,“会话值测试”字符串<br>存储在一个会话,然后立即输出到控制台。它不是最有用的代码,<br>但这很快就会改变的。<br>61年会议<br>创建和检索一个会话。<br>62年会议<br>玩家的ID<br>当用户点击列表中的玩家之一,我们要抓住玩家的惟一ID<br>并将其存储在“selectedPlayer”会议。这将允许我们改变背景<br>这个玩家的li元素的颜色。<br>如果你不确定我是什么意思,当我说“玩家”的惟一的ID,回想<br>当我们球员插入“PlayersList”集合。每次我们使用插入<br>函数,一个随机的数字和字母会出现。混乱是唯一的ID<br>的球员。<br>首先,创建一个“playerId”变量的顶部点击。球员的事件,并使其平等<br>从之前的“会话值测试”字符串:<br>var playerId =“会话值测试”;<br>然后修改会话。集函数,通过“playerId”变量作为第二个<br>论点。事件应该类似于:<br>的点击。球员”:函数(){<br>var playerId =“会话值测试”;<br>会话。集(selectedPlayer,playerId);<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>在这一点上,关键是要使“playerId”变量等于球员的惟一ID<br>这是被点击。这并不需要大量的代码,但它确实需要一些解释。<br>现在,改变“playerId”变量如下:<br>var playerId = this._id;<br>至于原因,有两个事情:<br>首先,我们有一个参考,这取决于上下文的价值。在这种背景下,<br>这个指的是文档的球员刚刚点击。<br>第二,_id部分是包含惟一的ID字段的名称的球员。所以在<br>我们创建了一个名字和分数一样,蒙戈为每个文档创建一个_id字段。<br>(下划线本身没有任何特殊的意义。这只是部分字段的名字。)<br>由于这一变化,现在下面是可能的:<br>1。用户点击的一个球员。<br>2。玩家的惟一ID存储在“playerId”变量。<br>3所示。“playerId”变量的值存储在“selectedPlayer”会话。(可以<br>只有一个值存储在一个会话,所以每当一个新值存储,前面的<br>值是重写。)<br>63年会议<br>4所示。“selectedPlayer”会话的值输出到控制台。<br>看到这在行动:保存文件,切换回Chrome,点击任何球员<br>列表。他们惟一的ID将显示在控制台。<br>点击大卫后,鲍勃和玛丽。<br>因为我们不需要看到控制台内的点击播放器的惟一的ID,我们可以<br>简化事件如下:<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>}<br>在这里,我们只是设置的值“selectedPlayer”会议,点击的惟一ID<br>的球员。<br>64年会议<br>选择效果,第1部分<br>当用户点击一个球员在我们的列表中,我们想要改变背景颜色<br>包含该玩家的li元素的属性。这将创建该玩家的影响<br>被选中。<br>为了实现这一点,打开项目的CSS文件并创建一个名为“选择”的类。这门课应该<br>background属性,在这个例子中,我们将通过“黄色”的价值:<br>.selected {<br>背景颜色:黄色;<br>}<br>然后切换到JavaScript文件并创建一个“selectedClass”助手:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回PlayersList.find()<br>},<br>“selectedClass”:函数(){<br>/ /代码在这里<br>}<br>});<br>(你会发现两个助手都是在相同的代码块,和我们讨论<br>以前,这是可能使用逗号)。<br>至于这个函数的内容,我们会让它返回“选择”这个词:<br>“selectedClass”:函数(){<br>返回“选择”<br>}<br>注意:我们需要返回的文本等于在CSS文件类的名称,因为<br>我们命名为“类”选择“在CSS文件中,我们返回“选择”从内部文本<br>这个函数。<br>接下来,切换到HTML文件并将引用这个“selectedClass”功能里面<br>li元素的class属性:<br>&lt;李类= “球员{ { selectedClass } } “ &gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>“选择”类将被应用到每一个。球员的元素,从而改变了背景<br>每个元素的颜色:黄色<br>65年会议<br>“选择”类是应用于li元素。<br>这不是我们想要的但这是一个重要的一步。<br>66年会议<br>选择效果,第2部分<br>在我们继续之前,我想要证明的东西。<br>在selectedClass helper函数返回语句注释掉:<br>“selectedClass”:函数(){<br>/ /返回“选择”<br>}<br>然后编写以下:<br>“selectedClass”:函数(){<br>/ /返回“选择”<br>返回this._id<br>}<br>在这里,我们使用这个。_id检索的惟一ID的球员。而是的ID<br>输出到控制台,它会出现在每个li元素的class属性。这是<br>不是我们想要的但重要的是要知道,因为selectedClass函数<br>被执行在每一块,它可以访问所有的数据迭代<br>(包括球员的惟一的ID、姓名和分数)。<br>这证明:保存文件,切换到Chrome,右键单击li元素之一,并选择<br>“检查元素”选项。你会注意到每个玩家现在出现在的惟一ID<br>class属性:<br>67年会议<br>球员们在每个类的惟一的ID属性。<br>知道了这一点,我们要做几件事:<br>首先,我们将删除返回。<em>id声明,因为它只是用于演示目的。<br>第二,我们将取消返回语句,因为我们想要selectedClass函数<br>返回“选择”的静态文本。<br>第三,我们将创建一个“playerId”变量的函数,this.</em>——的价值<br>id:<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>返回“选择”<br>}<br>第四,我们将创建一个“selectedPlayer”为“selectedPlayer”会话变量:<br>68年会议<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>返回“选择”<br>}<br>第五,将返回语句在下列条件:<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>如果(playerId = = selectedPlayer){<br>返回“选择”<br>}<br>}<br>逻辑后如果你有麻烦,这是怎么回事:<br>当用户点击一个列表中的玩家,玩家的惟一ID存储在里面<br>“selectedPlayer”会议。然后该会话的ID匹配的所有ID<br>球员们在列表中。因为玩家的ID将永远是独一无二的,只能有一个<br>单匹配,匹配时,静态文本的“选择”将返回的<br>selectedClass功能和放置在球员li元素的class属性。基于<br>在这类,玩家的li元素的背景颜色会变成黄色。(和<br>因为会话只能存储一个值,只有一个球员可以选择一次)。<br>点击后,鲍勃。<br>这是最复杂的例子在这本书中,但是你只需要掌握一种基本的会话<br>其余的章节。它并不重要,如果你不“获得”的一切。<br>69年会议<br>总结<br>在这一章,我们了解到:<br>•会议是用来存储小块的数据没有保存到数据库或<br>记得在返回访问。<br>•创建一个会话,我们使用会话。集函数,而检索的价值<br>会话我们使用会话。得到的功能。<br>•辅助函数和事件在每一块获得的数据<br>遍历的块。<br>流星的更深层次的理解:<br>•考虑我们如何使用“selectedPlayer”会议。我们还可以做些什么<br>选中的球员的惟一的ID吗?<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>数据库,第2部分<br>还有很多其余页的这本书,但是我们已经完成了大部分<br>从最初的排行榜应用程序特性。<br>剩下的我们将在本章的工作包括:<br>•增加选择球员的得分能力。<br>•排名球员的得分(从最高到最低)。<br>•显示选中的球员的名字在名单上。<br>我们也可以减量的得分选择球员,这并不是的一个特征<br>原始的应用程序,但足够简单的添加。<br>70年<br>第2部分数据库,71<br>给5分<br>在“排行榜”模板,我们将创建一个“给5分”按钮,当点击时,会<br>增加选择的球员的得分。<br>开始,将下面的按钮在“排行榜”模板:<br>&lt; input type = “ button “ class = “增量” value = “给5分”&gt;<br>按钮应该以外的每一块,类属性的设置<br>“增量”。<br>按钮做一些,添加以下事件的事件块内<br>JavaScript文件:<br>的点击。增量”:函数(){<br>/ /代码在这里<br>}<br>整个事件块应该类似于:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>},<br>的点击。增量”:函数(){<br>/ /代码在这里<br>}<br>});<br>(别忘了事件之间用逗号分隔)。<br>在点击。增加事件,我们将使用选定的玩家发现的惟一ID<br>玩家在“PlayersList”收集和增加球员的得分字段的值<br>5。<br>访问的唯一ID选择球员,使用会话。功能:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>您可以验证这个功能一个控制台。日志语句:<br>第2部分数据库,72<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>console.log(selectedPlayer);<br>}<br>选择一个球员之后,单击“给5分”按钮来显示所选的惟一ID<br>的球员。<br>单击“给5分”按钮后,玛丽的身份出现在控制台。<br>第2部分数据库,73<br>先进的运营商,第1部分<br>在这一点上,我们想做的是,当一个用户从列表中选择一个球员和点击<br>“给5分”按钮时,该玩家的分数是修改。<br>要做到这一点,删除控制台。从点击日志语句。增加事件和替换它<br>用以下:<br>PlayersList.update();<br>这是Mongo更新函数,在括号之间,我们可以定义:<br>1。什么文档(球员)我们要修改。<br>2。我们想修改文档。<br>要做到这一点,我们首先检索所选球员的文档。这可以通过通过<br>选中的球员的惟一ID:<br>PlayersList.update(selectedPlayer);<br>这件事现在应该类似于:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList.update(selectedPlayer);<br>}<br>修改文档,我们通过第二个参数更新函数定义<br>文档的一部分,我们要改变:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer {得分:5 });<br>}<br>该语句将:<br>1。找到的文档选择的球员,根据玩家的ID。<br>2。更新文档通过改变比分字段的值为5。<br>第2部分数据库,74<br>但是如果你测试这个功能,你会发现它坏了。如果你选择了一个播放器,点击“给<br>5点”按钮,这名球员的名字将会消失。比分字段的值将会改变<br>5,按计划,但名称字段将完全从文档中删除。<br>玛丽去了哪里?<br>这可能看起来像是一个错误,但默认情况下,更新函数通过删除原来的工作<br>文档和创建一个新的文档与我们指定的数据。_id字段的值<br>将保持不变,但由于我们只指定update语句内的分数,<br>这是唯一的其他领域仍在修改文档。<br>考虑到这一点,我们需要使用一套Mongo运营商,让我们的价值得分<br>场没有删除原始文档。<br>首先,用以下代码替换更新函数的第二个参数:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $:});<br>}<br>这里,我们使用这个设置操作员修改一个字段的值美元(或多个字段)<br>删除原始文档。冒号后,我们只需要通过我们想要的字段<br>修改(和他们的新值):<br>第2部分数据库,75<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $设置:{得分:5 } });<br>}<br>由于这一变化,更新函数不会被完全打破。如果我们保存文件<br>切换回Chrome,我们可以看到,选择一个球员和点击“给5分”按钮<br>将修改玩家的分数而不影响文档的其余部分。<br>设置分数而不破坏任何东西。<br>但尽管如此成功,我们仍然没有创建功能,我们旨在创建。因为<br>当我们的按钮可以设置选择玩家的分数5的价值,这就是它能做的。没有<br>多少次我们单击按钮时,字段的值不会增加任何进一步的。<br>修复这个问题,替换设置操作员与公司接线员:美元<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>根据这一变化,每当更新函数触发,比分字段的值<br>将增加任何价值我们指定的值(在本例中,5)。<br>第2部分数据库,76<br>现在可以增加分数字段的值。<br>第2部分数据库,77<br>先进的运营商,第2部分<br>没有出现在原始的排行榜的功能应用程序是衰减的能力<br>分数。虽然这样的特性将会有用,因为它意味着我们可以:<br>1。惩罚玩家不遵守规则。<br>2。收回点错误地获得。<br>也是一个很简单的特性来扔在一起。<br>首先,创建一个“带5分”按钮在“排行榜”模板:<br>&lt; input type = “按钮”class =“减量”值=“带5分”&gt;<br>与“给5分”按钮,把它在每个块和为它提供一个独特的<br>类属性(如“减量”)。<br>接下来,点击切换到JavaScript文件,复制。增加事件,将代码粘贴到<br>同样的事件。<br>块的事件应该类似于:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>},<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>},<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>});<br>在这一点上,我们只需要做两个变化:<br>首先,更改为新创建的事件选择器。.decrement增量。<br>第二,价值5通过公司运营商,而不是值为5。附加的<br>——逆转算子的功能,现在美元的公司操作符将衰减值<br>的分数。<br>最后一个事件的代码应该类似于:<br>第2部分数据库,78<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>有点冗余的代码,我们有两个几乎相同的事件——但这是<br>我们在后面的章节会修理。<br>第2部分数据库,79<br>对文档进行排序<br>目前,球员名单中排名的时候他们插入<br>收集,而不是通过他们的分数排名。<br>为了解决这个问题,我们将修改里面的球员helper函数返回语句:<br>“球员”:函数(){<br>返回PlayersList.find()<br>}<br>首先,通过一对大括号的括号找到功能:<br>“球员”:函数(){<br>返回PlayersList.find({ })<br>}<br>通过使用这些花括号,我们明确说明我们想要检索的所有数据<br>从“PlayersList”集合。这是默认的行为,所以这两个语句<br>技术上:<br>返回PlayersList.find()<br>返回PlayersList.find({ })<br>但经过花括号作为第一个参数,我们可以通过第二个<br>参数,在这第二个参数,我们可以定义如何想对数据排序<br>检索。<br>作为第二个参数,通过接线员:<br>PlayersList返回。找到({ },{ }):<br>(不像集和美元公司经营者,我们不使用美元符号的这个操作符<br>的名字。)<br>然后选择排序的字段的值:<br>PlayersList返回。找到({ },{:{分数:1 } })<br>通过值传递,我们可以按照降序排列。这意味着我们的排序<br>从得分最高的球员得分最低。如果我们通过一个值的球员<br>将排序分数最高的分数最低。<br>第2部分数据库,80<br>基于他们的分数排名球员。<br>基于这种变化,球员们将会根据他们的分数排名,但是如果两个<br>玩家同样的分数吗?<br>采取“鲍勃”和“比尔”,例如。如果他们有相同的分数,比尔应该排名高于鲍勃<br>因为,按字母顺序,首先是他的名字。但此刻,不会发生因为鲍勃<br>比尔之前添加到集合。<br>为了解决这个问题,name字段通过运营商,但是这一次,通过的值<br>1而不是1:<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } })<br>球员们仍将主要由他们的分数排名,但是一旦发生了排序,<br>球员们也会在他们的名字。这二次排序将发生在提升<br>(字母)。<br>第2部分数据库,81<br>基于分数和排名的名字。<br>根据这一变化,如果Bob和比尔有相同的分数,比尔会排名高于鲍勃。<br>第2部分数据库,82<br>个人文档<br>当用户选择其中的一个球员,球员的名字将出现在列表中<br>的球员。这并不是最有用的功能,但是:<br>1。这是最初的排行榜的一部分应用程序。<br>2。这意味着我们可以谈论一些流星的特性。<br>在JavaScript文件,创建一个helper函数,连着“showSelectedPlayer”<br>“排行榜”模板:<br>“showSelectedPlayer”:函数(){<br>/ /代码在这里<br>}<br>内部函数,获取当前选中的球员的惟一ID:<br>“showSelectedPlayer”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>然后写一个返回语句,返回数据从一个文档内<br>“PlayersList”集合。我们可以使用find函数,但findOne函数是首选<br>选择:<br>“showSelectedPlayer”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>返回PlayersList.findOne(selectedPlayer)<br>}<br>通过使用findOne函数,我们可以通过文档作为唯一的惟一ID<br>参数,我们可以避免不必要的开销,因为这个函数只<br>尝试检索单个文档。它不会像找到浏览整个集合<br>将函数。<br>有了这个功能,切换到HTML文件并将引用里面的函数<br>“排行榜”模板。我把我的列表的底部,李两两之间的标签:<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer } } &lt; /李&gt;<br>但是如果我们保存文件,输出看起来不完全正确,因为findOne函数<br>是球员的整个文档检索。为了解决这个问题,我们需要指定,我们只希望<br>显示名称字段的值,可以用点符号:<br>第2部分数据库,83<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer.name } } &lt; /李&gt;<br>现在的接口将类似于:<br>显示选中的球员的名字。<br>我们也应该让模板并不试图显示如果一个球员一个球员的名字<br>不是选择,可以用一个简单的条件:<br>{ { #如果showSelectedPlayer } }<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer.name } } &lt; /李&gt;<br>{ { /如果} }<br>这个列表项将只出现一个球员当前是否选中。<br>第2部分数据库,84<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,蒙戈更新功能的更新和删除文档<br>再现与指定的字段(同时保留相同的主键)。<br>•改变文档的值没有先删除它,设置操作员需要美元<br>被使用。这个操作符只会指定文档的值没有改变<br>影响文档的其余部分。<br>•公司美元操作符可以用来增加一个字段的值在一个特定的<br>文档。<br>•公司美元操作符可以用来衰减被放置的-一个字段的值<br>前面的符号指定的值。<br>•排序操作符可以用来排序的数据找到返回的函数。它<br>可以由多个字段排序。<br>•findOne函数只会从集合中检索单个文档,<br>更有效的方法,如果你只需要检索单个文档。<br>流星的了解:<br>•让“给5分”按钮只出现在用户已经选择。这<br>是最初的排行榜的功能的应用程序。<br>•浏览“运营商”部分Mongo文档看看的<br>可以通过纯粹的数据库操作。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>形式<br>我们已经完成重建原始排行榜的应用程序,但有足够的空间<br>扩大同新功能的应用程序。在这个章节中,我们将创建一个表单<br>允许用户添加玩家排行榜,连同其他界面控件。<br>85年<br>86年形式<br>创建一个表单<br>在HTML文件,创建一个名为“addPlayerForm”的第二个模板:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>&lt; /模板&gt;<br>包括这个地方在“排行榜”模板:<br>{ { &gt; addPlayerForm } }<br>在“addPlayerForm”模板,创建以下两个元素:<br>1。一个文本字段的名称属性设置为“playerName”。<br>2。提交按钮的值属性设置为“添加球员”。<br>模板应该类似于:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>&lt;形式&gt;<br>&lt; input type = “ text “ name = “ playerName “ &gt;<br>&lt; input type = “ submit “ value = “添加球员” &gt;</p>\n<blockquote>\n<p>&lt; /形式<br>&lt; /模板&gt;<br>由此产生的界面不会漂亮,但这是我们所需要的。<br>87年形式<br>一个表单添加球员排行榜。<br>88年形式<br>“提交”事件<br>我们已经见过几个点击事件的例子,我们可以触发执行<br>的代码,当用户单击一个特定的元素。同样,还有提交<br>事件,它允许触发执行的代码,当用户提交表单。<br>为此,创建另一个事件块isClient内部条件:<br>Template.addPlayerForm.events({<br>/ /事件到这里<br>});<br>(我们需要一个新的事件块,因为这一事件将被附加到新的“addPlayerForm”<br>模板,而不是“排行榜”模板。)<br>在这个事件块中,创建事件和事件类型设置为“提交”选择器集<br>“形式”:<br>Template.addPlayerForm.events({<br>的提交表单:函数(){<br>/ /代码在这里<br>}<br>});<br>基于这段代码中,事件的函数时将触发“addPlayerForm”内的形式<br>模板提交。<br>但是我们为什么不只是使用的单击事件形式?不会大多数用户单击submit按钮<br>呢?可能是这样,但重要的是要记住,可以提交表单<br>多种方式。在某些情况下,用户单击submit按钮,但其他时候他们会<br>点击“返回”键在键盘。通过使用submit事件类型,我们可以考虑<br>为每一个可能的方式,可以提交表单。<br>确认事件是按预期工作,放置一个控制台。日志声明里面:<br>的提交表单:函数(){<br>控制台。日志(“形式提交”);<br>}<br>但事实证明,实际上是一个事件的问题,因为当我们提交表单:<br>1。web浏览器刷新页面。<br>2。提交的“形式”的信息不会出现在控制台。<br>89年形式<br>这为什么会发生?<br>当我们把一种形式在一个网页,浏览器假设我们想要的数据<br>,并将其发送。问题是,当使用流星,我们不想<br>发送数据在任何地方——我们想要保持在当前页面——但这不是<br>标准行为浏览器而言,web页面刷新。<br>知道了这一点,我们必须禁用默认行为,web浏览器连接到表单。<br>这需要两个步骤。<br>90年形式<br>事件对象,第1部分<br>从一颗流星应用程序内触发事件时,我们可以访问的信息<br>该事件发生。这听起来可能很奇怪,但展示我的意思是,修改提交<br>表单事件如下:<br>提交表单:函数(事件){<br>控制台。日志(“形式提交”);<br>console.log(event.type);<br>}<br>在这里,我们通过这个“事件”关键字通过事件的函数的括号,然后<br>输出事件的价值。输入到控制台。<br>这个结果是双重的:<br>首先,任何关键字通过事件的函数的括号作为第一个参数<br>变成了一个参考。因为我们通过“事件”关键字,我们<br>可以参考事件在事件的函数使用关键字。但是,您可以使用<br>您所喜欢的任何一个字。(一种常见的惯例是使用“evt”或“e”而不是“事件”)。<br>第二,事件。类型是指的“type”属性事件对象。作为一个结果,<br>这段代码应该输出控制台“提交”这个词,因为这是事件的类型<br>被触发。<br>这并不能解决原来的问题尽管由于我们的页面刷新时表单<br>提交,我们不能看到控制台。日志语句。<br>为了解决这个问题,使用preventDefault函数:<br>提交表单:函数(事件){<br>event.preventDefault();<br>控制台。日志(“形式提交”);<br>console.log(event.type);<br>}<br>当附加到事件对象,这个preventDefault函数阻止默认行为<br>事件的发生。因为我们已经附加函数提交表单事件:<br>1。默认情况下,提交表单不会做任何事情。<br>2。我们需要手动定义表单的功能。<br>3所示。控制台。日志语句现在将正常工作。<br>保存文件,切换回Chrome和测试表单,它不再是刷新<br>页面。<br>91年形式<br>控制的形式。<br>注意:preventDefault函数不仅适用于形式。例如,你可以<br>完全控制的链接在一个模板:<br>“点击”:函数(事件){<br>event.preventDefault();<br>}<br>有了这个代码,模板中的任何一个元素不会像他们通常<br>会。你必须手动分配功能。<br>92年形式<br>事件对象,第2部分<br>现在我们已经完全控制的形式,我们希望提交表单的事件的<br>“playerName”文本框的内容提交表单时,和使用价值<br>添加一个球员到数据库。<br>首先,创建一个名为“playerNameVar”的变量:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar;<br>}<br>然后让这个变量等于“event.target。playerName”和输出变量的值<br>控制台:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName;<br>console.log(playerNameVar);<br>}<br>这语句使用事件对象获取任何HTML元素的name属性<br>设置为“playerName”。<br>但这段代码不工作正如你所想的那样,因为控制台。日志语句输出<br>的原始HTML文本字段,而不是它的价值:<br>抓住整个文本字段。<br>这是因为我们需要显式地检索价值属性:<br>93年形式<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>console.log(playerNameVar);<br>}<br>基于这种变化,无论用户输入文本字段将“playerName”<br>提交表单时输出到控制台。<br>文本字段的值出现在控制台。<br>提交的播放器插入“PlayersList”收藏,添加里面的插入功能<br>提交表单的事件:<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>而不是通过一个硬编码值名称字段,如“大卫”或“Bob”,通过<br>通过“playerNameVar”变量的引用。<br>现在事件的代码应该类似于:<br>94年形式<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>}<br>和现在应该像预期的那样工作。<br>凯尔被添加到排行榜。<br>95年形式<br>删除玩家<br>自从我们成为可能添加球员排行榜,这是一个好主意让它成为可能<br>也从排行榜中删除玩家。<br>为了实现这一点,首先创建一个“删除玩家”按钮在“排行榜”模板:<br>&lt; input type = “ button “ class = “删除” value = “删除玩家” &gt;<br>与其他按钮在这个项目中,附加一个独特的类属性,我们可以参考<br>按钮的事件。<br>在JavaScript文件,将下列事件附加到“排行榜”模板:<br>的点击。删除”:函数(){<br>/ /代码在这里<br>}<br>检索的ID选择球员的“selectedPlayer”会话:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>然后使用从集合中删除功能,删除选中的球员:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList.remove(selectedPlayer);<br>}<br>我们还没有谈到了去除函数,但没什么多说的。所有<br>我们要做的就是通过文档的惟一的ID作为唯一的参数。该文档<br>将从集合中删除。<br>用户将可以从列表中删除的球员。<br>96年形式<br>总结<br>在这一章,我们了解到:<br>•通过使用submit事件类型,我们可以触发时执行代码是一种形式<br>提交。<br>•使用提交事件而不是单击事件以来可以提交的一种形式<br>许多不同的方式(如“返回”键。)。<br>•我们可以从内部访问信息的一个事件,事件的功能,和也<br>操纵事件发生。<br>•浏览器的默认行为附加到形式,干扰我们的代码,但这一点<br>行为与preventDefault函数可以禁用。<br>•当表单字段名称属性,有一个简单的语法的价值<br>表单字段。<br>•通过Mongo文档的ID通过删除功能,我们可以删除<br>特定的文档集合。<br>流星的更深层次的理解:<br>•所以,后提交“添加球员”的形式,“playerName”文本的价值<br>字段是重置为空值。<br>•创建一个警告,要求用户确认他们是否真的想要删除一个<br>球员后从列表中点击“删除的球员”按钮。<br>•“分数”字段添加到“添加球员”形式,允许用户定义一个球员的得分<br>当他们被提交到列表中。<br>在其当前状态查看代码,查看GitHub提交。</p>\n</blockquote>\n<p>账户<br>我们的应用程序有许多有用的特性,但仍只支持单个球员的名单。<br>这意味着只能有一个用户应用程序在任何特定的时间,也就是<br>愚蠢的网络应用程序。<br>为了解决这个问题,我们将创建一个用户帐户系统,这样是最简单的一个<br>我们可以做的事情与框架。<br>有了这个系统,我们将使它如此:<br>•用户可以注册并登录到应用程序。<br>•注销用户不会看到“添加球员”的形式。<br>•每个用户将有自己的独特的排行榜。<br>它的很多功能,但不会花很多的代码。<br>97年<br>账户98<br>登录供应商<br>扩展我们的流星的功能项目在几秒钟之内,我们可以安装一个范围<br>包,包基本上是插件:<br>1。重要的功能添加到一个项目。<br>2。减少我们需要编写的代码量。<br>默认情况下,每个流星项目本地访问官方包的数量。这些都是<br>包,大多数开发人员需要使用在某种程度上,但不一定<br>在每一个项目。(也有成千上万的第三方包,但是他们超出了<br>这本书的范围,所以我们将只关注官方包。)<br>添加一个用户帐户系统我们的项目,我们将首先安装一个“登录供应商”包。这些<br>包使它非常容易为一个账户系统添加一个后端应用程序。<br>例如,通常创建一个用户帐户系统将涉及创建一个收集的<br>用户的数据:<br>useraccount = new Mongo.Collection(“用户”);<br>然后编写应用程序逻辑注册和登录,等等。<br>但在处理流星时,所有我们要做的是切换到命令行并运行<br>下面的命令:<br>流星添加accounts-password<br>这里,我们将这个“accounts-password”包添加到项目中。这个包创建<br>后端账户系统依赖于电子邮件和密码注册和日志记录<br>在。<br>账户99<br>accounts-password包添加到项目中。<br>具体地说,这个包:<br>1。创建了一个集合存储注册用户的数据。<br>2。为我们提供了一系列有用的功能我们很快就会讨论。<br>其他登录供应商包可用,允许用户登录到我们的应用程序<br>通过服务像谷歌和Facebook,但因为这增加了一个额外的步骤流程,<br>我们专注于电子邮件和密码系统。<br>账户100<br>Meteor.users<br>一旦“accounts-password”包添加到项目中,自动集合<br>用来存储数据的注册用户。这个集合被称为流星。用户和它<br>工作就像我们可以创建自己的任何集合。<br>为了说明这一点,下面的命令输入到控制台:<br>Meteor.users<br>返回的信息证实,这只是一个普通的集合:<br>检查出流星。用户收藏。<br>知道了这一点,我们可以使用查找和获取功能集合:<br>.fetch Meteor.users.find()();<br>但由于没有注册用户,将返回任何数据。<br>账户101<br>登录界面<br>我们已经设置账户的后端系统,但是前端呢?是<br>我们将编写接口代码,允许人们注册和登录和改变他们<br>帐户详细信息吗?<br>不。<br>我们可以创建一个定制的界面,它实际上是一个非常简单的事情,但有一个更容易<br>办法尽快启动并运行。<br>即时向项目添加账户系统的前端,我们只是必须安装<br>“accounts-ui”包:<br>流星添加accounts-ui<br>然后,一旦安装,以下正文标签之间的HTML文件(或在一个<br>的模板):<br>{ { &gt; loginButtons } }<br>这里,我们包括这种“loginButtons”模板,这是包含在“accounts-ui”<br>包中。因为这个包被添加到这个项目中,我们现在可以包括这个模板<br>任何我们想要的接口。<br>看看这个模板包含,保存文件并切换到浏览器。你会注意到一个”的迹象<br>出现在“按钮,当点击,一个登录表单和一个“创建帐户”链接将出现:<br>账户102<br>一个即时的接口。<br>虽然这不是一个纯粹的虚拟接口。已经没有任何配置,这是有可能的<br>用户注册、登录和注销。没有理由做这些事情——注册<br>和非注册用户将看到相同的内容,但这是我们将在未来解决<br>部分。<br>现在,使用查找和获取函数的流星。用户组:<br>账户103<br>第一个用户的数据。<br>返回你会注意到一个文档,该文档包含的数据<br>这是刚刚创建的。您可以单击箭头看到面临的下行数据联系在一起<br>该帐户。<br>账户104<br>登录状态<br>目前,未注册用户可以看到“添加球员”形式,不赚很多<br>有意义的。这种形式注册用户只能访问。<br>为了达到这个目标,改变“addPlayerForm”模板如下:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>{ { #如果currentUser } }<br>&lt;形式&gt;<br>&lt; input type = “ text “ name = “ playerName “ &gt;<br>&lt; input type = “ submit “ value = “添加球员” &gt;</p>\n<blockquote>\n<p>&lt; /形式<br>{ { /如果} }<br>&lt; /模板&gt;<br>在这里,我们指的是这个currentUser对象检查当前用户是否已登录。<br>这个对象所提供的“accounts-password”包,和逻辑很简单:<br>1。如果当前用户登录,currentUser将返回true。<br>2。如果当前用户没有登录,currentUser将返回false。<br>因此,只有几行代码,我们使它所以只有登录用户可以<br>(相互作用)的形式。<br>账户105<br>为每个用户分配一个排行榜<br>使我们的应用程序有些有用的更广泛的受众,我们需要让每一个<br>注册用户可以自己独立的球员名单。它可能不明显<br>我们怎么做这个,最困难的一点编程弄清楚吗<br>如何处理这样的问题,但这个过程本身不涉及很多步骤。<br>首先,下面的语句:<br>var currentUserId = Meteor.userId();<br>提交表单事件:内…<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>}<br>在这里,我们创建这个“currentUserId”变量,存储返回的值的<br>流星。标识功能。我们还没有谈到这个函数,但并不多<br>解释一下。它只是返回当前登录用户的惟一ID。<br>然后添加一个“createdBy”字段中插入功能,并通过“currentUserId”<br>变量:<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>因此,当用户添加一个球员排行榜,该用户的惟一ID<br>与玩家相关的补充道。<br>为了演示这个:<br>1。保存文件。<br>2。切换回Chrome。<br>3所示。添加一个球员排行榜。<br>账户106<br>然后使用“PlayersList”上的发现和获取函数集合,并单击downwardfacing<br>箭头为最近创建的文档。您将看到如何该文档包含了<br>用户的ID此玩家添加到集合中。<br>将一个球员与一个用户相关联。<br>接下来,我们将修改玩家helper函数:<br>“球员”:函数(){<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>首先,设置另一个“currentUserId”变量:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>然后改变返回语句,所以只返回球员当他们createdBy字段是相等的<br>当前登录用户的惟一ID:<br>账户107<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ createdBy:currentUserId },<br>{:{分数:1,名字:1 } });<br>}<br>这可以确保用户只能看到球员他们添加到排行榜中,从而产生的效应<br>,每个用户都有自己的独特的球员名单。<br>只看到球员属于当前用户。<br>账户108<br>项目重置<br>目前,有一些球员在数据库没有连接到任何特定的人<br>用户——球员被添加到前一节中——这意味着我们之前数据库<br>不需要他们在我们集合。<br>给自己一个全新的开始,然后,切换到命令行,停止与CTRL本地服务器</p>\n<ul>\n<li>C,输入以下命令:<br>流星重置<br>这将勾销数据库,因为我们写的代码在前一节中,<br>此时玩家添加到集合将被附加到当前登录的用户。<br>你可能会发现自己使用这个命令半定期,大量无用的数据很容易<br>在开发过程中填充数据库。<br>账户109<br>总结<br>在这一章,我们了解到:<br>•包让我们迅速向应用程序添加功能。有一些官员<br>包,还有成千上万的第三方包。<br>•“登录供应商”包来创建一个账户的后端系统。我们可以<br>创建一个后端,依赖于电子邮件和密码,或者像Twitter和服务<br>Facebook(或服务)的组合。<br>•安装登录提供者包之后,一颗流星。用户自动收集<br>用来存储数据的注册用户。<br>•accounts-ui包允许我们快速添加一个账户系统的用户界面<br>一个项目。你可以把一个自定义的方法,但这个样板的方法是伟大的<br>对于初学者来说。<br>•我们可以检查当前用户是否已登录通过引用curentUser<br>对象从一个模板。<br>•的惟一的ID来检索当前登录的用户,我们可以使用Meteor.userId()<br>函数。<br>流星的更深层次的理解:<br>•安装一个不同的登录供应商包装,像accounts-twitter包(但<br>确定accounts-ui包也是安装)。<br>•浏览atmospherejs.com查看很多第三方包<br>流星。<br>在其当前状态查看代码,查看GitHub提交。</li>\n</ul>\n</blockquote>\n<p>发布与订阅<br>到目前为止,我们已经构建了一个功能丰富的应用程序与流星,但我们没有说什么<br>安全,这是一个很大的网络软件开发的一部分。在大多数情况下,我想要的<br>向你们展示如何构建尽可能快速和简单的东西,但也有几个<br>安全我们应该谈论的话题前发布到web项目。<br>首先,让我们来谈谈出版物和订阅。<br>110年<br>发布和订阅111<br>数据安全<br>展示我们的项目的一个安全缺陷:<br>1。注册两个单独的用户帐户。<br>2。每个帐户下,添加三个球员。<br>3所示。注销的账户。<br>正因为如此,共有6名球员应该存在在数据库和他们应该“属于”<br>总共有两个用户。<br>下一步,使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>你会注意到,我们以前见过,所有返回的数据收集。我们可以<br>看到所有的数据属于两个用户。但这实际上是一个问题。因为除非<br>我们关闭这个功能,这个应用程序的每个用户将有同样的,肆无忌惮的访问权<br>每一个数据库内的数据。没有什么阻止他们深入挖掘<br>“PlayersList”收集的发现和获取功能。<br>访问所有的数据。<br>这个项目的数据不是特别敏感,它不像我们存储信用卡号码<br>——但:<br>发布和订阅112<br>1。如果我们存储敏感数据,这将是一个不可原谅的监督。<br>2。它有害的实践数据提供给用户当它不是必需的。<br>然而,这并乞求问题:<br>为什么这个功能存在的流星?如果是这样一个巨大的安全风险来访问数据<br>通过控制台,为什么允许这样做吗?<br>很简单,方便。在本书中,我们已经使用查找和获取<br>函数和他们伟大的工具来管理和操作的内容<br>数据库。只是,在我们与世界分享应用程序之前,我们必须:<br>1。禁用这种默认行为,限制访问的大部分数据。<br>2。精确地定义数据应该提供给特定的用户。<br>这就是我们将讨论接下来的章节。<br>发布和订阅113<br>autopublish<br>功能,允许我们使用控制台导航项目的数据<br>包含在一个“autopublish”包包含在默认情况下每个流星项目。<br>如果我们删除这个包,用户无法通过控制台访问任何数据,但它<br>也将打破应用程序,因此我们需要采取一些额外的步骤。<br>删除“autopublish”包从项目,运行以下命令:<br>流星删除autopublish<br>如果你登录的用户帐户删除包的时候,你不会注意到<br>任何不同,但尝试发现和获取功能:<br>.fetch PlayersList.find()();<br>你会注意到我们再也不能浏览里面的数据集合。唯一的<br>返回一个空数组。它看起来像数据已被删除,但事实并非如此。<br>它只是被获得。<br>现在问题是,我们的数据安全,因为如果我们登录的用户帐户,<br>数据也无法访问的接口:<br>没有可用的数据。<br>为了解决这个问题,我们需要找到一些我们面临的两个极端——之间的中间立场<br>一切都被访问和没有被访问。这涉及到精确的定义<br>数据应该提供给我们的用户。<br>发布和订阅114<br>isServer<br>在本书中,我们主要是在isClient条件编写代码。这是<br>因为我们大多写的代码意味着浏览器内运行(如代码<br>影响界面)。然而,很多情况下我们希望代码运行<br>在服务器上。<br>为了演示这些情况之一,地方在isServer如下声明<br>在JavaScript文件的条件:<br>.fetch console.log(PlayersList.find()());<br>不出所料,输出出现在命令行(而不是控制台),但要注意<br>我们没有任何麻烦检索“PlayersList”收集的数据。即使在<br>删除“autopublish”计划,我们有自由统治的数据直接在工作<br>与服务器。<br>为什么?<br>嗯,在服务器上执行的代码本身是可信的。所以,当我们停止用户<br>应用程序访问数据的前端——在客户端——我们可以继续<br>在服务器上检索数据。<br>你很快就会知道这个细节的有效性。<br>发布和订阅115<br>出版物,第1部分<br>在本节中,我们将发布“PlayersList”内的数据收集,和<br>从概念上讲,你能想到的出版数据传输数据到从服务器<br>醚。我们只是指定哪些数据应该提供给用户。我们不关心的地方<br>最终的数据。<br>为了实现这一点,删除控制台。日志声明isServer条件和替换它<br>一颗流星。发布功能:<br>Meteor.publish();<br>这个函数的括号之间,通过“应”作为第一个参数:<br>Meteor.publish(球员);<br>这个论点是一个名字,我们会参考。<br>然后,作为第二个参数,通过一个函数:<br>流星。发布(“球员”,函数(){<br>/ /内部发布功能<br>});<br>在这个函数,我们指定哪些数据应该提供给应用程序的用户。<br>在这种情况下,我们将返回所有的“PlayersList”收集的数据:<br>流星。发布(“球员”,函数(){<br>返回PlayersList.find()<br>});<br>这段代码复制autopublish的功能,这意味着它不是我们什么<br>想要的,但这是一个正确方向的一步。<br>发布和订阅116<br>订阅<br>因为流星。发布在服务器上执行的函数,我们现在可以订阅<br>这些数据在isClient条件,再一次做项目的数据访问<br>通过浏览器和控制台。<br>如果你想象一下,发布功能是传输数据到醚,然后订阅<br>函数是我们使用“捕捉”数据。<br>在isClient条件,写如下:<br>Meteor.subscribe();<br>这是流星。订阅功能,唯一的参数,我们需要通过<br>发布函数的名称:<br>Meteor.subscribe(球员);<br>保存文件,然后使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>你会注意到,再一次,我们可以访问所有的数据从项目的数据库,<br>意味着我们的应用程序是回到原来的状态。这还不是我们想要的,但这是另一个<br>重要的一步。<br>发布的所有数据。<br>发布和订阅117<br>出版物,第2部分<br>现在的目标是让流星。发布函数只从服务器发布数据<br>属于当前登录的用户。<br>这意味着:<br>1。登录用户只能访问自己的数据。<br>2。注销用户没有访问任何数据。<br>最后,应用程序将全功能保护潜在的敏感<br>数据。<br>为了达到这个目标,我们需要访问当前登录用户的惟一ID从内<br>流星。发布功能。在这个函数,我们不能使用Meteor.userId()<br>之前的功能。相反,我们必须使用下面的语句:<br>this.userId;<br>虽然语法是不同的,最终的结果是一样的。该语句返回唯一的<br>当前登录用户的ID。<br>声明在“currentUserId”变量:<br>流星。发布(“球员”,函数(){<br>var currentUserId = this.userId;<br>返回PlayersList.find()<br>});<br>然后改变找到函数只所以检索文档createdBy字段是相等的<br>当前登录用户的ID:<br>流星。发布(“球员”,函数(){<br>var currentUserId = this.userId;<br>PlayersList返回。找到({ createdBy:currentUserId })<br>});<br>保存文件,然后使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>如果你登录,您只会看到的数据属于当前用户的帐户,如果<br>你没有登录,你不会看到任何数据。这是因为内部的返回语句<br>流星。发布函数只能返回文档,包含当前的惟一ID<br>用户。<br>发布和订阅118<br>返回一个有限选择的数据。<br>也知道,我们现在可以简化玩家从这个函数:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ createdBy:currentUserId },<br>{:{分数:1,名字:1 } });<br>}<br>…:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>为什么?<br>因为球员内部的返回语句函数只能检索数据<br>从服务器发布。因此,指定要检索用户的数据<br>两个地方是多余的。我们只需要定义Meteor.publish中返回的数据<br>函数。<br>发布和订阅119<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,所有的数据在一个流星项目的数据库提供给所有用户<br>应用程序。这是方便的在开发期间,但它也是一个很大的安全漏洞<br>需要在部署前固定。<br>•这个默认功能都包含在一个“autopublish”包。如果我们删除这个<br>计划,项目将更安全,但它也会打破,需要固定的。<br>•流星。发布函数定义哪些数据应该在服务器端<br>提供给应用程序的用户。<br>•流星。订阅功能是用于客户端检索的数据<br>从服务器发布。<br>•在发布功能,我们不能使用Meteor.userId()函数,但我们可以<br>与this.userId检索当前用户的ID。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>方法<br>在前面的章节中,我们讨论的第一个包含两个主要的安全问题<br>每颗流星项目默认情况下。这个问题是用户通过导航的能力<br>所有的数据在数据库内部,直到我们把“autopublish”包。基于这些<br>我们做了改变,用户现在只有访问“属于”的数据。<br>为了演示第二个主要安全问题,输入以下命令控制台:<br>PlayersList。插入({ name:“伪玩家”,分数:1000 });<br>看有什么问题吗?<br>虽然我们已经取得了它所以用户不能浏览所有的数据在数据库中,用户<br>仍然能够自由使用控制台插入数据到数据库中。这意味着用户可以:<br>1。利用应用程序自己的优势。<br>2。数据库填充无用的、多余的数据。<br>用户还能够从数据库修改和删除数据,意味着在默认情况下,<br>他们主要有完全的管理权限。<br>与前面的安全问题,这个特性是当我们开发一个方便<br>应用程序,因为它很容易创建和管理数据,但这是一个我们需要的特性<br>关闭之前部署。<br>此功能包含在一个“没有安全感”包,我们可以删除它<br>项目使用下面的命令:<br>流星消除不安全的<br>删除包后,切换回Chrome和尝试和应用程序。<br>你会注意到:<br>•我们再也不能给分的球员。<br>•我们再也不能拿分的球员。<br>•我们再也不能从列表中移除玩家。<br>•我们再也不能将玩家添加到列表。<br>所有的插入、更新和删除功能停止工作——都通过<br>接口和控制台应用程序,所以更安全的结果,但是我们会有<br>解决很多事情。<br>120年<br>方法对121<br>创建一个方法<br>直到这个时候,所有的插入、更新和删除功能已经在isClient<br>有条件的。这是快速和容易的方法,但这也是为什么我们的应用程序<br>天生没有安全感。我们已经把这些敏感,clientside数据库驱动的功能。<br>更安全的做法是将这些函数isServer条件,也就是说:<br>1。数据库代码将执行服务器的可信的环境中。<br>2。用户无法使用这些函数从控制台,因为用户没有<br>直接访问服务器。<br>为了实现这一点,我们将创建我们的第一个方法,方法执行的代码块<br>在服务器上被触发后从客户端。如果这听起来奇怪,不要害怕。这是<br>其中的一次,之后在写出代码将帮助解释很多。<br>在isServer条件,写如下:<br>Meteor.methods({<br>/ /方法去这里<br>});<br>这是我们将使用代码块来创建我们的方法。你会发现语法很相似<br>我们如何创建两个助手和事件。<br>为了演示什么方法,创建一个“sendLogMessage”的方法:<br>Meteor.methods({<br>“sendLogMessage”<br>});<br>然后将该方法与功能:<br>Meteor.methods({<br>“sendLogMessage”:函数(){<br>控制台。日志(“Hello world”);<br>}<br>});<br>接下来,“电话”这个方法从底部的提交表单事件附加到“addPlayer -<br>形成“模板:<br>方法对122<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.playerName.value;<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>Meteor.call(“sendLogMessage”);<br>}<br>通过使用这颗流星。调用语句,通过我们创建的方法的名称,<br>我们能够触发方法时的执行“添加球员”提交表单。<br>保存文件,切换回Chrome,并提交“添加球员”形式。核心功能<br>这种形式的仍然是破碎的,但是如果你切换到命令行,您将看到“Hello<br>世界”的消息似乎每次提交表单。客户端表单的提交<br>触发的方法,但实际代码的方法是在服务器上执行。<br>代码在服务器上执行,导致当我们提交表单。<br>这个基本原则是我们在本章的其余部分使用。<br>方法对123<br>插入数据(再一次)<br>再次让应用程序工作,我们首先将插入函数里面提交<br>表单事件从客户机和服务器。<br>这意味着:<br>1。插入函数将成功地和安全地运行在服务器上。<br>2。用户仍然无法通过控制台插入数据。<br>换句话说,“添加球员”提交表单时,插入函数将触发<br>服务器从客户端触发后。<br>首先,“sendLogMessage”方法的名称更改为“insertPlayerData”,和摆脱<br>控制台。日志语句:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>/ /代码在这里<br>}<br>});<br>在方法内部,抓住当前登录用户的惟一ID:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>var currentUserId = Meteor.userId();<br>}<br>});<br>然后下面添加一个熟悉的插入函数声明:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>这里,我们通过一个硬编码值的“大卫”,这并不是我们所想要的,<br>但这已经足够好了。<br>返回到提交表单事件和删除currentUserId变量和插入<br>函数。事件应该类似于:<br>方法对124<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>Meteor.call(“sendLogMessage”);<br>}<br>但也一定要通过正确的方法名流星。调用语句:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>Meteor.call(“insertPlayerData”);<br>}<br>基于这些变化,“添加球员”形式将现在的工作。如果我们提交表单,<br>一个球员将被添加到“PlayersList”集合。我们只能添加球员叫“大卫”,<br>但在下一节我们将解决这个问题。<br>再次插入函数的工作。<br>现在,重要的是,用户可以添加玩家通过列表形式,<br>他们不能够使用插入函数从控制台。这意味着我们获得<br>控制用户如何与数据库的交互,这是一个保持应用程序的重要组成部分<br>安全。<br>方法对125<br>传递参数<br>“添加球员”形式的问题是文本字段的值没有被传递到<br>该方法。这样,当我们提交表单时,创建的球员的名字将永远<br>被设置为“大卫”。<br>为了解决这个问题,通过“playerNameVar”变量通过流星。调用语句作为第二<br>论点:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>流星。调用(insertPlayerData,playerNameVar);<br>}<br>然后允许接受这个论点的方法通过将“playerNameVar”之间<br>括号的方法的功能:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>正因为如此,我们现在可以参考“playerNameVar”参考用户的价值<br>进入表单的文本字段:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>最后,这是发生了什么:<br>方法对126<br>首先,当提交表单时,“insertPlayerData”方法被调用时,和的值<br>表单的文本字段附加到电话。<br>第二,执行“insertPlayerData”方法。该方法接受的价值<br>“playerNameVar”变量,然后从里面引用变量方法的功能。<br>第三,插入函数内执行方法,因为这段代码运行在服务器上,<br>它可以运行没有“安全感”包。与刚才不同,这个函数使用价值<br>来自表单的文本字段,而不是硬编码的“大卫”的价值。<br>创建的球员与原名称。<br>表单将再次工作的预期,但仍然会是没有为用户操作方法<br>数据通过控制台。<br>方法对127<br>删除玩家(再一次)<br>以同样的方式,我们创建了一个“insertPlayerData”变量,我们要创建一个“removePlayerData”<br>方法,我们将连接到“删除的球员”按钮,里面是我们的接口。<br>就像我们如何创建助手和事件,我们的位置在一个代码块的方法,<br>记住要用逗号分开的方法:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>},<br>“removePlayerData”:函数(){<br>/ /代码在这里<br>}<br>});<br>然后我们会点击两个变化。删除事件:<br>首先,去掉删除功能:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>在它的位置,创建另一个流星。调用语句:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>Meteor.call(“removePlayerData”);<br>}<br>通过“selectedPlayer”变量,第二个参数:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(removePlayerData,selectedPlayer);<br>}<br>允许接受这个论点的方法:<br>方法对128<br>“removePlayerData”:函数(selectedPlayer){<br>/ /代码在这里<br>}<br>然后重新创建删除方法内部的函数:<br>“removePlayerData”:函数(selectedPlayer){<br>PlayersList.remove(selectedPlayer);<br>}<br>“删除玩家”按钮将按预期工作,但用户仍然没有完成<br>管理访问数据库相关函数在控制台。<br>清除旧数据。<br>然而,一个挥之不去的问题…<br>因为“removePlayerData”方法执行从客户端,用户可以执行<br>同样的自称,从控制台:<br>流星。调用(‘ removePlayerData ‘,’ 8 sad8a90d8s9ad ‘);<br>因此,尽管他们没有获得全方位的插入、更新和删除功能<br>能做的,他们仍然可以做一些伤害。例如,他们可以运行这个命令来删除一个<br>玩家从另一个用户的列表。<br>这不是一个悲剧的巨大的安全漏洞,但这是我们应该解决的<br>准备在未来安全漏洞。<br>最好的做法是改变“removePlayerData”从这个方法:<br>方法对129<br>“removePlayerData”:函数(selectedPlayer){<br>PlayersList.remove(selectedPlayer);<br>}<br>…:<br>“removePlayerData”:函数(selectedPlayer){<br>var currentUserId = Meteor.userId();<br>PlayersList。remove({ _id:selectedPlayer createdBy:currentUserId });<br>}<br>有了这段代码,该方法将只允许玩家从列表中被删除<br>球员属于当前用户。<br>注意:你可能会认为它不太可能用户会让这样一个混乱与另一个<br>用户的排行榜,但当涉及到安全,最好不要低估人民的能力<br>和渴望肆虐。<br>方法对130<br>修改分数<br>在这一章,我们已经使用方法为了安全,但我们也可以使用<br>方法来减少我们的项目代码的数量。<br>为了说明这一点,我们要结合点击。增加并单击。衰减事件<br>成一个单一的方法。这是有可能的,因为有很多的这些事件之间共享代码:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>},<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>事实上,唯一的区别是在点击。增加事件,我们传递一个值<br>通过公司操作符“5”,而在点击。衰减事件,我们通过<br>一个“5”的价值。<br>改善这段代码中,我们首先关注点击。增量的事件。<br>在事件中,删除更新函数,代之以一个流星。调用语句:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(modifyPlayerScore,selectedPlayer);<br>}<br>这里,我们称之为“modifyPlayerScore”的方法,这是一个我们将创建方法<br>时刻,我们通过“selectedPlayer”变量。<br>创建内部的“modifyPlayerScore”方法方法:<br>“modifyPlayerScore”:函数(){<br>/ /代码在这里<br>}<br>…,让这个方法接受的价值“selectedPlayer”:<br>“modifyPlayerScore”:函数(selectedPlayer){<br>/ /代码在这里<br>}<br>然后,在该方法的功能,重新创建更新函数,我们刚才删除:<br>方法对131<br>“modifyPlayerScore”:函数(selectedPlayer){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>基于此代码,“给5分”按钮将正常工作。使更多的方法<br>不过,灵活返回点击。增加事件和通过“5”的第三个参数<br>流星。调用语句:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(‘modifyPlayerScore selectedPlayer 5);<br>}<br>允许接受这个第三个参数的方法:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>取代“5”的价值,在这个新创建的引用的方法<br>“scoreValue”属性:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });<br>}<br>由于这一变化,现在的方法是足够灵活,我们可以用它来“给<br>5分”按钮和“5分”按钮。<br>这里有…<br>首先,从内部点击删除更新函数。衰减事件:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>第二,一颗流星。调用语句在这个事件:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>Meteor.call(“modifyPlayerScore”);<br>}<br>第三,通过“selectedPlayer”变量的值:<br>方法对132<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(modifyPlayerScore,selectedPlayer);<br>}<br>第四,通过“5”的价值,而不只是“5”:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(‘modifyPlayerScore selectedPlayer 5);<br>}<br>看到我们所做的吗?<br>我们已经取得了如此“modifyPlayerScore”方法的效用取决于我们通过<br>第三个参数:<br>1。如果我们通过一个“5”,更新函数增量的值<br>“分数”字段。<br>2。如果我们通过一个“5”,更新函数递减的价值<br>“分数”字段。<br>因此,该方法允许代码既灵活又安全。<br>我们有相同的安全缺陷前一节中,一个用户可以输入<br>下面的命令在控制台修改数据库中的任何球员的得分:<br>流星。调用(‘modifyPlayerScore’,‘8 sad8a90d8s9ad’,100);<br>但解决方案也是一样的。<br>从这只改变方法的内容:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });<br>}<br>…:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>var currentUserId = Meteor.userId();<br>PlayersList。更新({ _id:selectedPlayer createdBy:currentUserId },<br>{ $ . n:行情):{得分:scoreValue } });<br>}<br>再次,我们检索当前登录用户的惟一的ID,并在更新<br>正在更新功能,确保玩家“属于”用户。如果登录用户<br>并不“拥有”的球员,球员的文档不会被发现的更新功能。<br>方法对133<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,有可能为用户插入、更新和删除数据的收集<br>使用JavaScript控制台。这对于开发方便,但存在安全风险<br>部署web应用程序。<br>•修复这个安全风险,我们必须从客户端数据库相关代码,<br>服务器的信任的环境。在这里,用户不会有任何直接访问(或<br>控制)数据库。<br>•这个安全风险是包含在一个“没有安全感”包。通过移除这个包,<br>应用程序将变得更加安全,但它也会休息,因为没有一个databaserelated<br>功能将工作。<br>•通过使用方法,我们能够编写代码在服务器上运行后第一个被触发<br>从客户端。这是我们如何修复项目的破碎功能。<br>•创建方法,我们可以在方法中定义块,然后触发<br>从其他地方的代码使用流星。调用语句。<br>•我们可以从流星传递数据。调用语句和方法,让我们<br>使用提交的数据表单内的方法。<br>•用户可以执行客户端流星。通过控制台调用语句,所以我们需要<br>注意这些语句允许用户做什么。<br>•方法不仅适用于安全。他们也有用结合相似的块<br>的功能到一个小的和可重复的代码片段。<br>流星的更深层次的理解:<br>•在一个新项目,首先删除“不安全”计划,从一开始,地方<br>里面所有的数据库相关代码的方法。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>结构<br>在本书中,我们把所有的项目的代码仅仅三个文件:<br>•leaderboard.html<br>•leaderboard.js<br>•leaderboard.css<br>这使得我们关注的基本面与流星没有构建软件<br>担心代码是如何组织的,该项目是非常简单的,所以我们需要不<br>需要其他文件,但:<br>1。在构建大型应用程序,是有意义的传播项目的代码在一个<br>数量的文件。<br>2。流星有许多公约组织项目的文件。<br>在我们继续之前,有两个问题需要考虑:<br>首先,流星没有硬性规定如何构造一个项目。有<br>流星鼓励某些准则,但没有严格的,你必须做的。你的喜好<br>最终在控制。<br>第二,人们仍然找出最佳实践在处理流星。因此,<br>没有理由形式教条的观点项目“应该”是如何构造的。允许<br>自己的实验。<br>这一章也不同,我们不会重组项目step-bystep排行榜。<br>相反,我们将讨论结构的原则,这些原则,这就是你的工作<br>付诸实践。<br>不过别担心。<br>基于我们覆盖到目前为止,处理如何构造一颗流星<br>应用程序将是小菜一碟。<br>134年<br>结构135<br>你的项目,你的选择<br>就像我说的,流星没有硬性规定如何组织一个项目。它不<br>关心如何组织你的文件和文件夹,如果你想创建一个大型项目<br>只是三个文件,你可以。<br>不过,与这种灵活性带来选择的矛盾:<br>如果你不局限于精确的规则,如何构建您的项目吗?<br>如果你是一个开发人员开始,您的项目结构尽可能简单的只要你<br>可以。这意味着传播您的代码在仅仅三个文件——HTML,JavaScript,和CSS<br>文件,直到这些文件变得过于臃肿的轻松地管理。这是罕见的一个实际的应用<br>包含在这样一个小结构,但如果你只是开始使用流星,它是<br>不生产为“完美”的结构。<br>仍然阅读这一章,有一些重要的约定要注意——但不要<br>觉得有必要实现每一个细节。最佳实践更容易学习一次<br>基本面已经吸收了,只要你是一个初学者,你可以变得很糟。<br>如果你不是一个开发人员,这意味着开始,如果你有网站开发经验,<br>和没有任何麻烦连同这本书,那么你会有一个简单的时间<br>实现约定我们要讨论。<br>结构136<br>脂肪薄文件,文件<br>当创建一个流星应用程序时,项目的文件可以作为“瘦”或“脂肪”,因为我们想要的<br>他们是。这意味着:<br>1。我们可以传播许多文件的代码。<br>2。我们可以包很多每个文件(或小)代码。<br>例如,让我们考虑一下”排行榜。html文件。不是脂肪,但它确实包含了<br>三个组件,虽然连接,不需要包含在单一文件:<br>•页面的HTML结构(头部标签,身体标签等)。<br>•“排行榜”模板。<br>•“addPlayerForm”模板。<br>如果这个项目变得越来越大,这将使这些组件拆分为三个<br>单独的文件。例如,你可能会想:<br>1。离开的HTML结构”排行榜。html文件。<br>2。把“排行榜”的“leaderboardList模板。html文件。<br>3所示。移动模板,一个“addPlayerForm addPlayerForm。html文件。<br>因此,它会更容易导航项目的文件因为每个文件的名称<br>暗示这文件包含什么。<br>需要澄清的是:<br>1。没有额外的步骤。把代码项目,无论你想要的<br>流星将知道如何把片段组合在一起。<br>2。文件名称是任意的。有一些“特殊”的文件名需要注意的,但是<br>一般来说,名字的文件,只要你喜欢就好。<br>你也可以将文件在文件夹和子文件夹(深层结构),但在那里<br>某些约定,鼓励某些命名这些文件夹的方法。<br>结构137<br>文件夹的约定,第1部分<br>很多内部的代码”排行榜。js”isClient条件内的文件。如果我们传播<br>这段代码在多个文件,它会不雅的重用这个条件<br>一次。<br>幸运的是,流星已经约定,任何的代码放在一个文件夹命名为“客户端”<br>只会在客户端上运行。<br>为了演示这个:<br>1。创建一个文件夹命名为“客户”在您的项目的文件夹。<br>2。在该文件夹中创建一个JavaScript文件。<br>3所示。剪切和粘贴的客户端代码”排行榜。js文件到新的文件,但是<br>没有isClient条件。<br>在保存文件时,应用程序将继续正常工作。<br>因为这个约定,最好是将模板,事件,助手,Meteor.subscribe<br>函数在一个“客户端”文件夹中。<br>相反,流星有约定的任何代码放置在一个文件夹命名<br>“服务器”只会在服务器上运行。这是我们地方项目的方法,和<br>流星。发表声明。<br>洗牌代码在排行榜内部应用程序之后,唯一的,左内<br>原始”排行榜。js文件将被声明,创建“PlayersList”集合。我们<br>希望这段代码运行在客户端和服务器,所以一定要离开这个声明<br>在“客户机”和“服务器”文件夹。一个常见的惯例是将这段代码在一个<br>”集合。js文件,但是这个文件名字没有特别的意义。<br>结构138<br>文件夹约定,第2部分<br>当开始使用流星,大多数项目的文件可能会在“客户端”<br>或“服务器”文件夹。然而,一些其他的文件夹名称,可用于不同的<br>用途:<br>•文件存储在一个“私人”文件夹只能访问的代码的执行<br>服务器。这些文件将永远不会访问用户。<br>•文件存储在一个“公共”文件夹是游客服务。这些文件是图片,图标,<br>和“机器人。txt文件。<br>•文件存储在一个“自由”文件夹其他文件之前加载。<br>但如果这一切似乎记得太多,不要害怕。这些细节是值得了解的<br>未来的参考,但这将是一段时间你需要付诸实施了。目前,<br>很好关注基础知识。<br>结构139<br>样板结构<br>学习如何结构的一种有效方式流星项目向其他开发人员学习<br>有可能遇到的许多问题有一天,你会遇到你。<br>例如,“铁”工具从克里斯事件化思想的源泉:<br>命令行脚手架流星应用程序的工具。它会自动创建<br>项目的结构,文件和样板代码。<br>这个工具可以用来快速创建一个项目使用以下结构:<br>我的app /<br>.iron /<br>json<br>bin /<br>构建/<br>配置/<br>开发/<br>env.sh<br>settings.json<br>app /<br>客户端/<br>集合/<br>lib /<br>样式表/<br>模板/<br>head.html<br>lib /<br>集合/<br>控制器/<br>methods.js<br>routes.js<br>包/<br>私人/<br>公共/<br>服务器/<br>集合/<br>控制器/<br>lib /<br>methods.js<br>publish.js<br>bootstrap.js<br>你会发现每件事都有它的位置。有文件夹集合和样式表<br>模板和其他组件的一个项目。<br>结构140<br>这是最好的方法构造一颗流星项目吗?<br>对一些人来说,它可能是。<br>我认为这有点复杂的人与流星刚刚开始,但当<br>你准备搬到一个更大的项目,它可能正是你需要管理<br>较大的基础代码。<br>在这个阶段,重点不是做出任何硬性的决定对你的偏好。但它<br>帮助了解什么至少是可能的。<br>其他样板值得一试,学习包括meteor-boilerplate和空白。<br>结构141<br>总结<br>在这一章,我们了解到:<br>•流星并不在项目执行精确的文件结构。有简单的约定<br>我们鼓励遵守为了我们自己的利益。<br>•通过命名特定文件夹,在某些方面,我们能够避免编写一些应用程序<br>逻辑基于流星如何处理这些文件夹。<br>流星的更深层次的理解:<br>•搜索别人的流星在GitHub,看看真实的项目<br>应用程序的结构。<br>•想象你创建一个博客应用程序像WordPress。你会如何结构<br>该应用程序?计划在一张纸上。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>部署<br>在本书中,我们取得了很多的进步。我们决定在项目建设,创建<br>所有的基本功能,添加了一些额外的细节,甚至谈到了几个<br>常见的安全问题。<br>因此,我们准备部署到web的应用程序。<br>在这里我们可以分享我们的创造与世界然后等待成群的陌生人<br>奇迹在我们的天才。但部署并不是简单的上传文件到web服务器。<br>有更多的参与。<br>这是一个广泛的部署过程的概述:<br>1。创建一个服务器DigitalOcean等网站。<br>2。在该服务器上安装所需的软件(节点,MongoDB,等等)。<br>3所示。配置所有的安装软件。<br>4所示。项目的文件上传到服务器。<br>5。交叉你的手指,没有休息。<br>听起来很复杂,对吗?<br>不要担心,我有你覆盖。<br>在这本书的前两个版本,我解释的绝对基础部署流星<br>应用程序web但已经放在一起更全面的指导,分开<br>从这本书。<br>你可以免费在线阅读:<br>meteortips.com/deployment-tutorial<br>如果你想尽快部署的东西,你只需要阅读第一<br>两个章,但是当你准备发射比throwntogether更有趣的东西<br>轻轻原型,这本书将指导您完成每一步的过程中,<br>与其他我发布在网上,你也可以看到很多的更新<br>部署实践的变化和发展。<br>也就是说,如果你不希望将应用程序部署到世界,这很好。<br>没有什么关于部署,你需要知道这一点。这个过程是相当<br>开发过程和截然不同的东西,直到你已经开发了应用程序,你的<br>时间是更好的在一个文本编辑器,编写代码,使事情。<br>142年<br>结论<br>祝贺你。你已经达到了这本书的最后一页。在第一章,就像我说的<br>这本书不是汤姆。有更多了解建筑与流星很酷的东西<br>框架。<br>这就是我建议:<br>1。如果你还没有,实际上我们已经构建排行榜应用程序<br>讨论这本书。没有更好的方法来学习如何比通过编写代码<br>每一行,循序渐进。<br>2。看流星的官方文档。你可能不理解每一点<br>它,但它确实提供了洞察如何以及为什么某些特性工作的方式做。<br>3所示。遵循“如何正确学习流星”的路线图。这是一个彻底的课程<br>成为一个全面的流星开发者(那就推荐这个<br>书)。<br>如果你还没有,请访问meteortips.com并注册电子邮件时事通讯。这是<br>最好的方法是不管我工作,帮助你做出更大、更快<br>进步与流星。<br>这就是现在。<br>祝你好运,和说话很快。<br>€”大卫·特恩布尔<br>注:如果你喜欢这本书,在Amazon.com上留下评论。你的支持让我<br>花更多的时间来研究新材料。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"项目\"><a href=\"#项目\" class=\"headerlink\" title=\"项目\"></a>项目</h3><p>刚开始学习如何编制Web应用的开发者的一个大错误是在对要创建的东西还没有一个清淅的认识时就开始进行。但这就像开车去一个新的目的地却没有地图。你可能会在正确的方向有一个小的进展,但你可能不会到达你需要去的地方。你不需要从一开始就知道一切,但你的确至少需要一个方向。</p>\n<p>记住这一点,我们要构建Leaderboard(排行榜)——Meteor开发团队设计的一个示例应用程序展示Meteor用很少的几行代码能做什么。<br>这就是它看起来的样子:</p>\n<p>Leaderboard已经在官网上已经被更高级的例子取代了,但它会是我们的示例项目,主要有两个原因:<br>首先,这个应用程序已经存在。我们可以玩,这意味着我们可以在我们编写单行代码前对我们试图创建的应用有一个好的认识。<br>第二,应用程序很简单。这意味着我们不需要担心构建软件的概念(这通常是最困难的一部分)。相反,我们可以集中学习Meteor本身。</p>\n<p>要获得实际的时间和排行榜,请访问leaderboard2.meteor.com,点击,注意其核心特征:</p>\n<ul>\n<li>有玩家的列表。</li>\n<li>每个球员都有一个分数。</li>\n<li>球员得分排名。</li>\n<li>你可以选择玩家通过点击它们。</li>\n<li>你可以增加一个选择球员的得分。</li>\n</ul>\n<p>在后面的章节中我们将创建附加功能,但即使相对较短的列表也涉及许多Meteor的核心功能。</p>\n<h3 id=\"创建一个项目\"><a href=\"#创建一个项目\" class=\"headerlink\" title=\"创建一个项目\"></a>创建一个项目</h3><p>创建我们的第一个Meteor应用程序,我们将需要创建我们的第一个项目,一个项目是一组自包含的文件表单应用程序的基础。您可以使用单词<br>“project”和“application”互换使用,但在谈到被开发的应用时“project”会更合适。<br>每个项目都是不同的,但是一般会包含:</p>\n<ul>\n<li>HTML文件,创建接口。</li>\n<li>CSS文件,指定样式的界面。</li>\n<li>JavaScript文件,定义应用程序逻辑。</li>\n<li>文件夹,确保都是组织良好的。</li>\n</ul>\n<p>一个项目可以包含其他类型的文件,如图片和CoffeeScript文件,但在这本书中我们会尽可能保持简单,只展示我们需要的。</p>\n<p>在我们创建Leaderboard应用项目前,让我们创建一个文件夹来存储我们的Meteor项目。我们不是必须这样做,但为了保持的东西<br>有条理，这是一个好主意。</p>\n<p>当然,我们可以选择“新建文件夹”选项从“文件”菜单,但这哪儿有乐趣?相反,输入以下命令行:</p>\n<pre><code>mkdir Meteor\n</code></pre><p>然后点击“回车”键。</p>\n<p>使用mkdir命令创建一个文件夹。这mkdir命令代表“目录”,从这个名字你可能猜到,它允许我们做出一个目录。</p>\n<p>在这个实例中,我们创建一个名为“Meteor”的目录,但是您可以调用任何你想要的文件夹。的精确位置的文件夹就会出现将取决于你操作系统,但至少在Mac OS X上,将出现在“家”的文件夹目录<br>默认情况下。(如果你找不到文件夹,创建简单的搜索你的电脑。)<br>一旦准备好了目录,导航到它使用下面的命令:</p>\n<pre><code>cd Meteor\n</code></pre><p>cd命令代表“改变目录”命令行相当于在图形界面中双击一个目录,按下“回车”键后,我们将在“Meteor”目录。</p>\n<p>导航到“Meteor”文件夹。</p>\n<p>然后在这个目录中创建一个Meteor项目,运行如下命令:</p>\n<pre><code>meteor create leaderboard\n</code></pre><p>这个命令有三个部分:</p>\n<ul>\n<li>meteor部分定义这是一个meteor命令。</li>\n<li>create部分澄清,我们想创建一个meteor项目。</li>\n<li>leaderboard的部分是我们分配给项目的名称。</li>\n</ul>\n<p>运行此命令后,会出现一个“leaderboard”目录内的“meteor”文件夹,默认情况下,该文件夹将包含三个文件:</p>\n<ul>\n<li>leaderboard.html</li>\n<li>leaderboard.css</li>\n<li>leaderboard.js</li>\n</ul>\n<p>它还包含一个隐藏文件夹.meteor,但如果您的操作系统从视图中隐藏了这个文件夹,这很好。我们不会碰它。</p>\n<p>在我们的项目的文件夹</p>\n<h3 id=\"本地服务器\"><a href=\"#本地服务器\" class=\"headerlink\" title=\"本地服务器\"></a>本地服务器</h3><p>Web应用程序不像静态网站。我们不能只是打开leaderboard.html文件就奇迹的看到一个动态的Meteor的动态应用程序。事实上,如果我们在Chrome浏览器打开该文件,所有我们会看到的是一些静态文本:</p>\n<p>没有什么动态。</p>\n<p>要得到我们计划中的web应用程序,我们需要启动所谓的本地服务器。这是一个web服务器,在我们的本地机器上运行。它包含在Meteor中并允许<br>我们:</p>\n<pre><code>1.看到我们的JavaScript代码的处理结果。\n2.在我们的本地机器上运行一个数据库。\n</code></pre><p>如果你使用一个应用程序像MAMP部署PHP和MySQL,这将是熟悉,但如果这一切听起来可怕,不要害怕。在实践中,这很简单。<br>通过命令行中,导航到“leaderboard”目录中:</p>\n<pre><code>cd leaderboard\n</code></pre><p>然后输入以下命令:</p>\n<pre><code>meteor run\n</code></pre><p>这里,meteor的部分定义了这是一个meteor命令，run部分阐明了我们要采取的精确行动。在这种情况下,我们想要运行本地服务器。</p>\n<p>启动本地服务器。</p>\n<p>利用“回车”键后,将显示如下:</p>\n<pre><code>=&gt;Started proxy.\n=&gt;Started MongoDB.\n=&gt;Started youApp \n=&gt;running at: http://localhost:3000/r app.\n</code></pre><p>这些线确认本地服务器启动和URL的最后一行- <a href=\"http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。\" target=\"_blank\" rel=\"noopener\">http://localhost:3000——是我们现在可以使用项目在web浏览器中查看我们的Meteor。</a></p>\n<p>导航到该URL在Chrome和注意,我们不再看到静态文本。相反,我们看到一个功能的web应用程序。应用程序本身是代码的结果这是包含在每个流星项目默认情况下,这并不是最有趣的创造在世界上,但是我们仍然在正确的方向上迈出了一步。</p>\n<p>这是默认的流星的应用程序。<br>不断地查看代码的结果,我们需要保持本地服务器运行。这个简单的<br>那就意味着要离开命令行打开从这一点开始。然而,您将需要打开<br>一个单独的标签或窗口进一步写命令:<br>一个单独的运行命令的选项卡。<br>在本地服务器停止,要么退出命令行,或命令行焦点,<br>项目22<br>在你的键盘上按CTRL + C。然后再次启动本地服务器,使用相同的命令<br>之前:<br>流星跑<br>只要确保你在一个项目的文件夹在运行命令之前。<br>项目23<br>默认应用程序<br>默认应用程序没有什么特别的,但是如果我们点击“点击我”按钮,这个号码<br>在屏幕上就会增加。这提供了一个相当普通的流星的实时演示<br>特性。这个应用程序背后的代码,但是,不正是重要的因为我们将讨论<br>在接下来的章节更大范围。<br>目前,打开项目文件和删除所有的默认代码。甚至不看看<br>代码。刚刚摆脱它。我们想要从一个完全空白。<br>一旦完成,在JavaScript中输入以下文件:<br>控制台。日志(“Hello world”);<br>然后保存文件并打开JavaScript控制台在铬:<br>1。单击视图菜单。<br>2。悬停在开发人员选择。<br>3所示。选择JavaScript控制台选项。<br>窗格的底部将打开浏览器并显示“Hello world”我们的文本<br>通过控制台。日志语句。<br>“Hello World”的文本出现在JavaScript控制台。<br>项目24<br>如果这是熟悉的,很好。如果不是,那么知道控制台。日志语句用于看到输出结果<br>不创建一个接口的代码显示输出。这意味着,在我们投资<br>时间为创建一个接口,我们可以:<br>1。确认我们的代码是按预期工作。<br>2。尽快修复任何错误出现。<br>我们还可以使用控制台操作应用程序的数据库,这是我们要做的<br>下一章。<br>离开控制台打开从这一点开始,但是随时删除控制台。日志语句<br>在JavaScript文件。<br>项目25<br>总结<br>在这一章,我们了解到:<br>•当学习如何构建一个web应用程序,重要的是要有一个清晰的认识<br>你想构建。<br>•命令行可以用来迅速达到熟悉的任务,如创建文件夹和<br>他们之间导航。<br>•开发流星应用程序时,我们将它作为一个“项目”,我们可以创建一个<br>项目与流星创建命令。<br>•来查看我们的web应用程序在本地机器上,我们可以用流星运行命令<br>启动一个本地web服务器。<br>•当结合控制台。日志语句,JavaScript控制台是一个非常方便的工具<br>流星发展。<br>流星的更深层次的理解:<br>•如果你还没有,玩耍与原排行榜的应用程序。它不<br>有很多功能,但这只是意味着没有理由不是有很强的把握的<br>它的功能。<br>•关闭命令行应用程序,然后重新打开它,回到你在哪里。<br>你应该能够浏览到您的项目的文件夹cd命令启动<br>本地服务器与流星跑。<br>•创建第二个流星项目和使用这个项目尝试当你学习<br>一些新的东西。折腾了为了这是一个很好的方式钻细节<br>深入你的大脑。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>数据库中,第1部分<br>写一个技术书的一个困难的部分是决定何时引入某些想法。<br>需要教的主题书之间是一致的,但你说的顺序<br>他们可以大大影响读者理解某些内容的能力。<br>例如,往往技术作者尽可能谈论创建一个接口<br>尽快这是因为看到很有趣的视觉结果代码,和很高兴的感觉<br>像你做出了很快的进步。<br>但是这种方法并介绍一下几个问题:<br>1。很难掌握任何有关前端(接口)当你没有<br>熟悉后端(数据库,等等)。<br>2。如果我们首先谈论的前端,我们将不得不回顾在下一章,所以任何<br>快速进步的感觉将是短暂的。<br>因此,我们将首先讨论我们的项目内创建和管理数据库。这<br>不是一个“性感”的话题,但是如果我们花几分钟覆盖基础,我们将有一个强大的<br>本书的其余部分的基础。<br>26<br>第1部分数据库,27岁<br>MongoDB vs . SQL<br>如果您已经构建了一些之前在网上,你可能接触到<br>的数据库。也许你安装WordPress的副本,或使用phpMyAdmin,甚至建造<br>一些软件语言像PHP。在这些情况下,您会接触到<br>一个SQL数据库。<br>默认情况下,每个流星项目有自己的数据库。没有安装或配置<br>必需的。当你创建一个项目时,会自动创建一个数据库项目,和<br>当本地服务器正在运行,那么数据库。然而,这个数据库并不是一个SQL<br>数据库。相反,它是所谓的MongoDB数据库。<br>如果你之前从未遇到MongoDB,你可能会有点担心,但不要害怕。蒙戈<br>数据库和SQL数据库不同,但是作为初学者而言,差异<br>很小。<br>目前,你只需要知道两件事:<br>首先,没有其他类型的数据库用于流星。如果你想使用一个SQL<br>数据库,例如,它是不可能的。其他选项可以在未来,但是<br>时间其实还不清楚。<br>第二,蒙戈使用不同的词汇来描述熟知的概念。例如,我们不会<br>使用“表”和“行”这样的词,但概念基本上是相同的。你可以看到<br>这个表的差异:<br>MongoDB vs . SQL<br>会很难想起概念熟悉新单词,但是我将提供大量的提醒<br>通过这本书我们进步。<br>第1部分数据库,28<br>创建一个集合<br>排行榜的中央功能应用程序的列表的球员。没有球员的名单<br>出现在界面,我们不能建立其他任何有价值的物品。因此这是一个好地方<br>开始——从应用程序的“中间”,向外工作的细节。<br>这里有两个问题需要考虑:<br>•我们在哪里存储与每个玩家相关的数据?<br>•我们如何显示这些数据从内部接口?<br>我们将在下一章回答第二个问题,但第一个问题:“在哪里<br>我们与每个球员关联存储数据吗?”<br>滑稽的答案将是“数据库”,但更有用的答案”<br>收集”,如前一节所示,相当于一个SQL表集合。<br>为了说明的目的收集,想象我们正在创建自己的版本的WordPress<br>流星。如果是这样的话,我们会创建一个集合的文章,为集合<br>评论,和一组页面。我们会创建一个为每个类型的数据收集。自<br>我们创建这个排行榜的应用程序,我们将创建一个集合的球员。<br>要做到这一点,打开JavaScript文件,写如下声明:<br>新的Mongo.Collection(球员);<br>在这里,我们创建一个集合命名为“玩家”在我们项目的Mongo数据库。你可以<br>名字收集任何你想要的,但它必须是唯一的。如果名字不是独一无二的,流星<br>将返回一个错误。<br>尽管这行代码,我们还没有供我们参考这个集合定义了一个方法,<br>因此我们没有办法操作。<br>为了解决这个问题,将集合在一个变量:<br>PlayersList = new Mongo.Collection(球员);<br>但请注意,我们没有使用var关键字,因为我们想要创建一个全球性的<br>变量。这将允许我们引用和操作在我们所有的集合<br>项目的文件。<br>确认收集存在,保存文件,切换到Chrome浏览器,并输入的名称<br>集合的变量为控制台:<br>PlayersList<br>第1部分数据库,29岁<br>您应当会看到类似如下:<br>集合的存在。<br>这表明集合是按预期工作。<br>如果返回一个错误,这可能是因为你的名字输入错误变量在控制台,<br>或在代码中犯了一个语法错误。<br>数据库中,第1部分30<br>插入数据<br>当我们想将数据插入一个集合,我们有四个选项。我们可以通过插入数据<br>JavaScript控制台,通过命令行,通过JavaScript文件,并通过<br>形式的界面。我们将看到如何使用所有这些选项在这本书,但第一<br>选项-通过JavaScript控制台是最简单的,所以这是最好的起点。<br>在控制台中,写如下:<br>PlayersList.insert();<br>这是我们使用的语法来操纵一个集合。<br>我们开始分配给变量集合,然后——“PlayersList”变量<br>附加功能。在本例中,我们使用插入函数,但是有一个范围的<br>功能,如查找、更新和删除(和我们将讨论这些很快的细节)。<br>但是,如果我们把“返回”键在这一点上,没有什么会发生,那是因为我们<br>需要在函数的括号之间传递数据改变的内容<br>集合。<br>我们通过的数据需要以JSON格式,如果你不熟悉<br>JSON格式,这就是它的样子:<br>{<br>名称:“大卫”,<br>得分:0<br>}<br>在这里,有几个事情:<br>首先,数据是用一对大括号。这就是我们如何区分我们的JSON数据<br>剩下的代码。<br>第二,我们已经定义了一对密钥。这些键被称为名字和分数,蒙戈<br>术语,这些是我们收集的字段。因为每个球员将集合<br>有一个名称和一个分数,名字和分数字段来保存这些值。<br>第三,我们已经定义了与我们的键相关联的值。在这种情况下,价值的名字<br>字段是“大卫”和分数字段的值是0。<br>第四,键值用逗号隔开。这是因为JSON格式<br>忽略空白,所以逗号是需要提供结构。<br>我们可以通过这些数据通过括号,像这样:<br>第1部分数据库,31日<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0<br>});<br>这是一个完整的插入功能,如果我们这个语句输入到控制台和挖掘<br>“返回”键,将会创建一个文档在“PlayersList”集合。文档是<br>相当于SQL行和,在这一点上,我们要为每个玩家创建一个文档<br>希望在我们的集合。如果我们希望我们的排行榜包含六名球员,我们需要使用<br>六次插入函数,从而创建6个文档。<br>插入数据。<br>为了实现这一点,重复这句话几次,确保定义独特的值<br>名称字段,所以我们可以区分球员:<br>PlayersList.insert({<br>名称:“鲍勃”,<br>得分:0<br>});<br>由于忽略空白,语句可以写在一行:<br>PlayersList。插入({ name:“鲍勃”,得分:0 });<br>数据库中,第1部分32<br>也请注意,创建每个文档后,会出现一个随机的数字和字母<br>在控制台。这种混乱的局面是一个独特的ID MongoDB和自动创建的<br>与每个文档相关联。它的主键,它会是重要的。<br>目前,只注意到它的存在所以你不惊讶当我们讨论一遍。<br>在我们继续之前,更多的玩家插入集合。示例应用程序<br>六名球员,应该够了。<br>球员们在我的名单是:<br>•大卫<br>•鲍勃<br>•玛丽<br>•比尔<br>•沃伦<br>•蒂姆<br>他们都有得分字段设置为0。<br>将剩下的球员。<br>第1部分数据库,33<br>找到数据<br>现在,我们有一些数据收集,我们能够检索这些数据。我们将这样做<br>接口在下一章,但就目前而言,我们只是通过控制台。<br>在控制台,输入以下:<br>PlayersList.find();<br>在这里,我们使用这个找到函数,用于检索数据从指定的集合。<br>因为我们没有任何穿过支架,该语句将检索所有的<br>的数据集合。<br>以下应该出现在控制台:<br>使用find函数。<br>但很明显,这不是最可读的回应。我们的应用程序可以是有意义的,但是<br>我们不能。<br>检索数据更可读的格式,附加一个获取函数的转换<br>检索到的数据转换成一个数组:<br>.fetch PlayersList.find()();<br>第1部分数据库、34<br>您应该看到如下:<br>使用查找和获取功能。<br>我们也可以单击下箭头与每个文档相关的数据,<br>包括:<br>•_id字段,存储文档的惟一的ID(“主键”,我们<br>之前提到过)。<br>•名称字段,存储的球员的名字。<br>•比分字段,存储得分的球员。<br>但是如果我们想要检索的数据的集合,而不是所有的<br>数据?要做到这一点,我们可以通过json格式的数据之间的括号:<br>PlayersList。找到({ name:“大卫”}).fetch();<br>这里,我们通过字段名和值通过发现功能,因此,我们可以<br>只检索文档,球员的名字字段等于“大卫”。在我们的例子中,这个<br>只检索一个文档,但是如果我们集合包含多个玩家叫“大卫”,<br>他们都是根据这个查询返回。<br>也有用的是计算能力的数量由一个查询返回的文件<br>将计数函数找到函数:<br>数据库中,第1部分35<br>.count PlayersList.find()();<br>因为这个语句将计数集合中的所有文档,如果有六名球员<br>(文件)的集合,6号返回。<br>第1部分数据库、36<br>总结<br>在这一章,我们了解到:<br>•当我们创建一个流星项目,蒙戈数据库自动创建,和<br>当本地服务器正在运行,那么数据库。<br>•Mongo数据库和SQL数据库不同,但差异是无关紧要的<br>初学者而言。<br>•为每一种类型的数据需要存储在Mongo数据库中,我们需要创建一个集合。<br>集合包含文档和文档的字段和值。<br>•使用插入函数,我们可以将数据插入一个集合。这个数据结构<br>以JSON格式。<br>•通过使用find函数,我们可以从集合中检索数据。这些数据就可以<br>通过使用控制台导航。<br>流星的更深层次的理解:<br>•注意,我们还没有预定义的数据库的结构。相反,结构<br>定义数据库的动态,我们使用插入函数。<br>•在一个单独的项目中,创建一个存储不同类型的数据的集合,比如博客<br>帖子,也许。什么样的字段集合有吗?<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>模板<br>在这一章,我们将开始构建排行榜的用户界面的应用程序。<br>这包括创建我们的第一个模板。<br>首先,下面的代码在排行榜。html文件:<br>&lt;头&gt;<br>&lt;标题&gt;排行榜&lt; /名称&gt;<br>&lt; / &gt;头<br>&lt;身体&gt;<br>&lt;标题&gt;排行榜&lt; / h1 &gt;<br>&lt; /身体&gt;<br>这段代码没有什么特别之处——它只是标准的HTML,但出现<br>缺少几件事:<br>•我们没有包含html标签。<br>•我们还没有包括任何JavaScript文件<br>•我们还没有包括任何CSS文件。<br>但是我们没有包括这些事情,因为我们不需要他们。流星负责<br>对我们这些细节。它将html标记添加到文件的开始和结束,自动<br>包括项目的文件夹中包含的任何资源(比如JavaScript和CSS文件)。<br>这不是世界上最引人注目的特性,但是流星的核心理念之一<br>开发者幸福,所以有很多这样传遍了节省时间的特性<br>框架。<br>37<br>模板38<br>创建一个模板<br>模板用于创建接口和JavaScript代码之间的连接。当<br>我们把界面元素在一个模板,我们可以参考和操作<br>元素与应用程序逻辑。<br>创建一个模板,将下面的代码添加到HTML文件的底部,下<br>关闭body标签:<br>&lt;模板名称=“排行榜”&gt;<br>Hello World<br>&lt; /模板&gt;<br>在这里,我们使用这个模板标签,它使用一个名称属性来区分<br>我们创建不同的模板。在这种情况下,模板的名称是“排行榜”,我们会<br>很快这个名字从JavaScript文件的引用。<br>如果你保存文件在其当前状态,模板不出现在web浏览器。<br>在HTML文件,但是没有别的地方了。这是因为,在默认情况下,模板不出现<br>内部接口。这听起来可能很奇怪,但是考虑到,在某些情况下:<br>•您可能希望一个模板出现在某些时候。<br>•您可能希望一个模板在某些时刻消失。<br>•你可能想要一个模板出现在多个位置。<br>考虑到这种可能性,我们需要手动包含模板内部的接口。这<br>确实需要一个额外的步骤,但它会变得越来越有用,因为我们深入发展。<br>使“排行榜”模板出现在浏览器内,把这个标签之间的身体<br>需要在HTML文件:<br>{ { &gt;排行榜} }<br>显然,这不是HTML。代替。double-curly括号的使用意味着这是空格键<br>语法,空格键是语法中我们使用HTML当我们想要动态<br>发生。这是语法,桥梁之间的差距接口和应用程序逻辑。<br>我们将了解更多关于空格键在这本书,但现在,知道:<br>1。所有空格键标签使用double-curly括号来区分。<br>2。我们只使用大于符号当我们想要包括一个模板。<br>基于这些变化,HTML文件现在应该类似于:<br>模板39<br>&lt;头&gt;<br>&lt;标题&gt;排行榜&lt; /名称&gt;<br>&lt; / &gt;头<br>&lt;身体&gt;<br>&lt;标题&gt;排行榜&lt; / h1 &gt;<br>{ { &gt;排行榜} }<br>&lt; /身体&gt;<br>&lt;模板名称=“排行榜”&gt;<br>Hello World<br>&lt; /模板&gt;<br>保存文件之后,内部的“Hello World”从“排行榜”模板<br>出现在浏览器:<br>当前界面。<br>模板40<br>客户端与服务器<br>在我们继续之前,我想要证明的东西。你不需要完全理解我们<br>封面,但都遵循允许通过编写的所有代码。<br>在JavaScript文件,编写以下控制台。日志语句:<br>控制台。日志(“Hello world”);<br>这是我们声明语句写在“项目”一章,并在保存文件<br>切换回Chrome,您应该看到“Hello world”消息出现在控制台:<br>“Hello World”出现在控制台。<br>上次我没有提到虽然是,由于这种说法,别的东西也<br>发生,如果我们切换到命令行中,我们可以看到“Hello world”消息<br>也在这里:<br>模板41<br>“Hello World”出现在命令行。<br>这是很重要的,因为我们已经写一行代码的执行在两个地方。的<br>代码是运行在客户端(在用户的web浏览器)和服务器(其中<br>应用程序托管)。<br>为什么这很重要?<br>有几个原因,但这里有一个例子:<br>自从我们创造了“PlayersList”集合,下面的语句上运行<br>客户端和服务器:<br>PlayersList = new Mongo.Collection(球员);<br>但是代码不做同样的事情在这两个地方。<br>当代码在服务器上执行,创建在Mongo集合数据库。这是<br>我们的数据存储。当代码执行从用户的web浏览器中虽然-<br>在客户端创建一个本地副本的收集用户的计算机。作为一个结果,<br>当用户与数据库交互时,他们实际上交互的本地副本。这<br>部分原因是流星应用程序默认是实时的。数据是用户的操作<br>本地机器然后无形在后台与服务器端数据库同步。<br>但如果这一切听起来有点概念,不要害怕。你不需要了解细节<br>点流星的“魔法”。你只需要一行代码就可以掌握:<br>1。在两个不同的环境中运行(在客户端和服务器)。<br>模板42<br>2。根据不同的环境会有不同的行为。<br>也就是说,在某些情况下,我们不希望我们的代码运行在两个地方。如果,<br>实例中,我们编写代码,只会影响应用程序的接口,它不会是有意义的<br>在服务器上运行的代码。我们只希望它在客户机上运行。<br>适应,有一双条件我们可以用来确定代码运行<br>的环境。你会有一个更好的想法何时使用这些条件<br>通过书的进展,但是,只要跟着目前通过编写所有的<br>代码。<br>首先,一颗流星。isClient条件下的控制台。日志声明:<br>如果(Meteor.isClient){<br>/ /这段代码只在客户机上运行<br>}<br>这个条件允许我们专门执行代码在客户端——从用户的内部<br>web浏览器,为了证明这一点,我们可以简单地添加一个控制台。日志声明内<br>条件:<br>如果(Meteor.isClient){<br>控制台。日志(“你好客户”);<br>}<br>保存文件,切换到浏览器,注意,“你好”客户端消息出现在<br>控制台,但没有出现在命令行里面。这是因为代码没有被<br>在服务器上执行。<br>模板43<br>“你好,客户端”只出现在控制台。<br>我们可以创建与流星相反的效果。isServer条件:<br>如果(Meteor.isServer){<br>/ /这段代码只运行在服务器上<br>}<br>再次,我们将放置一个控制台。日志语句内部条件:<br>如果(Meteor.isServer){<br>控制台。服务器日志(“你好”);<br>}<br>保存文件之后,请注意,“你好”服务器消息出现在命令<br>线,但不出现在控制台。这是因为只有被执行的代码<br>托管服务器(应用程序)。<br>模板44<br>“你好,服务器”只出现在命令行。<br>但是如果这一切都是真的沉没,只要记住两件事:<br>1。一行代码可以运行在客户端和服务器。<br>2。有时我们不想让我们的代码运行在这两个地方。<br>精确的时刻,我们需要考虑这些点很快就将变得明朗了。<br>现在,仅仅删除控制台。日志语句,但离开他们的条件。我们会<br>很快就会使用它们。<br>模板45<br>创建一个助手<br>在这一点上,我们的“排行榜”模板只显示静态文本“Hello World”。为了解决这个问题,<br>我们将创建一个helper函数,一个辅助函数是一个常规的JavaScript函数<br>附加的模板,让我们从一个接口内部执行代码。<br>开始,我们将一个古老的方法来创建辅助函数。这种方法已被弃用,<br>这意味着它不再是官方支持,你读这句话的时候,它可能<br>不工作。但这老格式更容易教和理解,并允许我们来缓解<br>到non-deprecated方法,我们会讨论。<br>在JavaScript文件,编写以下isClient内部条件:<br>Template.leaderboard.player<br>这是弃用语法来创建一个helper函数,它可以分解成三个<br>部分:<br>首先,我们流星的模板通过关键词搜索模板工程。我们只<br>有一个模板,但是一个完整的项目会更多。<br>第二,通栏广告关键字指的是我们创建模板的名称<br>早些时候。每一个helper函数必须附加到一个模板。在这种情况下,附加功能<br>“排行榜”模板。<br>第三,球员关键字是我们给这个函数。我们很快就会参考<br>这个名字在HTML文件。<br>这个助手附加代码,将它与一个函数:<br>Template.leaderboard。球员= function(){<br>/ /代码在这里<br>}<br>“助手”这个词可能会让这种声音的,但是我们没有做什么特别的。<br>我们已经创建了一个函数,将其命名为“球员”,并连接到“排行榜”模板。<br>添加一些功能函数,创建一个返回语句返回一些静态的<br>文本:<br>Template.leaderboard。球员= function(){<br>返回“其他文本”<br>}<br>然后删除的文本“Hello World”模板,代之以“排行榜”<br>以下标记:<br>模板46<br>{ {球员} }<br>在这里,我们使用的是另一个空格键标签,就是明证double-curly括号的使用。但<br>请注意,我们不使用大于符号,这是因为我们不包括<br>模板。相反,我们引用玩家函数的名称。<br>保存文件后,返回语句的文本应该出现在浏览器内:<br>使用弃用辅助函数方法。<br>如果文本不出现,一些是错误的代码,或者这种方法创建<br>从流星助手被移除。如果你不确定它,检查你的代码错误。<br>如果您的代码就是我告诉你写,它仍然不工作,不要害怕。现在,<br>你知道老方法创建辅助函数,我们准备讨论的新方法。<br>删除所有我们刚刚创建的helper函数,代之以:<br>Template.leaderboard.helpers<br>在这里,我们有这个模板的关键字,搜索通过模板在我们的项目,<br>这个排行榜的关键字,这是一个引用“排行榜”模板。<br>但是这个帮手关键词呢?<br>我们创建一个函数命名的“帮手”?<br>不。<br>模板47<br>这个助手关键字是一个特殊的关键字,它允许我们定义多个辅助功能<br>在一个代码块。<br>因此,而不是创建一个helper函数:<br>Template.leaderboard。球员= function(){<br>/ /代码在这里<br>}<br>我们为所有的模板创建一个块的辅助功能:<br>Template.leaderboard.helpers({<br>/ /辅助函数到这里<br>});<br>这些助手以JSON格式定义,与助手的名字和一个的关键<br>相关函数的值:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回“其他文本”<br>}<br>});<br>使用逗号分隔,我们可以创建多个辅助功能:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回“其他文本”<br>},<br>“otherHelperFunction”:函数(){<br>返回“其他功能”<br>}<br>});<br>可以使用这两个辅助函数在“排行榜”模板:<br>{ {球员} }<br>{ { otherHelperFunction } }<br>这段代码可能看起来有点忙比弃用的方法,但这只是因为我们<br>使用少量的帮手。更大数量的助手,组织他们<br>这是最清洁的方法。<br>模板48<br>一对辅助函数在一个模板。<br>模板49<br>每一块<br>我们已经取得了一个helper函数,但它只是返回一些静态文本,这并不是很有趣。<br>我们真正想要的是一个helper函数,从“PlayersList”中检索文档<br>收集。然后我们就可以从界面中显示数据。<br>为了达到这个目标,helper函数的返回语句替换为以下几点:<br>返回PlayersList.find()<br>在这里,我们使用find函数函数从“数据库,第1部分”一章。这个函数<br>将从“PlayersList”检索所有的数据集合,因为我们已经把它内<br>helper函数,这些数据现在可以从内部“排行榜”模板。<br>看到这,从HTML文件中删除以下标记:<br>{ {球员} }<br>之前,我们的helper函数返回之前的一段数据,字符串,<br>这个目的,这个标签是很好,但现在的助手是返回一个数组的所有文档<br>在集合,这意味着我们需要遍历返回的数据。<br>为了实现这一点,我们可以使用空格键语法来创建一个每个块:<br>{ { #每个玩家} }<br>测试<br>{ { /每个} }<br>在这里,有几个事情:<br>首先,从“PlayersList”收集所有的文档检索的基础上,参考<br>玩家的功能。<br>第二,我们遍历返回的数据的每个语法。<br>第三,我们为每个文档输出“测试”这个词(球员)的检索。因为有<br>六名球员在收集、“测试”这个词会出现界面内的6倍。<br>模板50<br>“测试”这个词似乎每个玩家的收集。<br>从概念上讲,这就像我们有一个数组:<br>var playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);<br>…就像我们使用forEach循环遍历这个数组的值:<br>var playersList =[“大卫”,“鲍勃”,“玛丽”,“比尔”,“沃伦”,“蒂姆”);<br>playersList.forEach(函数(){<br>console.log(测试);<br>});<br>在每一块,我们也可以从内部文档检索字段的值。<br>因为我们把“PlayersList”收集的数据,我们可以显示的值<br>字段名字和分数。<br>显示玩家的名字,例如,我们可以写:<br>{ { #每个玩家} }<br>{ {名称} }<br>{ { /每个} }<br>然后显示玩家的分数,我们可以写:<br>模板51<br>{ { #每个玩家} }<br>{ {名称} }:{ {得分} }<br>{ { /每个} }<br>虽然我们不会让这个应用程序很浪费时间,我们将添加一些细微的结构<br>的接口:<br>&lt; ul &gt;<br>{ { #每个玩家} }<br>&lt;李&gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>{ { /每个} }<br>&lt; / ul &gt;<br>保存文件后,玩家的名字和分数将会出现在一个无序列表。通过<br>默认情况下,球员们会按时间——从他们插入到集合<br>玩家添加第一个球员最近增加了更多,但这是我们改变<br>后一章。<br>一种改进的界面。<br>模板52<br>总结<br>在这一章,我们了解到:<br>•流星为我们处理一些无聊的细节,如使用html标记和包括<br>JavaScript和CSS文件。<br>•通过创建模板,我们可以形成一个应用程序逻辑和我们之间的桥梁<br>接口。<br>•我们的项目的代码可以在客户端和服务器上运行,但我们并不总是想要的<br>这样的事情发生。我们可以使用isClient isServer条件控制的<br>代码运行。<br>•创建一个模板后,我们需要手动把它在界面。这给了<br>我们控制时间和地点。<br>•通过创建辅助函数,我们可以执行代码在一个模板,从而创建<br>一个动态的界面。<br>•如果一个helper函数返回一个数组的数据,我们可以通过数据在一个循环<br>模板使用每个语法。<br>流星的更深层次的理解:<br>•意识到模板可以放置在任何地方项目的文件夹。我们可以,<br>实例,把我们的“排行榜”模板在另一个HTML文件和参考{ { &gt;<br>排行榜} }将继续工作。<br>•故意打破应用程序通过将每个块之外的“排行榜”<br>模板。熟悉的错误,你会不可避免地遇到一颗流星<br>开发人员。然后你就会知道如何处理这些问题当他们意想不到的。<br>•创建一个helper函数,使用查找和计数函数返回的数量<br>球员“PlayersList”集合。然后在界面中显示这些数据。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>事件<br>在这一点上,我们有一个名单的球员出现在界面,但是没有办法<br>用户与该列表。数据动态地从“PlayersList”收集、检索<br>但用户仍将可能假定应用程序完全是静态的。<br>我们将花剩下的书解决这个问题,但在接下来的几个章节<br>特别的,我们将创建的影响能够选择球员名单内。<br>具体来说,当用户点击其中一个球员,球员的背景颜色<br>元素将会改变黄色。<br>53<br>事件54<br>创建一个事件<br>在本节中,我们将创建我们的第一个事件,事件使我们能够触发执行的代码<br>当用户点击一个按钮,轻拍一个关键键盘,或完成一系列其他<br>行动。<br>为了说明这一点,写在isClient条件如下:<br>Template.leaderboard.events({<br>/ /事件到这里<br>});<br>在这里,有几个事情:<br>首先,模板是用来搜索所有的项目模板。<br>第二,排行榜是模板的名称我们要附加事件。<br>第三,事件是特殊的关键字,是用于指定,在未来的<br>代码,我们希望指定一个或多个事件。(这段代码非常类似于我们如何创建助手<br>功能。)<br>花括号之间的事件块,使用JSON格式创建一个事件:<br>Template.leaderboard.events({<br>“点击”:函数(){<br>/ /代码在这里<br>}<br>});<br>在这里,有两个事情:<br>首先,我们定义事件类型。这是点击部分。正因为如此,里面的代码<br>相关的函数将执行当用户点击的范围内的任何地方<br>“排行榜”模板。<br>第二,这个事件我们附加一个函数,这个函数里面,我们可以写<br>代码要执行时,单击出现。<br>为了说明这一点,添加一个控制台。日志语句内的事件:<br>Template.leaderboard.events({<br>“点击”:函数(){<br>控制台。日志(“你点击”);<br>}<br>});<br>事件55<br>保存文件后,切换回Chrome和点击的范围内的任何地方<br>“排行榜”模板。每次点击,你点击“消息将出现在里面<br>控制台。<br>点击。<br>事件56<br>事件选择器<br>我们已经创建的事件是太过宽泛。它触发当用户单击任何地方范围内<br>“排行榜”的模板。在某些情况下可能是有用的,但通常我们<br>当用户希望触发一个事件做精确,喜欢点击某个按钮。<br>为了实现这一点,我们将使用事件选择器,选择符允许我们将事件附加到特定的HTML<br>元素。(如果你曾经使用jQuery,这个过程将是熟悉的,但如果不是这样,它仍然会相当<br>容易掌握。)<br>早些时候,我们把李HTML文件中的标签:<br>&lt;李&gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>目前的计划是让我们的事件触发李当用户点击其中一个元素。<br>要做到这一点,改变事件如下:<br>“李点击”:函数(){<br>控制台。日志(“你点击一个li元素”);<br>}<br>在这里,我们做了两处修改:<br>首先,我们已经添加了李后点击关键字部分。这意味着事件将触发<br>当用户点击“排行榜”内任何li元素模板。<br>第二,我们已经改变了控制台的输出。日志语句。<br>然而,我们还没有考虑:<br>会发生什么,如果我们有其他的li元素内部的“排行榜”模板,不是吗<br>玩家的列表的一部分吗?以后会这样,我们的代码的目前的形式来看,它会引发一场<br>问题。事件将触发当我们不希望它来触发。<br>为了解决这个问题,添加一个。球员对li元素类:<br>&lt;李类= “玩家” &gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>然后使用这类事件选择器:<br>的点击。球员”:函数(){<br>控制台。日志(“你点击。球员元素”);<br>}<br>在这里,我们已经取得了如此事件只会触发,当用户单击一个元素<br>的。播放器类连接到它。<br>保存文件后,最后的结果不会出现任何不同,但是如果我们添加其他元素<br>模板,事件不会触发的时候不应该。<br>事件57<br>点击一个球员。<br>事件58<br>总结<br>在这一章,我们学到的:<br>•当用户点击一个按钮,提交一个表单,或完成其他操作,我们可以<br>触发器的执行代码通过使用事件。<br>•最常见的事件类型是点击,但是有一个可用的其他选项范围<br>以许多不同的方式使我们的应用程序交互。<br>•通过使用事件选择器,我们可以精确的元素的附加事件<br>类似的语法jQuery和CSS。<br>流星的更深层次的理解:<br>•尝试不同的事件类型,包括:双击鼠标,焦点,模糊,鼠标悬停,<br>改变。找出这些不同类型的行为,试图整合他们<br>排行榜的应用程序。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>会话<br>当用户点击其中一个。球员元素,执行一个函数。当这个函数是<br>触发,我们想改变背景颜色的元素,从而产生的效应<br>被选中的球员。<br>为了实现这一点,我们将使用会话,会话允许我们不存储小块的数据<br>保存到数据库并返回访问不会记得。这类数据可能<br>听起来不立即有用,但这是一个令人惊讶的是通用的方法来解决很多共同之处<br>问题。<br>59<br>会话60<br>创建一个会话<br>创建一个会话,写在单击下面的语句。球员事件:<br>会话。集(“selectedPlayer”、“会话值测试”);<br>这里,我们使用这个会话。设置功能,通过两个参数:<br>首先,我们通过会议的名称。这个名字被用作参考。在这个<br>情况下,我们调用会话“selectedPlayer”,但随意使用任何你喜欢的名字。<br>其次,我们通过会议的价值。这是我们内部存储的数据<br>会话。在这种情况下,我们通过“会话值测试”的静态值,但我们会<br>使用一个更有趣的值。<br>证明我们的会话是按预期工作,检索的会议的价值<br>下面的语句:<br>Session.get(“selectedPlayer”);<br>块应该类似的事件:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>会话。集(“selectedPlayer”、“会话值测试”);<br>Session.get(“selectedPlayer”);<br>}<br>});<br>这里,我们使用这个会话。函数,通过“选择——的名称<br>玩家“会话,我们刚才创建的。<br>输出该会话的值到控制台,它在一个变量:<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>然后添加一个控制台。日志声明下面这条线:<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>console.log(selectedPlayer);<br>现在,当用户点击其中一个球员元素,“会话值测试”字符串<br>存储在一个会话,然后立即输出到控制台。它不是最有用的代码,<br>但这很快就会改变的。<br>61年会议<br>创建和检索一个会话。<br>62年会议<br>玩家的ID<br>当用户点击列表中的玩家之一,我们要抓住玩家的惟一ID<br>并将其存储在“selectedPlayer”会议。这将允许我们改变背景<br>这个玩家的li元素的颜色。<br>如果你不确定我是什么意思,当我说“玩家”的惟一的ID,回想<br>当我们球员插入“PlayersList”集合。每次我们使用插入<br>函数,一个随机的数字和字母会出现。混乱是唯一的ID<br>的球员。<br>首先,创建一个“playerId”变量的顶部点击。球员的事件,并使其平等<br>从之前的“会话值测试”字符串:<br>var playerId =“会话值测试”;<br>然后修改会话。集函数,通过“playerId”变量作为第二个<br>论点。事件应该类似于:<br>的点击。球员”:函数(){<br>var playerId =“会话值测试”;<br>会话。集(selectedPlayer,playerId);<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>在这一点上,关键是要使“playerId”变量等于球员的惟一ID<br>这是被点击。这并不需要大量的代码,但它确实需要一些解释。<br>现在,改变“playerId”变量如下:<br>var playerId = this._id;<br>至于原因,有两个事情:<br>首先,我们有一个参考,这取决于上下文的价值。在这种背景下,<br>这个指的是文档的球员刚刚点击。<br>第二,_id部分是包含惟一的ID字段的名称的球员。所以在<br>我们创建了一个名字和分数一样,蒙戈为每个文档创建一个_id字段。<br>(下划线本身没有任何特殊的意义。这只是部分字段的名字。)<br>由于这一变化,现在下面是可能的:<br>1。用户点击的一个球员。<br>2。玩家的惟一ID存储在“playerId”变量。<br>3所示。“playerId”变量的值存储在“selectedPlayer”会话。(可以<br>只有一个值存储在一个会话,所以每当一个新值存储,前面的<br>值是重写。)<br>63年会议<br>4所示。“selectedPlayer”会话的值输出到控制台。<br>看到这在行动:保存文件,切换回Chrome,点击任何球员<br>列表。他们惟一的ID将显示在控制台。<br>点击大卫后,鲍勃和玛丽。<br>因为我们不需要看到控制台内的点击播放器的惟一的ID,我们可以<br>简化事件如下:<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>}<br>在这里,我们只是设置的值“selectedPlayer”会议,点击的惟一ID<br>的球员。<br>64年会议<br>选择效果,第1部分<br>当用户点击一个球员在我们的列表中,我们想要改变背景颜色<br>包含该玩家的li元素的属性。这将创建该玩家的影响<br>被选中。<br>为了实现这一点,打开项目的CSS文件并创建一个名为“选择”的类。这门课应该<br>background属性,在这个例子中,我们将通过“黄色”的价值:<br>.selected {<br>背景颜色:黄色;<br>}<br>然后切换到JavaScript文件并创建一个“selectedClass”助手:<br>Template.leaderboard.helpers({<br>“球员”:函数(){<br>返回PlayersList.find()<br>},<br>“selectedClass”:函数(){<br>/ /代码在这里<br>}<br>});<br>(你会发现两个助手都是在相同的代码块,和我们讨论<br>以前,这是可能使用逗号)。<br>至于这个函数的内容,我们会让它返回“选择”这个词:<br>“selectedClass”:函数(){<br>返回“选择”<br>}<br>注意:我们需要返回的文本等于在CSS文件类的名称,因为<br>我们命名为“类”选择“在CSS文件中,我们返回“选择”从内部文本<br>这个函数。<br>接下来,切换到HTML文件并将引用这个“selectedClass”功能里面<br>li元素的class属性:<br>&lt;李类= “球员{ { selectedClass } } “ &gt; { {名称} }:{ {得分} } &lt; /李&gt;<br>“选择”类将被应用到每一个。球员的元素,从而改变了背景<br>每个元素的颜色:黄色<br>65年会议<br>“选择”类是应用于li元素。<br>这不是我们想要的但这是一个重要的一步。<br>66年会议<br>选择效果,第2部分<br>在我们继续之前,我想要证明的东西。<br>在selectedClass helper函数返回语句注释掉:<br>“selectedClass”:函数(){<br>/ /返回“选择”<br>}<br>然后编写以下:<br>“selectedClass”:函数(){<br>/ /返回“选择”<br>返回this._id<br>}<br>在这里,我们使用这个。_id检索的惟一ID的球员。而是的ID<br>输出到控制台,它会出现在每个li元素的class属性。这是<br>不是我们想要的但重要的是要知道,因为selectedClass函数<br>被执行在每一块,它可以访问所有的数据迭代<br>(包括球员的惟一的ID、姓名和分数)。<br>这证明:保存文件,切换到Chrome,右键单击li元素之一,并选择<br>“检查元素”选项。你会注意到每个玩家现在出现在的惟一ID<br>class属性:<br>67年会议<br>球员们在每个类的惟一的ID属性。<br>知道了这一点,我们要做几件事:<br>首先,我们将删除返回。<em>id声明,因为它只是用于演示目的。<br>第二,我们将取消返回语句,因为我们想要selectedClass函数<br>返回“选择”的静态文本。<br>第三,我们将创建一个“playerId”变量的函数,this.</em>——的价值<br>id:<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>返回“选择”<br>}<br>第四,我们将创建一个“selectedPlayer”为“selectedPlayer”会话变量:<br>68年会议<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>返回“选择”<br>}<br>第五,将返回语句在下列条件:<br>“selectedClass”:函数(){<br>var playerId = this._id;<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>如果(playerId = = selectedPlayer){<br>返回“选择”<br>}<br>}<br>逻辑后如果你有麻烦,这是怎么回事:<br>当用户点击一个列表中的玩家,玩家的惟一ID存储在里面<br>“selectedPlayer”会议。然后该会话的ID匹配的所有ID<br>球员们在列表中。因为玩家的ID将永远是独一无二的,只能有一个<br>单匹配,匹配时,静态文本的“选择”将返回的<br>selectedClass功能和放置在球员li元素的class属性。基于<br>在这类,玩家的li元素的背景颜色会变成黄色。(和<br>因为会话只能存储一个值,只有一个球员可以选择一次)。<br>点击后,鲍勃。<br>这是最复杂的例子在这本书中,但是你只需要掌握一种基本的会话<br>其余的章节。它并不重要,如果你不“获得”的一切。<br>69年会议<br>总结<br>在这一章,我们了解到:<br>•会议是用来存储小块的数据没有保存到数据库或<br>记得在返回访问。<br>•创建一个会话,我们使用会话。集函数,而检索的价值<br>会话我们使用会话。得到的功能。<br>•辅助函数和事件在每一块获得的数据<br>遍历的块。<br>流星的更深层次的理解:<br>•考虑我们如何使用“selectedPlayer”会议。我们还可以做些什么<br>选中的球员的惟一的ID吗?<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>数据库,第2部分<br>还有很多其余页的这本书,但是我们已经完成了大部分<br>从最初的排行榜应用程序特性。<br>剩下的我们将在本章的工作包括:<br>•增加选择球员的得分能力。<br>•排名球员的得分(从最高到最低)。<br>•显示选中的球员的名字在名单上。<br>我们也可以减量的得分选择球员,这并不是的一个特征<br>原始的应用程序,但足够简单的添加。<br>70年<br>第2部分数据库,71<br>给5分<br>在“排行榜”模板,我们将创建一个“给5分”按钮,当点击时,会<br>增加选择的球员的得分。<br>开始,将下面的按钮在“排行榜”模板:<br>&lt; input type = “ button “ class = “增量” value = “给5分”&gt;<br>按钮应该以外的每一块,类属性的设置<br>“增量”。<br>按钮做一些,添加以下事件的事件块内<br>JavaScript文件:<br>的点击。增量”:函数(){<br>/ /代码在这里<br>}<br>整个事件块应该类似于:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>},<br>的点击。增量”:函数(){<br>/ /代码在这里<br>}<br>});<br>(别忘了事件之间用逗号分隔)。<br>在点击。增加事件,我们将使用选定的玩家发现的惟一ID<br>玩家在“PlayersList”收集和增加球员的得分字段的值<br>5。<br>访问的唯一ID选择球员,使用会话。功能:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>您可以验证这个功能一个控制台。日志语句:<br>第2部分数据库,72<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>console.log(selectedPlayer);<br>}<br>选择一个球员之后,单击“给5分”按钮来显示所选的惟一ID<br>的球员。<br>单击“给5分”按钮后,玛丽的身份出现在控制台。<br>第2部分数据库,73<br>先进的运营商,第1部分<br>在这一点上,我们想做的是,当一个用户从列表中选择一个球员和点击<br>“给5分”按钮时,该玩家的分数是修改。<br>要做到这一点,删除控制台。从点击日志语句。增加事件和替换它<br>用以下:<br>PlayersList.update();<br>这是Mongo更新函数,在括号之间,我们可以定义:<br>1。什么文档(球员)我们要修改。<br>2。我们想修改文档。<br>要做到这一点,我们首先检索所选球员的文档。这可以通过通过<br>选中的球员的惟一ID:<br>PlayersList.update(selectedPlayer);<br>这件事现在应该类似于:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList.update(selectedPlayer);<br>}<br>修改文档,我们通过第二个参数更新函数定义<br>文档的一部分,我们要改变:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer {得分:5 });<br>}<br>该语句将:<br>1。找到的文档选择的球员,根据玩家的ID。<br>2。更新文档通过改变比分字段的值为5。<br>第2部分数据库,74<br>但是如果你测试这个功能,你会发现它坏了。如果你选择了一个播放器,点击“给<br>5点”按钮,这名球员的名字将会消失。比分字段的值将会改变<br>5,按计划,但名称字段将完全从文档中删除。<br>玛丽去了哪里?<br>这可能看起来像是一个错误,但默认情况下,更新函数通过删除原来的工作<br>文档和创建一个新的文档与我们指定的数据。_id字段的值<br>将保持不变,但由于我们只指定update语句内的分数,<br>这是唯一的其他领域仍在修改文档。<br>考虑到这一点,我们需要使用一套Mongo运营商,让我们的价值得分<br>场没有删除原始文档。<br>首先,用以下代码替换更新函数的第二个参数:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $:});<br>}<br>这里,我们使用这个设置操作员修改一个字段的值美元(或多个字段)<br>删除原始文档。冒号后,我们只需要通过我们想要的字段<br>修改(和他们的新值):<br>第2部分数据库,75<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $设置:{得分:5 } });<br>}<br>由于这一变化,更新函数不会被完全打破。如果我们保存文件<br>切换回Chrome,我们可以看到,选择一个球员和点击“给5分”按钮<br>将修改玩家的分数而不影响文档的其余部分。<br>设置分数而不破坏任何东西。<br>但尽管如此成功,我们仍然没有创建功能,我们旨在创建。因为<br>当我们的按钮可以设置选择玩家的分数5的价值,这就是它能做的。没有<br>多少次我们单击按钮时,字段的值不会增加任何进一步的。<br>修复这个问题,替换设置操作员与公司接线员:美元<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>根据这一变化,每当更新函数触发,比分字段的值<br>将增加任何价值我们指定的值(在本例中,5)。<br>第2部分数据库,76<br>现在可以增加分数字段的值。<br>第2部分数据库,77<br>先进的运营商,第2部分<br>没有出现在原始的排行榜的功能应用程序是衰减的能力<br>分数。虽然这样的特性将会有用,因为它意味着我们可以:<br>1。惩罚玩家不遵守规则。<br>2。收回点错误地获得。<br>也是一个很简单的特性来扔在一起。<br>首先,创建一个“带5分”按钮在“排行榜”模板:<br>&lt; input type = “按钮”class =“减量”值=“带5分”&gt;<br>与“给5分”按钮,把它在每个块和为它提供一个独特的<br>类属性(如“减量”)。<br>接下来,点击切换到JavaScript文件,复制。增加事件,将代码粘贴到<br>同样的事件。<br>块的事件应该类似于:<br>Template.leaderboard.events({<br>的点击。球员”:函数(){<br>var playerId = this._id;<br>会话。集(selectedPlayer,playerId);<br>},<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>},<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>});<br>在这一点上,我们只需要做两个变化:<br>首先,更改为新创建的事件选择器。.decrement增量。<br>第二,价值5通过公司运营商,而不是值为5。附加的<br>——逆转算子的功能,现在美元的公司操作符将衰减值<br>的分数。<br>最后一个事件的代码应该类似于:<br>第2部分数据库,78<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>有点冗余的代码,我们有两个几乎相同的事件——但这是<br>我们在后面的章节会修理。<br>第2部分数据库,79<br>对文档进行排序<br>目前,球员名单中排名的时候他们插入<br>收集,而不是通过他们的分数排名。<br>为了解决这个问题,我们将修改里面的球员helper函数返回语句:<br>“球员”:函数(){<br>返回PlayersList.find()<br>}<br>首先,通过一对大括号的括号找到功能:<br>“球员”:函数(){<br>返回PlayersList.find({ })<br>}<br>通过使用这些花括号,我们明确说明我们想要检索的所有数据<br>从“PlayersList”集合。这是默认的行为,所以这两个语句<br>技术上:<br>返回PlayersList.find()<br>返回PlayersList.find({ })<br>但经过花括号作为第一个参数,我们可以通过第二个<br>参数,在这第二个参数,我们可以定义如何想对数据排序<br>检索。<br>作为第二个参数,通过接线员:<br>PlayersList返回。找到({ },{ }):<br>(不像集和美元公司经营者,我们不使用美元符号的这个操作符<br>的名字。)<br>然后选择排序的字段的值:<br>PlayersList返回。找到({ },{:{分数:1 } })<br>通过值传递,我们可以按照降序排列。这意味着我们的排序<br>从得分最高的球员得分最低。如果我们通过一个值的球员<br>将排序分数最高的分数最低。<br>第2部分数据库,80<br>基于他们的分数排名球员。<br>基于这种变化,球员们将会根据他们的分数排名,但是如果两个<br>玩家同样的分数吗?<br>采取“鲍勃”和“比尔”,例如。如果他们有相同的分数,比尔应该排名高于鲍勃<br>因为,按字母顺序,首先是他的名字。但此刻,不会发生因为鲍勃<br>比尔之前添加到集合。<br>为了解决这个问题,name字段通过运营商,但是这一次,通过的值<br>1而不是1:<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } })<br>球员们仍将主要由他们的分数排名,但是一旦发生了排序,<br>球员们也会在他们的名字。这二次排序将发生在提升<br>(字母)。<br>第2部分数据库,81<br>基于分数和排名的名字。<br>根据这一变化,如果Bob和比尔有相同的分数,比尔会排名高于鲍勃。<br>第2部分数据库,82<br>个人文档<br>当用户选择其中的一个球员,球员的名字将出现在列表中<br>的球员。这并不是最有用的功能,但是:<br>1。这是最初的排行榜的一部分应用程序。<br>2。这意味着我们可以谈论一些流星的特性。<br>在JavaScript文件,创建一个helper函数,连着“showSelectedPlayer”<br>“排行榜”模板:<br>“showSelectedPlayer”:函数(){<br>/ /代码在这里<br>}<br>内部函数,获取当前选中的球员的惟一ID:<br>“showSelectedPlayer”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>然后写一个返回语句,返回数据从一个文档内<br>“PlayersList”集合。我们可以使用find函数,但findOne函数是首选<br>选择:<br>“showSelectedPlayer”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>返回PlayersList.findOne(selectedPlayer)<br>}<br>通过使用findOne函数,我们可以通过文档作为唯一的惟一ID<br>参数,我们可以避免不必要的开销,因为这个函数只<br>尝试检索单个文档。它不会像找到浏览整个集合<br>将函数。<br>有了这个功能,切换到HTML文件并将引用里面的函数<br>“排行榜”模板。我把我的列表的底部,李两两之间的标签:<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer } } &lt; /李&gt;<br>但是如果我们保存文件,输出看起来不完全正确,因为findOne函数<br>是球员的整个文档检索。为了解决这个问题,我们需要指定,我们只希望<br>显示名称字段的值,可以用点符号:<br>第2部分数据库,83<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer.name } } &lt; /李&gt;<br>现在的接口将类似于:<br>显示选中的球员的名字。<br>我们也应该让模板并不试图显示如果一个球员一个球员的名字<br>不是选择,可以用一个简单的条件:<br>{ { #如果showSelectedPlayer } }<br>&lt;李&gt;选中的球员:{ { showSelectedPlayer.name } } &lt; /李&gt;<br>{ { /如果} }<br>这个列表项将只出现一个球员当前是否选中。<br>第2部分数据库,84<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,蒙戈更新功能的更新和删除文档<br>再现与指定的字段(同时保留相同的主键)。<br>•改变文档的值没有先删除它,设置操作员需要美元<br>被使用。这个操作符只会指定文档的值没有改变<br>影响文档的其余部分。<br>•公司美元操作符可以用来增加一个字段的值在一个特定的<br>文档。<br>•公司美元操作符可以用来衰减被放置的-一个字段的值<br>前面的符号指定的值。<br>•排序操作符可以用来排序的数据找到返回的函数。它<br>可以由多个字段排序。<br>•findOne函数只会从集合中检索单个文档,<br>更有效的方法,如果你只需要检索单个文档。<br>流星的了解:<br>•让“给5分”按钮只出现在用户已经选择。这<br>是最初的排行榜的功能的应用程序。<br>•浏览“运营商”部分Mongo文档看看的<br>可以通过纯粹的数据库操作。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>形式<br>我们已经完成重建原始排行榜的应用程序,但有足够的空间<br>扩大同新功能的应用程序。在这个章节中,我们将创建一个表单<br>允许用户添加玩家排行榜,连同其他界面控件。<br>85年<br>86年形式<br>创建一个表单<br>在HTML文件,创建一个名为“addPlayerForm”的第二个模板:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>&lt; /模板&gt;<br>包括这个地方在“排行榜”模板:<br>{ { &gt; addPlayerForm } }<br>在“addPlayerForm”模板,创建以下两个元素:<br>1。一个文本字段的名称属性设置为“playerName”。<br>2。提交按钮的值属性设置为“添加球员”。<br>模板应该类似于:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>&lt;形式&gt;<br>&lt; input type = “ text “ name = “ playerName “ &gt;<br>&lt; input type = “ submit “ value = “添加球员” &gt;</p>\n<blockquote>\n<p>&lt; /形式<br>&lt; /模板&gt;<br>由此产生的界面不会漂亮,但这是我们所需要的。<br>87年形式<br>一个表单添加球员排行榜。<br>88年形式<br>“提交”事件<br>我们已经见过几个点击事件的例子,我们可以触发执行<br>的代码,当用户单击一个特定的元素。同样,还有提交<br>事件,它允许触发执行的代码,当用户提交表单。<br>为此,创建另一个事件块isClient内部条件:<br>Template.addPlayerForm.events({<br>/ /事件到这里<br>});<br>(我们需要一个新的事件块,因为这一事件将被附加到新的“addPlayerForm”<br>模板,而不是“排行榜”模板。)<br>在这个事件块中,创建事件和事件类型设置为“提交”选择器集<br>“形式”:<br>Template.addPlayerForm.events({<br>的提交表单:函数(){<br>/ /代码在这里<br>}<br>});<br>基于这段代码中,事件的函数时将触发“addPlayerForm”内的形式<br>模板提交。<br>但是我们为什么不只是使用的单击事件形式?不会大多数用户单击submit按钮<br>呢?可能是这样,但重要的是要记住,可以提交表单<br>多种方式。在某些情况下,用户单击submit按钮,但其他时候他们会<br>点击“返回”键在键盘。通过使用submit事件类型,我们可以考虑<br>为每一个可能的方式,可以提交表单。<br>确认事件是按预期工作,放置一个控制台。日志声明里面:<br>的提交表单:函数(){<br>控制台。日志(“形式提交”);<br>}<br>但事实证明,实际上是一个事件的问题,因为当我们提交表单:<br>1。web浏览器刷新页面。<br>2。提交的“形式”的信息不会出现在控制台。<br>89年形式<br>这为什么会发生?<br>当我们把一种形式在一个网页,浏览器假设我们想要的数据<br>,并将其发送。问题是,当使用流星,我们不想<br>发送数据在任何地方——我们想要保持在当前页面——但这不是<br>标准行为浏览器而言,web页面刷新。<br>知道了这一点,我们必须禁用默认行为,web浏览器连接到表单。<br>这需要两个步骤。<br>90年形式<br>事件对象,第1部分<br>从一颗流星应用程序内触发事件时,我们可以访问的信息<br>该事件发生。这听起来可能很奇怪,但展示我的意思是,修改提交<br>表单事件如下:<br>提交表单:函数(事件){<br>控制台。日志(“形式提交”);<br>console.log(event.type);<br>}<br>在这里,我们通过这个“事件”关键字通过事件的函数的括号,然后<br>输出事件的价值。输入到控制台。<br>这个结果是双重的:<br>首先,任何关键字通过事件的函数的括号作为第一个参数<br>变成了一个参考。因为我们通过“事件”关键字,我们<br>可以参考事件在事件的函数使用关键字。但是,您可以使用<br>您所喜欢的任何一个字。(一种常见的惯例是使用“evt”或“e”而不是“事件”)。<br>第二,事件。类型是指的“type”属性事件对象。作为一个结果,<br>这段代码应该输出控制台“提交”这个词,因为这是事件的类型<br>被触发。<br>这并不能解决原来的问题尽管由于我们的页面刷新时表单<br>提交,我们不能看到控制台。日志语句。<br>为了解决这个问题,使用preventDefault函数:<br>提交表单:函数(事件){<br>event.preventDefault();<br>控制台。日志(“形式提交”);<br>console.log(event.type);<br>}<br>当附加到事件对象,这个preventDefault函数阻止默认行为<br>事件的发生。因为我们已经附加函数提交表单事件:<br>1。默认情况下,提交表单不会做任何事情。<br>2。我们需要手动定义表单的功能。<br>3所示。控制台。日志语句现在将正常工作。<br>保存文件,切换回Chrome和测试表单,它不再是刷新<br>页面。<br>91年形式<br>控制的形式。<br>注意:preventDefault函数不仅适用于形式。例如,你可以<br>完全控制的链接在一个模板:<br>“点击”:函数(事件){<br>event.preventDefault();<br>}<br>有了这个代码,模板中的任何一个元素不会像他们通常<br>会。你必须手动分配功能。<br>92年形式<br>事件对象,第2部分<br>现在我们已经完全控制的形式,我们希望提交表单的事件的<br>“playerName”文本框的内容提交表单时,和使用价值<br>添加一个球员到数据库。<br>首先,创建一个名为“playerNameVar”的变量:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar;<br>}<br>然后让这个变量等于“event.target。playerName”和输出变量的值<br>控制台:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName;<br>console.log(playerNameVar);<br>}<br>这语句使用事件对象获取任何HTML元素的name属性<br>设置为“playerName”。<br>但这段代码不工作正如你所想的那样,因为控制台。日志语句输出<br>的原始HTML文本字段,而不是它的价值:<br>抓住整个文本字段。<br>这是因为我们需要显式地检索价值属性:<br>93年形式<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>console.log(playerNameVar);<br>}<br>基于这种变化,无论用户输入文本字段将“playerName”<br>提交表单时输出到控制台。<br>文本字段的值出现在控制台。<br>提交的播放器插入“PlayersList”收藏,添加里面的插入功能<br>提交表单的事件:<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>而不是通过一个硬编码值名称字段,如“大卫”或“Bob”,通过<br>通过“playerNameVar”变量的引用。<br>现在事件的代码应该类似于:<br>94年形式<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>}<br>和现在应该像预期的那样工作。<br>凯尔被添加到排行榜。<br>95年形式<br>删除玩家<br>自从我们成为可能添加球员排行榜,这是一个好主意让它成为可能<br>也从排行榜中删除玩家。<br>为了实现这一点,首先创建一个“删除玩家”按钮在“排行榜”模板:<br>&lt; input type = “ button “ class = “删除” value = “删除玩家” &gt;<br>与其他按钮在这个项目中,附加一个独特的类属性,我们可以参考<br>按钮的事件。<br>在JavaScript文件,将下列事件附加到“排行榜”模板:<br>的点击。删除”:函数(){<br>/ /代码在这里<br>}<br>检索的ID选择球员的“selectedPlayer”会话:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>然后使用从集合中删除功能,删除选中的球员:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList.remove(selectedPlayer);<br>}<br>我们还没有谈到了去除函数,但没什么多说的。所有<br>我们要做的就是通过文档的惟一的ID作为唯一的参数。该文档<br>将从集合中删除。<br>用户将可以从列表中删除的球员。<br>96年形式<br>总结<br>在这一章,我们了解到:<br>•通过使用submit事件类型,我们可以触发时执行代码是一种形式<br>提交。<br>•使用提交事件而不是单击事件以来可以提交的一种形式<br>许多不同的方式(如“返回”键。)。<br>•我们可以从内部访问信息的一个事件,事件的功能,和也<br>操纵事件发生。<br>•浏览器的默认行为附加到形式,干扰我们的代码,但这一点<br>行为与preventDefault函数可以禁用。<br>•当表单字段名称属性,有一个简单的语法的价值<br>表单字段。<br>•通过Mongo文档的ID通过删除功能,我们可以删除<br>特定的文档集合。<br>流星的更深层次的理解:<br>•所以,后提交“添加球员”的形式,“playerName”文本的价值<br>字段是重置为空值。<br>•创建一个警告,要求用户确认他们是否真的想要删除一个<br>球员后从列表中点击“删除的球员”按钮。<br>•“分数”字段添加到“添加球员”形式,允许用户定义一个球员的得分<br>当他们被提交到列表中。<br>在其当前状态查看代码,查看GitHub提交。</p>\n</blockquote>\n<p>账户<br>我们的应用程序有许多有用的特性,但仍只支持单个球员的名单。<br>这意味着只能有一个用户应用程序在任何特定的时间,也就是<br>愚蠢的网络应用程序。<br>为了解决这个问题,我们将创建一个用户帐户系统,这样是最简单的一个<br>我们可以做的事情与框架。<br>有了这个系统,我们将使它如此:<br>•用户可以注册并登录到应用程序。<br>•注销用户不会看到“添加球员”的形式。<br>•每个用户将有自己的独特的排行榜。<br>它的很多功能,但不会花很多的代码。<br>97年<br>账户98<br>登录供应商<br>扩展我们的流星的功能项目在几秒钟之内,我们可以安装一个范围<br>包,包基本上是插件:<br>1。重要的功能添加到一个项目。<br>2。减少我们需要编写的代码量。<br>默认情况下,每个流星项目本地访问官方包的数量。这些都是<br>包,大多数开发人员需要使用在某种程度上,但不一定<br>在每一个项目。(也有成千上万的第三方包,但是他们超出了<br>这本书的范围,所以我们将只关注官方包。)<br>添加一个用户帐户系统我们的项目,我们将首先安装一个“登录供应商”包。这些<br>包使它非常容易为一个账户系统添加一个后端应用程序。<br>例如,通常创建一个用户帐户系统将涉及创建一个收集的<br>用户的数据:<br>useraccount = new Mongo.Collection(“用户”);<br>然后编写应用程序逻辑注册和登录,等等。<br>但在处理流星时,所有我们要做的是切换到命令行并运行<br>下面的命令:<br>流星添加accounts-password<br>这里,我们将这个“accounts-password”包添加到项目中。这个包创建<br>后端账户系统依赖于电子邮件和密码注册和日志记录<br>在。<br>账户99<br>accounts-password包添加到项目中。<br>具体地说,这个包:<br>1。创建了一个集合存储注册用户的数据。<br>2。为我们提供了一系列有用的功能我们很快就会讨论。<br>其他登录供应商包可用,允许用户登录到我们的应用程序<br>通过服务像谷歌和Facebook,但因为这增加了一个额外的步骤流程,<br>我们专注于电子邮件和密码系统。<br>账户100<br>Meteor.users<br>一旦“accounts-password”包添加到项目中,自动集合<br>用来存储数据的注册用户。这个集合被称为流星。用户和它<br>工作就像我们可以创建自己的任何集合。<br>为了说明这一点,下面的命令输入到控制台:<br>Meteor.users<br>返回的信息证实,这只是一个普通的集合:<br>检查出流星。用户收藏。<br>知道了这一点,我们可以使用查找和获取功能集合:<br>.fetch Meteor.users.find()();<br>但由于没有注册用户,将返回任何数据。<br>账户101<br>登录界面<br>我们已经设置账户的后端系统,但是前端呢?是<br>我们将编写接口代码,允许人们注册和登录和改变他们<br>帐户详细信息吗?<br>不。<br>我们可以创建一个定制的界面,它实际上是一个非常简单的事情,但有一个更容易<br>办法尽快启动并运行。<br>即时向项目添加账户系统的前端,我们只是必须安装<br>“accounts-ui”包:<br>流星添加accounts-ui<br>然后,一旦安装,以下正文标签之间的HTML文件(或在一个<br>的模板):<br>{ { &gt; loginButtons } }<br>这里,我们包括这种“loginButtons”模板,这是包含在“accounts-ui”<br>包中。因为这个包被添加到这个项目中,我们现在可以包括这个模板<br>任何我们想要的接口。<br>看看这个模板包含,保存文件并切换到浏览器。你会注意到一个”的迹象<br>出现在“按钮,当点击,一个登录表单和一个“创建帐户”链接将出现:<br>账户102<br>一个即时的接口。<br>虽然这不是一个纯粹的虚拟接口。已经没有任何配置,这是有可能的<br>用户注册、登录和注销。没有理由做这些事情——注册<br>和非注册用户将看到相同的内容,但这是我们将在未来解决<br>部分。<br>现在,使用查找和获取函数的流星。用户组:<br>账户103<br>第一个用户的数据。<br>返回你会注意到一个文档,该文档包含的数据<br>这是刚刚创建的。您可以单击箭头看到面临的下行数据联系在一起<br>该帐户。<br>账户104<br>登录状态<br>目前,未注册用户可以看到“添加球员”形式,不赚很多<br>有意义的。这种形式注册用户只能访问。<br>为了达到这个目标,改变“addPlayerForm”模板如下:<br>&lt;模板名称= “ addPlayerForm “ &gt;<br>{ { #如果currentUser } }<br>&lt;形式&gt;<br>&lt; input type = “ text “ name = “ playerName “ &gt;<br>&lt; input type = “ submit “ value = “添加球员” &gt;</p>\n<blockquote>\n<p>&lt; /形式<br>{ { /如果} }<br>&lt; /模板&gt;<br>在这里,我们指的是这个currentUser对象检查当前用户是否已登录。<br>这个对象所提供的“accounts-password”包,和逻辑很简单:<br>1。如果当前用户登录,currentUser将返回true。<br>2。如果当前用户没有登录,currentUser将返回false。<br>因此,只有几行代码,我们使它所以只有登录用户可以<br>(相互作用)的形式。<br>账户105<br>为每个用户分配一个排行榜<br>使我们的应用程序有些有用的更广泛的受众,我们需要让每一个<br>注册用户可以自己独立的球员名单。它可能不明显<br>我们怎么做这个,最困难的一点编程弄清楚吗<br>如何处理这样的问题,但这个过程本身不涉及很多步骤。<br>首先,下面的语句:<br>var currentUserId = Meteor.userId();<br>提交表单事件:内…<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0<br>});<br>}<br>在这里,我们创建这个“currentUserId”变量,存储返回的值的<br>流星。标识功能。我们还没有谈到这个函数,但并不多<br>解释一下。它只是返回当前登录用户的惟一ID。<br>然后添加一个“createdBy”字段中插入功能,并通过“currentUserId”<br>变量:<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>因此,当用户添加一个球员排行榜,该用户的惟一ID<br>与玩家相关的补充道。<br>为了演示这个:<br>1。保存文件。<br>2。切换回Chrome。<br>3所示。添加一个球员排行榜。<br>账户106<br>然后使用“PlayersList”上的发现和获取函数集合,并单击downwardfacing<br>箭头为最近创建的文档。您将看到如何该文档包含了<br>用户的ID此玩家添加到集合中。<br>将一个球员与一个用户相关联。<br>接下来,我们将修改玩家helper函数:<br>“球员”:函数(){<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>首先,设置另一个“currentUserId”变量:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>然后改变返回语句,所以只返回球员当他们createdBy字段是相等的<br>当前登录用户的惟一ID:<br>账户107<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ createdBy:currentUserId },<br>{:{分数:1,名字:1 } });<br>}<br>这可以确保用户只能看到球员他们添加到排行榜中,从而产生的效应<br>,每个用户都有自己的独特的球员名单。<br>只看到球员属于当前用户。<br>账户108<br>项目重置<br>目前,有一些球员在数据库没有连接到任何特定的人<br>用户——球员被添加到前一节中——这意味着我们之前数据库<br>不需要他们在我们集合。<br>给自己一个全新的开始,然后,切换到命令行,停止与CTRL本地服务器</p>\n<ul>\n<li>C,输入以下命令:<br>流星重置<br>这将勾销数据库,因为我们写的代码在前一节中,<br>此时玩家添加到集合将被附加到当前登录的用户。<br>你可能会发现自己使用这个命令半定期,大量无用的数据很容易<br>在开发过程中填充数据库。<br>账户109<br>总结<br>在这一章,我们了解到:<br>•包让我们迅速向应用程序添加功能。有一些官员<br>包,还有成千上万的第三方包。<br>•“登录供应商”包来创建一个账户的后端系统。我们可以<br>创建一个后端,依赖于电子邮件和密码,或者像Twitter和服务<br>Facebook(或服务)的组合。<br>•安装登录提供者包之后,一颗流星。用户自动收集<br>用来存储数据的注册用户。<br>•accounts-ui包允许我们快速添加一个账户系统的用户界面<br>一个项目。你可以把一个自定义的方法,但这个样板的方法是伟大的<br>对于初学者来说。<br>•我们可以检查当前用户是否已登录通过引用curentUser<br>对象从一个模板。<br>•的惟一的ID来检索当前登录的用户,我们可以使用Meteor.userId()<br>函数。<br>流星的更深层次的理解:<br>•安装一个不同的登录供应商包装,像accounts-twitter包(但<br>确定accounts-ui包也是安装)。<br>•浏览atmospherejs.com查看很多第三方包<br>流星。<br>在其当前状态查看代码,查看GitHub提交。</li>\n</ul>\n</blockquote>\n<p>发布与订阅<br>到目前为止,我们已经构建了一个功能丰富的应用程序与流星,但我们没有说什么<br>安全,这是一个很大的网络软件开发的一部分。在大多数情况下,我想要的<br>向你们展示如何构建尽可能快速和简单的东西,但也有几个<br>安全我们应该谈论的话题前发布到web项目。<br>首先,让我们来谈谈出版物和订阅。<br>110年<br>发布和订阅111<br>数据安全<br>展示我们的项目的一个安全缺陷:<br>1。注册两个单独的用户帐户。<br>2。每个帐户下,添加三个球员。<br>3所示。注销的账户。<br>正因为如此,共有6名球员应该存在在数据库和他们应该“属于”<br>总共有两个用户。<br>下一步,使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>你会注意到,我们以前见过,所有返回的数据收集。我们可以<br>看到所有的数据属于两个用户。但这实际上是一个问题。因为除非<br>我们关闭这个功能,这个应用程序的每个用户将有同样的,肆无忌惮的访问权<br>每一个数据库内的数据。没有什么阻止他们深入挖掘<br>“PlayersList”收集的发现和获取功能。<br>访问所有的数据。<br>这个项目的数据不是特别敏感,它不像我们存储信用卡号码<br>——但:<br>发布和订阅112<br>1。如果我们存储敏感数据,这将是一个不可原谅的监督。<br>2。它有害的实践数据提供给用户当它不是必需的。<br>然而,这并乞求问题:<br>为什么这个功能存在的流星?如果是这样一个巨大的安全风险来访问数据<br>通过控制台,为什么允许这样做吗?<br>很简单,方便。在本书中,我们已经使用查找和获取<br>函数和他们伟大的工具来管理和操作的内容<br>数据库。只是,在我们与世界分享应用程序之前,我们必须:<br>1。禁用这种默认行为,限制访问的大部分数据。<br>2。精确地定义数据应该提供给特定的用户。<br>这就是我们将讨论接下来的章节。<br>发布和订阅113<br>autopublish<br>功能,允许我们使用控制台导航项目的数据<br>包含在一个“autopublish”包包含在默认情况下每个流星项目。<br>如果我们删除这个包,用户无法通过控制台访问任何数据,但它<br>也将打破应用程序,因此我们需要采取一些额外的步骤。<br>删除“autopublish”包从项目,运行以下命令:<br>流星删除autopublish<br>如果你登录的用户帐户删除包的时候,你不会注意到<br>任何不同,但尝试发现和获取功能:<br>.fetch PlayersList.find()();<br>你会注意到我们再也不能浏览里面的数据集合。唯一的<br>返回一个空数组。它看起来像数据已被删除,但事实并非如此。<br>它只是被获得。<br>现在问题是,我们的数据安全,因为如果我们登录的用户帐户,<br>数据也无法访问的接口:<br>没有可用的数据。<br>为了解决这个问题,我们需要找到一些我们面临的两个极端——之间的中间立场<br>一切都被访问和没有被访问。这涉及到精确的定义<br>数据应该提供给我们的用户。<br>发布和订阅114<br>isServer<br>在本书中,我们主要是在isClient条件编写代码。这是<br>因为我们大多写的代码意味着浏览器内运行(如代码<br>影响界面)。然而,很多情况下我们希望代码运行<br>在服务器上。<br>为了演示这些情况之一,地方在isServer如下声明<br>在JavaScript文件的条件:<br>.fetch console.log(PlayersList.find()());<br>不出所料,输出出现在命令行(而不是控制台),但要注意<br>我们没有任何麻烦检索“PlayersList”收集的数据。即使在<br>删除“autopublish”计划,我们有自由统治的数据直接在工作<br>与服务器。<br>为什么?<br>嗯,在服务器上执行的代码本身是可信的。所以,当我们停止用户<br>应用程序访问数据的前端——在客户端——我们可以继续<br>在服务器上检索数据。<br>你很快就会知道这个细节的有效性。<br>发布和订阅115<br>出版物,第1部分<br>在本节中,我们将发布“PlayersList”内的数据收集,和<br>从概念上讲,你能想到的出版数据传输数据到从服务器<br>醚。我们只是指定哪些数据应该提供给用户。我们不关心的地方<br>最终的数据。<br>为了实现这一点,删除控制台。日志声明isServer条件和替换它<br>一颗流星。发布功能:<br>Meteor.publish();<br>这个函数的括号之间,通过“应”作为第一个参数:<br>Meteor.publish(球员);<br>这个论点是一个名字,我们会参考。<br>然后,作为第二个参数,通过一个函数:<br>流星。发布(“球员”,函数(){<br>/ /内部发布功能<br>});<br>在这个函数,我们指定哪些数据应该提供给应用程序的用户。<br>在这种情况下,我们将返回所有的“PlayersList”收集的数据:<br>流星。发布(“球员”,函数(){<br>返回PlayersList.find()<br>});<br>这段代码复制autopublish的功能,这意味着它不是我们什么<br>想要的,但这是一个正确方向的一步。<br>发布和订阅116<br>订阅<br>因为流星。发布在服务器上执行的函数,我们现在可以订阅<br>这些数据在isClient条件,再一次做项目的数据访问<br>通过浏览器和控制台。<br>如果你想象一下,发布功能是传输数据到醚,然后订阅<br>函数是我们使用“捕捉”数据。<br>在isClient条件,写如下:<br>Meteor.subscribe();<br>这是流星。订阅功能,唯一的参数,我们需要通过<br>发布函数的名称:<br>Meteor.subscribe(球员);<br>保存文件,然后使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>你会注意到,再一次,我们可以访问所有的数据从项目的数据库,<br>意味着我们的应用程序是回到原来的状态。这还不是我们想要的,但这是另一个<br>重要的一步。<br>发布的所有数据。<br>发布和订阅117<br>出版物,第2部分<br>现在的目标是让流星。发布函数只从服务器发布数据<br>属于当前登录的用户。<br>这意味着:<br>1。登录用户只能访问自己的数据。<br>2。注销用户没有访问任何数据。<br>最后,应用程序将全功能保护潜在的敏感<br>数据。<br>为了达到这个目标,我们需要访问当前登录用户的惟一ID从内<br>流星。发布功能。在这个函数,我们不能使用Meteor.userId()<br>之前的功能。相反,我们必须使用下面的语句:<br>this.userId;<br>虽然语法是不同的,最终的结果是一样的。该语句返回唯一的<br>当前登录用户的ID。<br>声明在“currentUserId”变量:<br>流星。发布(“球员”,函数(){<br>var currentUserId = this.userId;<br>返回PlayersList.find()<br>});<br>然后改变找到函数只所以检索文档createdBy字段是相等的<br>当前登录用户的ID:<br>流星。发布(“球员”,函数(){<br>var currentUserId = this.userId;<br>PlayersList返回。找到({ createdBy:currentUserId })<br>});<br>保存文件,然后使用“PlayersList”上的发现和获取功能集合:<br>.fetch PlayersList.find()();<br>如果你登录,您只会看到的数据属于当前用户的帐户,如果<br>你没有登录,你不会看到任何数据。这是因为内部的返回语句<br>流星。发布函数只能返回文档,包含当前的惟一ID<br>用户。<br>发布和订阅118<br>返回一个有限选择的数据。<br>也知道,我们现在可以简化玩家从这个函数:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ createdBy:currentUserId },<br>{:{分数:1,名字:1 } });<br>}<br>…:<br>“球员”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList返回。找到({ },{:{分数:1,名字:1 } });<br>}<br>为什么?<br>因为球员内部的返回语句函数只能检索数据<br>从服务器发布。因此,指定要检索用户的数据<br>两个地方是多余的。我们只需要定义Meteor.publish中返回的数据<br>函数。<br>发布和订阅119<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,所有的数据在一个流星项目的数据库提供给所有用户<br>应用程序。这是方便的在开发期间,但它也是一个很大的安全漏洞<br>需要在部署前固定。<br>•这个默认功能都包含在一个“autopublish”包。如果我们删除这个<br>计划,项目将更安全,但它也会打破,需要固定的。<br>•流星。发布函数定义哪些数据应该在服务器端<br>提供给应用程序的用户。<br>•流星。订阅功能是用于客户端检索的数据<br>从服务器发布。<br>•在发布功能,我们不能使用Meteor.userId()函数,但我们可以<br>与this.userId检索当前用户的ID。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>方法<br>在前面的章节中,我们讨论的第一个包含两个主要的安全问题<br>每颗流星项目默认情况下。这个问题是用户通过导航的能力<br>所有的数据在数据库内部,直到我们把“autopublish”包。基于这些<br>我们做了改变,用户现在只有访问“属于”的数据。<br>为了演示第二个主要安全问题,输入以下命令控制台:<br>PlayersList。插入({ name:“伪玩家”,分数:1000 });<br>看有什么问题吗?<br>虽然我们已经取得了它所以用户不能浏览所有的数据在数据库中,用户<br>仍然能够自由使用控制台插入数据到数据库中。这意味着用户可以:<br>1。利用应用程序自己的优势。<br>2。数据库填充无用的、多余的数据。<br>用户还能够从数据库修改和删除数据,意味着在默认情况下,<br>他们主要有完全的管理权限。<br>与前面的安全问题,这个特性是当我们开发一个方便<br>应用程序,因为它很容易创建和管理数据,但这是一个我们需要的特性<br>关闭之前部署。<br>此功能包含在一个“没有安全感”包,我们可以删除它<br>项目使用下面的命令:<br>流星消除不安全的<br>删除包后,切换回Chrome和尝试和应用程序。<br>你会注意到:<br>•我们再也不能给分的球员。<br>•我们再也不能拿分的球员。<br>•我们再也不能从列表中移除玩家。<br>•我们再也不能将玩家添加到列表。<br>所有的插入、更新和删除功能停止工作——都通过<br>接口和控制台应用程序,所以更安全的结果,但是我们会有<br>解决很多事情。<br>120年<br>方法对121<br>创建一个方法<br>直到这个时候,所有的插入、更新和删除功能已经在isClient<br>有条件的。这是快速和容易的方法,但这也是为什么我们的应用程序<br>天生没有安全感。我们已经把这些敏感,clientside数据库驱动的功能。<br>更安全的做法是将这些函数isServer条件,也就是说:<br>1。数据库代码将执行服务器的可信的环境中。<br>2。用户无法使用这些函数从控制台,因为用户没有<br>直接访问服务器。<br>为了实现这一点,我们将创建我们的第一个方法,方法执行的代码块<br>在服务器上被触发后从客户端。如果这听起来奇怪,不要害怕。这是<br>其中的一次,之后在写出代码将帮助解释很多。<br>在isServer条件,写如下:<br>Meteor.methods({<br>/ /方法去这里<br>});<br>这是我们将使用代码块来创建我们的方法。你会发现语法很相似<br>我们如何创建两个助手和事件。<br>为了演示什么方法,创建一个“sendLogMessage”的方法:<br>Meteor.methods({<br>“sendLogMessage”<br>});<br>然后将该方法与功能:<br>Meteor.methods({<br>“sendLogMessage”:函数(){<br>控制台。日志(“Hello world”);<br>}<br>});<br>接下来,“电话”这个方法从底部的提交表单事件附加到“addPlayer -<br>形成“模板:<br>方法对122<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.playerName.value;<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>Meteor.call(“sendLogMessage”);<br>}<br>通过使用这颗流星。调用语句,通过我们创建的方法的名称,<br>我们能够触发方法时的执行“添加球员”提交表单。<br>保存文件,切换回Chrome,并提交“添加球员”形式。核心功能<br>这种形式的仍然是破碎的,但是如果你切换到命令行,您将看到“Hello<br>世界”的消息似乎每次提交表单。客户端表单的提交<br>触发的方法,但实际代码的方法是在服务器上执行。<br>代码在服务器上执行,导致当我们提交表单。<br>这个基本原则是我们在本章的其余部分使用。<br>方法对123<br>插入数据(再一次)<br>再次让应用程序工作,我们首先将插入函数里面提交<br>表单事件从客户机和服务器。<br>这意味着:<br>1。插入函数将成功地和安全地运行在服务器上。<br>2。用户仍然无法通过控制台插入数据。<br>换句话说,“添加球员”提交表单时,插入函数将触发<br>服务器从客户端触发后。<br>首先,“sendLogMessage”方法的名称更改为“insertPlayerData”,和摆脱<br>控制台。日志语句:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>/ /代码在这里<br>}<br>});<br>在方法内部,抓住当前登录用户的惟一ID:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>var currentUserId = Meteor.userId();<br>}<br>});<br>然后下面添加一个熟悉的插入函数声明:<br>Meteor.methods({<br>“insertPlayerData”:函数(){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>这里,我们通过一个硬编码值的“大卫”,这并不是我们所想要的,<br>但这已经足够好了。<br>返回到提交表单事件和删除currentUserId变量和插入<br>函数。事件应该类似于:<br>方法对124<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>Meteor.call(“sendLogMessage”);<br>}<br>但也一定要通过正确的方法名流星。调用语句:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>Meteor.call(“insertPlayerData”);<br>}<br>基于这些变化,“添加球员”形式将现在的工作。如果我们提交表单,<br>一个球员将被添加到“PlayersList”集合。我们只能添加球员叫“大卫”,<br>但在下一节我们将解决这个问题。<br>再次插入函数的工作。<br>现在,重要的是,用户可以添加玩家通过列表形式,<br>他们不能够使用插入函数从控制台。这意味着我们获得<br>控制用户如何与数据库的交互,这是一个保持应用程序的重要组成部分<br>安全。<br>方法对125<br>传递参数<br>“添加球员”形式的问题是文本字段的值没有被传递到<br>该方法。这样,当我们提交表单时,创建的球员的名字将永远<br>被设置为“大卫”。<br>为了解决这个问题,通过“playerNameVar”变量通过流星。调用语句作为第二<br>论点:<br>提交表单:函数(事件){<br>event.preventDefault();<br>var playerNameVar = event.target.playerName.value;<br>流星。调用(insertPlayerData,playerNameVar);<br>}<br>然后允许接受这个论点的方法通过将“playerNameVar”之间<br>括号的方法的功能:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:“大卫”,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>正因为如此,我们现在可以参考“playerNameVar”参考用户的价值<br>进入表单的文本字段:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>}<br>});<br>最后,这是发生了什么:<br>方法对126<br>首先,当提交表单时,“insertPlayerData”方法被调用时,和的值<br>表单的文本字段附加到电话。<br>第二,执行“insertPlayerData”方法。该方法接受的价值<br>“playerNameVar”变量,然后从里面引用变量方法的功能。<br>第三,插入函数内执行方法,因为这段代码运行在服务器上,<br>它可以运行没有“安全感”包。与刚才不同,这个函数使用价值<br>来自表单的文本字段,而不是硬编码的“大卫”的价值。<br>创建的球员与原名称。<br>表单将再次工作的预期,但仍然会是没有为用户操作方法<br>数据通过控制台。<br>方法对127<br>删除玩家(再一次)<br>以同样的方式,我们创建了一个“insertPlayerData”变量,我们要创建一个“removePlayerData”<br>方法,我们将连接到“删除的球员”按钮,里面是我们的接口。<br>就像我们如何创建助手和事件,我们的位置在一个代码块的方法,<br>记住要用逗号分开的方法:<br>Meteor.methods({<br>“insertPlayerData”:函数(playerNameVar){<br>var currentUserId = Meteor.userId();<br>PlayersList.insert({<br>名称:playerNameVar,<br>得分:0,<br>createdBy:currentUserId<br>});<br>},<br>“removePlayerData”:函数(){<br>/ /代码在这里<br>}<br>});<br>然后我们会点击两个变化。删除事件:<br>首先,去掉删除功能:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>在它的位置,创建另一个流星。调用语句:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>Meteor.call(“removePlayerData”);<br>}<br>通过“selectedPlayer”变量,第二个参数:<br>的点击。删除”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(removePlayerData,selectedPlayer);<br>}<br>允许接受这个论点的方法:<br>方法对128<br>“removePlayerData”:函数(selectedPlayer){<br>/ /代码在这里<br>}<br>然后重新创建删除方法内部的函数:<br>“removePlayerData”:函数(selectedPlayer){<br>PlayersList.remove(selectedPlayer);<br>}<br>“删除玩家”按钮将按预期工作,但用户仍然没有完成<br>管理访问数据库相关函数在控制台。<br>清除旧数据。<br>然而,一个挥之不去的问题…<br>因为“removePlayerData”方法执行从客户端,用户可以执行<br>同样的自称,从控制台:<br>流星。调用(‘ removePlayerData ‘,’ 8 sad8a90d8s9ad ‘);<br>因此,尽管他们没有获得全方位的插入、更新和删除功能<br>能做的,他们仍然可以做一些伤害。例如,他们可以运行这个命令来删除一个<br>玩家从另一个用户的列表。<br>这不是一个悲剧的巨大的安全漏洞,但这是我们应该解决的<br>准备在未来安全漏洞。<br>最好的做法是改变“removePlayerData”从这个方法:<br>方法对129<br>“removePlayerData”:函数(selectedPlayer){<br>PlayersList.remove(selectedPlayer);<br>}<br>…:<br>“removePlayerData”:函数(selectedPlayer){<br>var currentUserId = Meteor.userId();<br>PlayersList。remove({ _id:selectedPlayer createdBy:currentUserId });<br>}<br>有了这段代码,该方法将只允许玩家从列表中被删除<br>球员属于当前用户。<br>注意:你可能会认为它不太可能用户会让这样一个混乱与另一个<br>用户的排行榜,但当涉及到安全,最好不要低估人民的能力<br>和渴望肆虐。<br>方法对130<br>修改分数<br>在这一章,我们已经使用方法为了安全,但我们也可以使用<br>方法来减少我们的项目代码的数量。<br>为了说明这一点,我们要结合点击。增加并单击。衰减事件<br>成一个单一的方法。这是有可能的,因为有很多的这些事件之间共享代码:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>},<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>事实上,唯一的区别是在点击。增加事件,我们传递一个值<br>通过公司操作符“5”,而在点击。衰减事件,我们通过<br>一个“5”的价值。<br>改善这段代码中,我们首先关注点击。增量的事件。<br>在事件中,删除更新函数,代之以一个流星。调用语句:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(modifyPlayerScore,selectedPlayer);<br>}<br>这里,我们称之为“modifyPlayerScore”的方法,这是一个我们将创建方法<br>时刻,我们通过“selectedPlayer”变量。<br>创建内部的“modifyPlayerScore”方法方法:<br>“modifyPlayerScore”:函数(){<br>/ /代码在这里<br>}<br>…,让这个方法接受的价值“selectedPlayer”:<br>“modifyPlayerScore”:函数(selectedPlayer){<br>/ /代码在这里<br>}<br>然后,在该方法的功能,重新创建更新函数,我们刚才删除:<br>方法对131<br>“modifyPlayerScore”:函数(selectedPlayer){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>基于此代码,“给5分”按钮将正常工作。使更多的方法<br>不过,灵活返回点击。增加事件和通过“5”的第三个参数<br>流星。调用语句:<br>的点击。增量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(‘modifyPlayerScore selectedPlayer 5);<br>}<br>允许接受这个第三个参数的方法:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:5 } });<br>}<br>取代“5”的价值,在这个新创建的引用的方法<br>“scoreValue”属性:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });<br>}<br>由于这一变化,现在的方法是足够灵活,我们可以用它来“给<br>5分”按钮和“5分”按钮。<br>这里有…<br>首先,从内部点击删除更新函数。衰减事件:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>}<br>第二,一颗流星。调用语句在这个事件:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>Meteor.call(“modifyPlayerScore”);<br>}<br>第三,通过“selectedPlayer”变量的值:<br>方法对132<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(modifyPlayerScore,selectedPlayer);<br>}<br>第四,通过“5”的价值,而不只是“5”:<br>的点击。减量”:函数(){<br>var selectedPlayer = Session.get(“selectedPlayer”);<br>流星。调用(‘modifyPlayerScore selectedPlayer 5);<br>}<br>看到我们所做的吗?<br>我们已经取得了如此“modifyPlayerScore”方法的效用取决于我们通过<br>第三个参数:<br>1。如果我们通过一个“5”,更新函数增量的值<br>“分数”字段。<br>2。如果我们通过一个“5”,更新函数递减的价值<br>“分数”字段。<br>因此,该方法允许代码既灵活又安全。<br>我们有相同的安全缺陷前一节中,一个用户可以输入<br>下面的命令在控制台修改数据库中的任何球员的得分:<br>流星。调用(‘modifyPlayerScore’,‘8 sad8a90d8s9ad’,100);<br>但解决方案也是一样的。<br>从这只改变方法的内容:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>PlayersList。更新(selectedPlayer { $ . n:行情):{得分:scoreValue } });<br>}<br>…:<br>“modifyPlayerScore”:函数(selectedPlayer scoreValue){<br>var currentUserId = Meteor.userId();<br>PlayersList。更新({ _id:selectedPlayer createdBy:currentUserId },<br>{ $ . n:行情):{得分:scoreValue } });<br>}<br>再次,我们检索当前登录用户的惟一的ID,并在更新<br>正在更新功能,确保玩家“属于”用户。如果登录用户<br>并不“拥有”的球员,球员的文档不会被发现的更新功能。<br>方法对133<br>总结<br>在这一章,我们了解到:<br>•在默认情况下,有可能为用户插入、更新和删除数据的收集<br>使用JavaScript控制台。这对于开发方便,但存在安全风险<br>部署web应用程序。<br>•修复这个安全风险,我们必须从客户端数据库相关代码,<br>服务器的信任的环境。在这里,用户不会有任何直接访问(或<br>控制)数据库。<br>•这个安全风险是包含在一个“没有安全感”包。通过移除这个包,<br>应用程序将变得更加安全,但它也会休息,因为没有一个databaserelated<br>功能将工作。<br>•通过使用方法,我们能够编写代码在服务器上运行后第一个被触发<br>从客户端。这是我们如何修复项目的破碎功能。<br>•创建方法,我们可以在方法中定义块,然后触发<br>从其他地方的代码使用流星。调用语句。<br>•我们可以从流星传递数据。调用语句和方法,让我们<br>使用提交的数据表单内的方法。<br>•用户可以执行客户端流星。通过控制台调用语句,所以我们需要<br>注意这些语句允许用户做什么。<br>•方法不仅适用于安全。他们也有用结合相似的块<br>的功能到一个小的和可重复的代码片段。<br>流星的更深层次的理解:<br>•在一个新项目,首先删除“不安全”计划,从一开始,地方<br>里面所有的数据库相关代码的方法。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>结构<br>在本书中,我们把所有的项目的代码仅仅三个文件:<br>•leaderboard.html<br>•leaderboard.js<br>•leaderboard.css<br>这使得我们关注的基本面与流星没有构建软件<br>担心代码是如何组织的,该项目是非常简单的,所以我们需要不<br>需要其他文件,但:<br>1。在构建大型应用程序,是有意义的传播项目的代码在一个<br>数量的文件。<br>2。流星有许多公约组织项目的文件。<br>在我们继续之前,有两个问题需要考虑:<br>首先,流星没有硬性规定如何构造一个项目。有<br>流星鼓励某些准则,但没有严格的,你必须做的。你的喜好<br>最终在控制。<br>第二,人们仍然找出最佳实践在处理流星。因此,<br>没有理由形式教条的观点项目“应该”是如何构造的。允许<br>自己的实验。<br>这一章也不同,我们不会重组项目step-bystep排行榜。<br>相反,我们将讨论结构的原则,这些原则,这就是你的工作<br>付诸实践。<br>不过别担心。<br>基于我们覆盖到目前为止,处理如何构造一颗流星<br>应用程序将是小菜一碟。<br>134年<br>结构135<br>你的项目,你的选择<br>就像我说的,流星没有硬性规定如何组织一个项目。它不<br>关心如何组织你的文件和文件夹,如果你想创建一个大型项目<br>只是三个文件,你可以。<br>不过,与这种灵活性带来选择的矛盾:<br>如果你不局限于精确的规则,如何构建您的项目吗?<br>如果你是一个开发人员开始,您的项目结构尽可能简单的只要你<br>可以。这意味着传播您的代码在仅仅三个文件——HTML,JavaScript,和CSS<br>文件,直到这些文件变得过于臃肿的轻松地管理。这是罕见的一个实际的应用<br>包含在这样一个小结构,但如果你只是开始使用流星,它是<br>不生产为“完美”的结构。<br>仍然阅读这一章,有一些重要的约定要注意——但不要<br>觉得有必要实现每一个细节。最佳实践更容易学习一次<br>基本面已经吸收了,只要你是一个初学者,你可以变得很糟。<br>如果你不是一个开发人员,这意味着开始,如果你有网站开发经验,<br>和没有任何麻烦连同这本书,那么你会有一个简单的时间<br>实现约定我们要讨论。<br>结构136<br>脂肪薄文件,文件<br>当创建一个流星应用程序时,项目的文件可以作为“瘦”或“脂肪”,因为我们想要的<br>他们是。这意味着:<br>1。我们可以传播许多文件的代码。<br>2。我们可以包很多每个文件(或小)代码。<br>例如,让我们考虑一下”排行榜。html文件。不是脂肪,但它确实包含了<br>三个组件,虽然连接,不需要包含在单一文件:<br>•页面的HTML结构(头部标签,身体标签等)。<br>•“排行榜”模板。<br>•“addPlayerForm”模板。<br>如果这个项目变得越来越大,这将使这些组件拆分为三个<br>单独的文件。例如,你可能会想:<br>1。离开的HTML结构”排行榜。html文件。<br>2。把“排行榜”的“leaderboardList模板。html文件。<br>3所示。移动模板,一个“addPlayerForm addPlayerForm。html文件。<br>因此,它会更容易导航项目的文件因为每个文件的名称<br>暗示这文件包含什么。<br>需要澄清的是:<br>1。没有额外的步骤。把代码项目,无论你想要的<br>流星将知道如何把片段组合在一起。<br>2。文件名称是任意的。有一些“特殊”的文件名需要注意的,但是<br>一般来说,名字的文件,只要你喜欢就好。<br>你也可以将文件在文件夹和子文件夹(深层结构),但在那里<br>某些约定,鼓励某些命名这些文件夹的方法。<br>结构137<br>文件夹的约定,第1部分<br>很多内部的代码”排行榜。js”isClient条件内的文件。如果我们传播<br>这段代码在多个文件,它会不雅的重用这个条件<br>一次。<br>幸运的是,流星已经约定,任何的代码放在一个文件夹命名为“客户端”<br>只会在客户端上运行。<br>为了演示这个:<br>1。创建一个文件夹命名为“客户”在您的项目的文件夹。<br>2。在该文件夹中创建一个JavaScript文件。<br>3所示。剪切和粘贴的客户端代码”排行榜。js文件到新的文件,但是<br>没有isClient条件。<br>在保存文件时,应用程序将继续正常工作。<br>因为这个约定,最好是将模板,事件,助手,Meteor.subscribe<br>函数在一个“客户端”文件夹中。<br>相反,流星有约定的任何代码放置在一个文件夹命名<br>“服务器”只会在服务器上运行。这是我们地方项目的方法,和<br>流星。发表声明。<br>洗牌代码在排行榜内部应用程序之后,唯一的,左内<br>原始”排行榜。js文件将被声明,创建“PlayersList”集合。我们<br>希望这段代码运行在客户端和服务器,所以一定要离开这个声明<br>在“客户机”和“服务器”文件夹。一个常见的惯例是将这段代码在一个<br>”集合。js文件,但是这个文件名字没有特别的意义。<br>结构138<br>文件夹约定,第2部分<br>当开始使用流星,大多数项目的文件可能会在“客户端”<br>或“服务器”文件夹。然而,一些其他的文件夹名称,可用于不同的<br>用途:<br>•文件存储在一个“私人”文件夹只能访问的代码的执行<br>服务器。这些文件将永远不会访问用户。<br>•文件存储在一个“公共”文件夹是游客服务。这些文件是图片,图标,<br>和“机器人。txt文件。<br>•文件存储在一个“自由”文件夹其他文件之前加载。<br>但如果这一切似乎记得太多,不要害怕。这些细节是值得了解的<br>未来的参考,但这将是一段时间你需要付诸实施了。目前,<br>很好关注基础知识。<br>结构139<br>样板结构<br>学习如何结构的一种有效方式流星项目向其他开发人员学习<br>有可能遇到的许多问题有一天,你会遇到你。<br>例如,“铁”工具从克里斯事件化思想的源泉:<br>命令行脚手架流星应用程序的工具。它会自动创建<br>项目的结构,文件和样板代码。<br>这个工具可以用来快速创建一个项目使用以下结构:<br>我的app /<br>.iron /<br>json<br>bin /<br>构建/<br>配置/<br>开发/<br>env.sh<br>settings.json<br>app /<br>客户端/<br>集合/<br>lib /<br>样式表/<br>模板/<br>head.html<br>lib /<br>集合/<br>控制器/<br>methods.js<br>routes.js<br>包/<br>私人/<br>公共/<br>服务器/<br>集合/<br>控制器/<br>lib /<br>methods.js<br>publish.js<br>bootstrap.js<br>你会发现每件事都有它的位置。有文件夹集合和样式表<br>模板和其他组件的一个项目。<br>结构140<br>这是最好的方法构造一颗流星项目吗?<br>对一些人来说,它可能是。<br>我认为这有点复杂的人与流星刚刚开始,但当<br>你准备搬到一个更大的项目,它可能正是你需要管理<br>较大的基础代码。<br>在这个阶段,重点不是做出任何硬性的决定对你的偏好。但它<br>帮助了解什么至少是可能的。<br>其他样板值得一试,学习包括meteor-boilerplate和空白。<br>结构141<br>总结<br>在这一章,我们了解到:<br>•流星并不在项目执行精确的文件结构。有简单的约定<br>我们鼓励遵守为了我们自己的利益。<br>•通过命名特定文件夹,在某些方面,我们能够避免编写一些应用程序<br>逻辑基于流星如何处理这些文件夹。<br>流星的更深层次的理解:<br>•搜索别人的流星在GitHub,看看真实的项目<br>应用程序的结构。<br>•想象你创建一个博客应用程序像WordPress。你会如何结构<br>该应用程序?计划在一张纸上。<br>在其当前状态查看代码,查看GitHub提交。</p>\n<p>部署<br>在本书中,我们取得了很多的进步。我们决定在项目建设,创建<br>所有的基本功能,添加了一些额外的细节,甚至谈到了几个<br>常见的安全问题。<br>因此,我们准备部署到web的应用程序。<br>在这里我们可以分享我们的创造与世界然后等待成群的陌生人<br>奇迹在我们的天才。但部署并不是简单的上传文件到web服务器。<br>有更多的参与。<br>这是一个广泛的部署过程的概述:<br>1。创建一个服务器DigitalOcean等网站。<br>2。在该服务器上安装所需的软件(节点,MongoDB,等等)。<br>3所示。配置所有的安装软件。<br>4所示。项目的文件上传到服务器。<br>5。交叉你的手指,没有休息。<br>听起来很复杂,对吗?<br>不要担心,我有你覆盖。<br>在这本书的前两个版本,我解释的绝对基础部署流星<br>应用程序web但已经放在一起更全面的指导,分开<br>从这本书。<br>你可以免费在线阅读:<br>meteortips.com/deployment-tutorial<br>如果你想尽快部署的东西,你只需要阅读第一<br>两个章,但是当你准备发射比throwntogether更有趣的东西<br>轻轻原型,这本书将指导您完成每一步的过程中,<br>与其他我发布在网上,你也可以看到很多的更新<br>部署实践的变化和发展。<br>也就是说,如果你不希望将应用程序部署到世界,这很好。<br>没有什么关于部署,你需要知道这一点。这个过程是相当<br>开发过程和截然不同的东西,直到你已经开发了应用程序,你的<br>时间是更好的在一个文本编辑器,编写代码,使事情。<br>142年<br>结论<br>祝贺你。你已经达到了这本书的最后一页。在第一章,就像我说的<br>这本书不是汤姆。有更多了解建筑与流星很酷的东西<br>框架。<br>这就是我建议:<br>1。如果你还没有,实际上我们已经构建排行榜应用程序<br>讨论这本书。没有更好的方法来学习如何比通过编写代码<br>每一行,循序渐进。<br>2。看流星的官方文档。你可能不理解每一点<br>它,但它确实提供了洞察如何以及为什么某些特性工作的方式做。<br>3所示。遵循“如何正确学习流星”的路线图。这是一个彻底的课程<br>成为一个全面的流星开发者(那就推荐这个<br>书)。<br>如果你还没有,请访问meteortips.com并注册电子邮件时事通讯。这是<br>最好的方法是不管我工作,帮助你做出更大、更快<br>进步与流星。<br>这就是现在。<br>祝你好运,和说话很快。<br>€”大卫·特恩布尔<br>注:如果你喜欢这本书,在Amazon.com上留下评论。你的支持让我<br>花更多的时间来研究新材料。</p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4w74u3c0000acelres86ti8","category_id":"ck4w74u3r0002acelllplz0gh","_id":"ck4w74u470008acel5y0cov4k"},{"post_id":"ck4w74u3r0001acelqn3y0qog","category_id":"ck4w74u3r0002acelllplz0gh","_id":"ck4w74u47000bacel7idzi2xk"},{"post_id":"ck4w74u5i000oacelq6uwuk7p","category_id":"ck4w74u5y000pacelsxe10xxw","_id":"ck4w74u5y000sacelmkvub3to"}],"PostTag":[{"post_id":"ck4w74u3c0000acelres86ti8","tag_id":"ck4w74u3r0003acelsn9pjfnx","_id":"ck4w74u470007aceldu1rw8vq"},{"post_id":"ck4w74u3r0001acelqn3y0qog","tag_id":"ck4w74u470006aceltfj8vwkd","_id":"ck4w74u47000aacel45qgmvgw"},{"post_id":"ck4w74u3r0004acelh1hdxrp9","tag_id":"ck4w74u470009acelue1rz697","_id":"ck4w74u47000cacelxcdsaoiz"},{"post_id":"ck4w74u4n000facel0isrqacv","tag_id":"ck4w74u4n000hacelh1vlwil2","_id":"ck4w74u53000kacelat7dzx2x"},{"post_id":"ck4w74u4n000gacelx1idnio6","tag_id":"ck4w74u53000jacele5qcfqsy","_id":"ck4w74u53000macelhs3qmsvp"},{"post_id":"ck4w74u4n000iacelbqrqmztt","tag_id":"ck4w74u53000lacelhusxtbe9","_id":"ck4w74u53000nacelvmvsgego"},{"post_id":"ck4w74u5i000oacelq6uwuk7p","tag_id":"ck4w74u5y000qacelo0dgpqq0","_id":"ck4w74u5y000racelcm0n4p61"},{"post_id":"ck4w74u5y000tacele6r9rzj0","tag_id":"ck4w74u470009acelue1rz697","_id":"ck4w74u6d000uacel3oxst4n5"}],"Tag":[{"name":"出纳专家旗舰版","_id":"ck4w74u3r0003acelsn9pjfnx"},{"name":"全真打印软件","_id":"ck4w74u470006aceltfj8vwkd"},{"name":"你的第一个Meteor应用","_id":"ck4w74u470009acelue1rz697"},{"name":"西游记外传之金箍棒之殇","_id":"ck4w74u4n000hacelh1vlwil2"},{"name":"编译thrift0.11","_id":"ck4w74u53000jacele5qcfqsy"},{"name":"网络安全","_id":"ck4w74u53000lacelhusxtbe9"},{"name":"敏捷技能修炼","_id":"ck4w74u5y000qacelo0dgpqq0"}]}}